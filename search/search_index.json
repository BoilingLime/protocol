{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rarible Protocol Overview \u00b6 Rarible Protocol is a tool to query, issue and trade NFTs on these blockchains: Ethereum Flow (WIP, currently on devnet) Tezos (WIP, currently on granada testnet) Polygon (WIP, coming soon) Other blockchains ( tell us what blockchain you want) Getting Started \u00b6 Install and start to use Protocol SDK Use Protocol API Look at Example App for a quick start. Protocol Features \u00b6 query information about NFTs mint (issue, create) NFTs trade NFTs ( sell , bid , auction ) transfer burn Architecture \u00b6 The architecture of the Protocol: Protocol is based on the blockchain layer (smart contracts written for every blockchain supported). These smart contracts allow users to mint and exchange tokens. On top of the contracts we built indexers to index part of the blockchain state. This gives us the possibility to query data about NFTs. Then, SDKs were written to interact with smart contracts. All these components are written for every blockchain supported and are used in Union service and Union SDK Applications need to integrate Union service and Union SDK to be able to interact with all blockchains in the same way. Suggestions \u00b6 You are welcome to suggest features and report bugs found ! Audits \u00b6 Rarible Protocol is audited. Check this report by ChainSecurity.com . License \u00b6 Rarible Protocol is available under GPL v3 . SDK and openapi (with generated clients) are available under MIT .","title":"Rarible Protocol Overview"},{"location":"#rarible-protocol-overview","text":"Rarible Protocol is a tool to query, issue and trade NFTs on these blockchains: Ethereum Flow (WIP, currently on devnet) Tezos (WIP, currently on granada testnet) Polygon (WIP, coming soon) Other blockchains ( tell us what blockchain you want)","title":"Rarible Protocol Overview"},{"location":"#getting-started","text":"Install and start to use Protocol SDK Use Protocol API Look at Example App for a quick start.","title":"Getting Started"},{"location":"#protocol-features","text":"query information about NFTs mint (issue, create) NFTs trade NFTs ( sell , bid , auction ) transfer burn","title":"Protocol Features"},{"location":"#architecture","text":"The architecture of the Protocol: Protocol is based on the blockchain layer (smart contracts written for every blockchain supported). These smart contracts allow users to mint and exchange tokens. On top of the contracts we built indexers to index part of the blockchain state. This gives us the possibility to query data about NFTs. Then, SDKs were written to interact with smart contracts. All these components are written for every blockchain supported and are used in Union service and Union SDK Applications need to integrate Union service and Union SDK to be able to interact with all blockchains in the same way.","title":"Architecture"},{"location":"#suggestions","text":"You are welcome to suggest features and report bugs found !","title":"Suggestions"},{"location":"#audits","text":"Rarible Protocol is audited. Check this report by ChainSecurity.com .","title":"Audits"},{"location":"#license","text":"Rarible Protocol is available under GPL v3 . SDK and openapi (with generated clients) are available under MIT .","title":"License"},{"location":"ethereum/contract-addresses/","text":"Contract Addresses \u00b6 Here you can find Rarible Smart Contracts deployed instances across Ethereum Ropsten Testnet, Rinkeby Testnet and Mainnet. Mainnet \u00b6 Asset Contract ERC721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C \u2197 Asset Contract ERC1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 \u2197 Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 \u2197 External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD \u2197 ERC721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 \u2197 ERC1155 Token Factory 0x81243681078bEE8e251D02Ee6872b1EAa6DD982A \u2197 Rinkeby \u00b6 Is known to usually be more reliable than Ropsten. Asset Contract ERC721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 \u2197 Asset Contract ERC1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 \u2197 Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b \u2197 External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 \u2197 NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 \u2197 ERC721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf \u2197 ERC1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d \u2197 Ropsten \u00b6 Is known to be less reliable. Asset Contract ERC721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 \u2197 Asset Contract ERC1155 0x6a94aC200342AC823F909F142a65232E2f052183 \u2197 Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD \u2197 External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B \u2197 NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 \u2197 ERC721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 \u2197 ERC1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e \u2197","title":"Contract Addresses"},{"location":"ethereum/contract-addresses/#contract-addresses","text":"Here you can find Rarible Smart Contracts deployed instances across Ethereum Ropsten Testnet, Rinkeby Testnet and Mainnet.","title":"Contract Addresses"},{"location":"ethereum/contract-addresses/#mainnet","text":"Asset Contract ERC721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C \u2197 Asset Contract ERC1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 \u2197 Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 \u2197 External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD \u2197 ERC721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 \u2197 ERC1155 Token Factory 0x81243681078bEE8e251D02Ee6872b1EAa6DD982A \u2197","title":"Mainnet"},{"location":"ethereum/contract-addresses/#rinkeby","text":"Is known to usually be more reliable than Ropsten. Asset Contract ERC721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 \u2197 Asset Contract ERC1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 \u2197 Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b \u2197 External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 \u2197 NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 \u2197 ERC721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf \u2197 ERC1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d \u2197","title":"Rinkeby"},{"location":"ethereum/contract-addresses/#ropsten","text":"Is known to be less reliable. Asset Contract ERC721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 \u2197 Asset Contract ERC1155 0x6a94aC200342AC823F909F142a65232E2f052183 \u2197 Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD \u2197 External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B \u2197 NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 \u2197 ERC721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 \u2197 ERC1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e \u2197","title":"Ropsten"},{"location":"ethereum/ethereum-overview/","text":"Rarible Protocol Ethereum \u00b6 Overview \u00b6 Rarible Protocol Ethereum is a set of tools to query, issue, and trade NFTs in the Ethereum blockchain network. It consists of Smart Contracts, Indexer, API, and SDK. Main features: Decentralized Exchange Open Source Indexer Minting single (ERC-721) and multiple (ERC-1155) tokens, including lazy minting Ability to share Fees Royalties Support Public Order Book Smart Contracts \u00b6 Rarible Smart Contracts for Ethereum are stored on the Ethereum blockchain. They will run when predetermined conditions are met. To see more details about the smart contracts as well as their code, check the Smart Contracts page or the Protocol Contracts github repo. API Reference \u00b6 Use these base URLs to access API on different Ethereum networks: Base URL Network Chain ID https://ethereum-api.rarible.org/v0.1/doc Mainnet 1 https://ethereum-api-staging.rarible.org/v0.1/doc Rinkeby 4 https://ethereum-api-dev.rarible.org/v0.1/doc Ropsten 3 https://ethereum-api-e2e.rarible.org/v0.1/doc - - See the page API and Indexer to see how to work with the API. For more information, see Ethereum Indexer and Ethereum OpenAPI repos on GitHub. SDK \u00b6 Rarible Protocol Ethereum SDK can help interact with your application and the Rarible protocol. Main features: Create Mint and Lazy Minting ERC-721 and ERC-1155 tokens Create Sell Orders Create and accept Bid Buy tokens Transfer tokens Burn tokens For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.","title":"Ethereum Overview"},{"location":"ethereum/ethereum-overview/#rarible-protocol-ethereum","text":"","title":"Rarible Protocol Ethereum"},{"location":"ethereum/ethereum-overview/#overview","text":"Rarible Protocol Ethereum is a set of tools to query, issue, and trade NFTs in the Ethereum blockchain network. It consists of Smart Contracts, Indexer, API, and SDK. Main features: Decentralized Exchange Open Source Indexer Minting single (ERC-721) and multiple (ERC-1155) tokens, including lazy minting Ability to share Fees Royalties Support Public Order Book","title":"Overview"},{"location":"ethereum/ethereum-overview/#smart-contracts","text":"Rarible Smart Contracts for Ethereum are stored on the Ethereum blockchain. They will run when predetermined conditions are met. To see more details about the smart contracts as well as their code, check the Smart Contracts page or the Protocol Contracts github repo.","title":"Smart Contracts"},{"location":"ethereum/ethereum-overview/#api-reference","text":"Use these base URLs to access API on different Ethereum networks: Base URL Network Chain ID https://ethereum-api.rarible.org/v0.1/doc Mainnet 1 https://ethereum-api-staging.rarible.org/v0.1/doc Rinkeby 4 https://ethereum-api-dev.rarible.org/v0.1/doc Ropsten 3 https://ethereum-api-e2e.rarible.org/v0.1/doc - - See the page API and Indexer to see how to work with the API. For more information, see Ethereum Indexer and Ethereum OpenAPI repos on GitHub.","title":"API Reference"},{"location":"ethereum/ethereum-overview/#sdk","text":"Rarible Protocol Ethereum SDK can help interact with your application and the Rarible protocol. Main features: Create Mint and Lazy Minting ERC-721 and ERC-1155 tokens Create Sell Orders Create and accept Bid Buy tokens Transfer tokens Burn tokens For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.","title":"SDK"},{"location":"ethereum/api/create-lazy-minting/","text":"Using Lazy Minting \u00b6 To mint an NFT using Lazy Minting, use the mintNftAsset method in nft-lazy-mint-controller . mintNftAsset \u00b6 Creates a Lazy Minted NFT token. https://ethereum-api-staging.rarible.org/v0.1/nft/mints Example request (staging): curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/nft/mints' \\ --header 'content-type: application/json' \\ --data-raw '{\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"@type\":\"ERC721\",\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"]}' Request parameters: @typerequired \u2014 token type ERC721 or ERC1155 supply \u2014 the total number of tokens for Mint. Only for ERC-1155 contract \u2014 address of the smart contract tokenId \u2014 token ID uri \u2014 suffix for the token URI. The prefix is usually ipfs:/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of digital signatures. Each creator must have a signature the only exception being when the creator sends a mint transaction. Response example (status 200): { \"id\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"contract\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"creators\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 10000 } ], \"supply\" : \"1\" , \"lazySupply\" : \"1\" , \"owners\" : [ \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" ], \"royalties\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 1000 } ], \"date\" : \"2021-11-23T15:37:03.610Z\" , \"pending\" : [], \"deleted\" : false , \"meta\" : { \"name\" : \"Violence Token\" , \"description\" : \"\" , \"attributes\" : [], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmbnW9qS5dcmXavo55yqzmF79wWT6qTcYKBAAaS3gDgrDa/image.jpeg\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/jpeg\" , \"width\" : 400 , \"height\" : 400 } } } } } Response parameters: id \u2014 item ID, has the format ${contract}:${tokenId} contract \u2014 address of the smart contract tokenId \u2014 token ID creators \u2014 array of information about creators supply \u2014 number of tokens created lazysupply \u2014 the number of Lazy Minting tokens created owners \u2014 array of information about token owners royalties \u2014 an array of information about royalties date \u2014 date of token creation pending \u2014 whether the item is incomplete. For example, it is in the status TRANSFER deleted \u2014 is the order deleted meta \u2014 meta information about the item","title":"Create Lazy Minting"},{"location":"ethereum/api/create-lazy-minting/#using-lazy-minting","text":"To mint an NFT using Lazy Minting, use the mintNftAsset method in nft-lazy-mint-controller .","title":"Using Lazy Minting"},{"location":"ethereum/api/create-lazy-minting/#mintnftasset","text":"Creates a Lazy Minted NFT token. https://ethereum-api-staging.rarible.org/v0.1/nft/mints Example request (staging): curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/nft/mints' \\ --header 'content-type: application/json' \\ --data-raw '{\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"@type\":\"ERC721\",\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"]}' Request parameters: @typerequired \u2014 token type ERC721 or ERC1155 supply \u2014 the total number of tokens for Mint. Only for ERC-1155 contract \u2014 address of the smart contract tokenId \u2014 token ID uri \u2014 suffix for the token URI. The prefix is usually ipfs:/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of digital signatures. Each creator must have a signature the only exception being when the creator sends a mint transaction. Response example (status 200): { \"id\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"contract\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"creators\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 10000 } ], \"supply\" : \"1\" , \"lazySupply\" : \"1\" , \"owners\" : [ \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" ], \"royalties\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 1000 } ], \"date\" : \"2021-11-23T15:37:03.610Z\" , \"pending\" : [], \"deleted\" : false , \"meta\" : { \"name\" : \"Violence Token\" , \"description\" : \"\" , \"attributes\" : [], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmbnW9qS5dcmXavo55yqzmF79wWT6qTcYKBAAaS3gDgrDa/image.jpeg\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/jpeg\" , \"width\" : 400 , \"height\" : 400 } } } } } Response parameters: id \u2014 item ID, has the format ${contract}:${tokenId} contract \u2014 address of the smart contract tokenId \u2014 token ID creators \u2014 array of information about creators supply \u2014 number of tokens created lazysupply \u2014 the number of Lazy Minting tokens created owners \u2014 array of information about token owners royalties \u2014 an array of information about royalties date \u2014 date of token creation pending \u2014 whether the item is incomplete. For example, it is in the status TRANSFER deleted \u2014 is the order deleted meta \u2014 meta information about the item","title":"mintNftAsset"},{"location":"ethereum/api/create-orders/","text":"Create Orders \u00b6 To create an order, use the upsertOrder method in order-controller . upsertOrder \u00b6 Creates or updates an Order. https://ethereum-api.rarible.org/v0.1/order/orders Example request (staging): curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/order/orders' \\ --header 'content-type: application/json' \\ --data-raw '{\"maker\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"type\":\"RARIBLE_V2\",\"data\":{\"dataType\":\"RARIBLE_V2_DATA_V1\",\"payouts\":[],\"originFees\":[{\"account\":\"0x76c5855e93bd498b6331652854c4549d34bc3a30\",\"value\":250}]},\"salt\":\"86881339267547208763979074509610437060593762063071194041427040496432360352297\",\"signature\":\"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\",\"make\":{\"assetType\":{\"@type\":\"ERC721\",\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"],\"assetClass\":\"ERC721_LAZY\"},\"value\":\"1\"},\"take\":{\"assetType\":{\"assetClass\":\"ETH\"},\"value\":\"10000000000000000\"}}' Request parameters: type \u2014 order type RARIBLE_V1 or RARIBLE_V2 data \u2014 data for creating or updating the order. The required fields depend on order type maker \u2014 address of the order creator taker \u2014 address of the recipient of the order (optional) make \u2014 make the side of the order. What the creator has take \u2014 take the side of the order. What the creator wants to get in exchange for the make side salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash start \u2014 the start date of the order placement, from which the buyer can make a Bid (optional) p.s. unix time is used end \u2014 the end date of the order placement, before which the buyer can make a Bid (optional) p.s. unix time is used signature \u2014 the digital signature of the order creator Response example (status 200): { \"type\" : \"RARIBLE_V2\" , \"maker\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"make\" : { \"assetType\" : { \"assetClass\" : \"ERC721_LAZY\" , \"contract\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"uri\" : \"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\" , \"creators\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\" ] }, \"value\" : \"1\" , \"valueDecimal\" : 1 }, \"take\" : { \"assetType\" : { \"assetClass\" : \"ETH\" }, \"value\" : \"10000000000000000\" , \"valueDecimal\" : 0.01 }, \"fill\" : \"0\" , \"fillValue\" : 0 , \"makeStock\" : \"1\" , \"makeStockValue\" : 1 , \"cancelled\" : false , \"salt\" : \"0xc015186be955e586fb9d3bc1ddbbf43470a40d18b4ccdc750af405155eee6a29\" , \"signature\" : \"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\" , \"createdAt\" : \"2021-11-23T15:37:13.158Z\" , \"lastUpdateAt\" : \"2021-11-23T15:37:13.158Z\" , \"pending\" : [], \"hash\" : \"0x279863b844f7bae2db201bff5abd9467f380eb029399e1339671d9d51f9a0280\" , \"makeBalance\" : \"0\" , \"makePrice\" : 0.01 , \"makePriceUsd\" : 40.193574609729986 , \"priceHistory\" : [ { \"date\" : \"2021-11-23T15:37:13.158Z\" , \"makeValue\" : 1 , \"takeValue\" : 0.01 } ], \"status\" : \"ACTIVE\" , \"data\" : { \"dataType\" : \"RARIBLE_V2_DATA_V1\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } Response parameters: type \u2014 order type RARIBLE_V1 , RARIBLE_V2 , OPEN_SEA_V1 or CRYPTO_PUNK data \u2014 information about order type, Fees, etc. maker \u2014 address of the order creator taker \u2014 address of the recipient of the order make \u2014 make the order side. What the creator has take \u2014 take the side of the order. What the creator wants to get in exchange for the make side fill \u2014 filling in data when matching fillvalue \u2014 data filling value start \u2014 the starting date of the order placement, from which the buyer can make a Bid end \u2014 the end date of the order placement before which the buyer can make a Bid makestock \u2014 how much is available for sale makestockvalue \u2014 the value of how much is available for sale cancelled \u2014 the order is canceled or not salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash signature \u2014 digital signature of the order creator createdAt \u2014 date of order creation lastupdateat \u2014 order update date pending \u2014 whether the order is incomplete. For example, it is in the status of CANCEL , ORDER_SIDE_MATCH or ON_CHAIN_ORDER hash \u2014 hash of the order makebalance \u2014 balance of the order creator makeprice \u2014 order price Takeprice \u2014 buyer's suggested price makepriceusd \u2014 order price in USD takepriceusd \u2014 price in USD suggested by the buyer pricehistory \u2014 history of price changes status \u2014 order status ACTIVE , FILLED , HISTORICAL , INACTIVE or CANCELLED","title":"Create Orders"},{"location":"ethereum/api/create-orders/#create-orders","text":"To create an order, use the upsertOrder method in order-controller .","title":"Create Orders"},{"location":"ethereum/api/create-orders/#upsertorder","text":"Creates or updates an Order. https://ethereum-api.rarible.org/v0.1/order/orders Example request (staging): curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/order/orders' \\ --header 'content-type: application/json' \\ --data-raw '{\"maker\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"type\":\"RARIBLE_V2\",\"data\":{\"dataType\":\"RARIBLE_V2_DATA_V1\",\"payouts\":[],\"originFees\":[{\"account\":\"0x76c5855e93bd498b6331652854c4549d34bc3a30\",\"value\":250}]},\"salt\":\"86881339267547208763979074509610437060593762063071194041427040496432360352297\",\"signature\":\"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\",\"make\":{\"assetType\":{\"@type\":\"ERC721\",\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"],\"assetClass\":\"ERC721_LAZY\"},\"value\":\"1\"},\"take\":{\"assetType\":{\"assetClass\":\"ETH\"},\"value\":\"10000000000000000\"}}' Request parameters: type \u2014 order type RARIBLE_V1 or RARIBLE_V2 data \u2014 data for creating or updating the order. The required fields depend on order type maker \u2014 address of the order creator taker \u2014 address of the recipient of the order (optional) make \u2014 make the side of the order. What the creator has take \u2014 take the side of the order. What the creator wants to get in exchange for the make side salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash start \u2014 the start date of the order placement, from which the buyer can make a Bid (optional) p.s. unix time is used end \u2014 the end date of the order placement, before which the buyer can make a Bid (optional) p.s. unix time is used signature \u2014 the digital signature of the order creator Response example (status 200): { \"type\" : \"RARIBLE_V2\" , \"maker\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"make\" : { \"assetType\" : { \"assetClass\" : \"ERC721_LAZY\" , \"contract\" : \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"83144199935168800027256855471009236590928205711995533202494108027144764391425\" , \"uri\" : \"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\" , \"creators\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\" ] }, \"value\" : \"1\" , \"valueDecimal\" : 1 }, \"take\" : { \"assetType\" : { \"assetClass\" : \"ETH\" }, \"value\" : \"10000000000000000\" , \"valueDecimal\" : 0.01 }, \"fill\" : \"0\" , \"fillValue\" : 0 , \"makeStock\" : \"1\" , \"makeStockValue\" : 1 , \"cancelled\" : false , \"salt\" : \"0xc015186be955e586fb9d3bc1ddbbf43470a40d18b4ccdc750af405155eee6a29\" , \"signature\" : \"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\" , \"createdAt\" : \"2021-11-23T15:37:13.158Z\" , \"lastUpdateAt\" : \"2021-11-23T15:37:13.158Z\" , \"pending\" : [], \"hash\" : \"0x279863b844f7bae2db201bff5abd9467f380eb029399e1339671d9d51f9a0280\" , \"makeBalance\" : \"0\" , \"makePrice\" : 0.01 , \"makePriceUsd\" : 40.193574609729986 , \"priceHistory\" : [ { \"date\" : \"2021-11-23T15:37:13.158Z\" , \"makeValue\" : 1 , \"takeValue\" : 0.01 } ], \"status\" : \"ACTIVE\" , \"data\" : { \"dataType\" : \"RARIBLE_V2_DATA_V1\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } Response parameters: type \u2014 order type RARIBLE_V1 , RARIBLE_V2 , OPEN_SEA_V1 or CRYPTO_PUNK data \u2014 information about order type, Fees, etc. maker \u2014 address of the order creator taker \u2014 address of the recipient of the order make \u2014 make the order side. What the creator has take \u2014 take the side of the order. What the creator wants to get in exchange for the make side fill \u2014 filling in data when matching fillvalue \u2014 data filling value start \u2014 the starting date of the order placement, from which the buyer can make a Bid end \u2014 the end date of the order placement before which the buyer can make a Bid makestock \u2014 how much is available for sale makestockvalue \u2014 the value of how much is available for sale cancelled \u2014 the order is canceled or not salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash signature \u2014 digital signature of the order creator createdAt \u2014 date of order creation lastupdateat \u2014 order update date pending \u2014 whether the order is incomplete. For example, it is in the status of CANCEL , ORDER_SIDE_MATCH or ON_CHAIN_ORDER hash \u2014 hash of the order makebalance \u2014 balance of the order creator makeprice \u2014 order price Takeprice \u2014 buyer's suggested price makepriceusd \u2014 order price in USD takepriceusd \u2014 price in USD suggested by the buyer pricehistory \u2014 history of price changes status \u2014 order status ACTIVE , FILLED , HISTORICAL , INACTIVE or CANCELLED","title":"upsertOrder"},{"location":"ethereum/api/ethereum-api-indexer/","text":"API and Indexer Overview \u00b6 The main functions of the API and indexer are: Follow the blockchain Handle read requests Process creation requests Architecture \u00b6 The Rarible Protocol Ethereum indexer consists of the following parts: NFT indexer \u2014 aggregates NFTs data ERC-20 indexer \u2014 aggregates data about ERC-20 tokens and balances Order indexer \u2014 aggregates Orders data from different platforms Each indexer listens to a specific part of the Ethereum blockchain. The indexers can be used to request data about the state of the blockchain. Indexers generate events when the state changes. They are developed with Spring Framework and use these external services: MongoDB \u2014 main data storage Apache Kafka \u2014 event handling Controllers \u00b6 To create or modify NFTs and search information about them: nft-transaction-controller nft-lazy-mint-controller nft-activity-controller nft-ownership-controller nft-item-controller nft-collection-controller To create or modify orders and search information about them: order-signature-controller order-encode-controller order-controller order-transaction-controller order-activity-controller order-aggregation-controller nft-order-ownership-controller nft-order-item-controller nft-order-activity-controller nft-order-collection-controller Additional controllers: gateway-controller erc20-balance-controller erc20-token-controller lock-controller API usage Examples \u00b6 Search Items Search Orders Create Lazy Minting Create Orders","title":"API and Indexer Overview"},{"location":"ethereum/api/ethereum-api-indexer/#api-and-indexer-overview","text":"The main functions of the API and indexer are: Follow the blockchain Handle read requests Process creation requests","title":"API and Indexer Overview"},{"location":"ethereum/api/ethereum-api-indexer/#architecture","text":"The Rarible Protocol Ethereum indexer consists of the following parts: NFT indexer \u2014 aggregates NFTs data ERC-20 indexer \u2014 aggregates data about ERC-20 tokens and balances Order indexer \u2014 aggregates Orders data from different platforms Each indexer listens to a specific part of the Ethereum blockchain. The indexers can be used to request data about the state of the blockchain. Indexers generate events when the state changes. They are developed with Spring Framework and use these external services: MongoDB \u2014 main data storage Apache Kafka \u2014 event handling","title":"Architecture"},{"location":"ethereum/api/ethereum-api-indexer/#controllers","text":"To create or modify NFTs and search information about them: nft-transaction-controller nft-lazy-mint-controller nft-activity-controller nft-ownership-controller nft-item-controller nft-collection-controller To create or modify orders and search information about them: order-signature-controller order-encode-controller order-controller order-transaction-controller order-activity-controller order-aggregation-controller nft-order-ownership-controller nft-order-item-controller nft-order-activity-controller nft-order-collection-controller Additional controllers: gateway-controller erc20-balance-controller erc20-token-controller lock-controller","title":"Controllers"},{"location":"ethereum/api/ethereum-api-indexer/#api-usage-examples","text":"Search Items Search Orders Create Lazy Minting Create Orders","title":"API usage Examples"},{"location":"ethereum/api/search-items/","text":"Search Items \u00b6 The main requests for working with Items relate to the nft-item-controller . Let's look at the example of getNftAllItems. getNftAllItems \u00b6 It will return all NFT items. Example request: curl --request GET 'https://ethereum-api.rarible.org/v0.1/nft/items/all?size=1' Request parameters: size \u2014 the number of items to be returned showDeleted \u2014 display deleted items or not lastUpdatedFrom \u2014 returns items that have been updated since that date (timestamp in ms) lastUpdatedTo \u2014 returns items that have been updated to this date (timestamp in ms) continuation \u2014 continuation token from the previous response Response example (status 200): { \"total\" : 1 , \"continuation\" : \"1637677864204_0xf6793da657495ffeff9ee6350824910abc21356c:0x8108800667cb3859020c77f7643cedb794b4455700000000000000000000000e\" , \"items\" : [ { \"id\" : \"0xf6793da657495ffeff9ee6350824910abc21356c:58363375839982426315252321964399886024230569048144758096248518895130164330510\" , \"contract\" : \"0xf6793da657495ffeff9ee6350824910abc21356c\" , \"tokenId\" : \"58363375839982426315252321964399886024230569048144758096248518895130164330510\" , \"creators\" : [ { \"account\" : \"0x8108800667cb3859020c77f7643cedb794b44557\" , \"value\" : 10000 } ], \"supply\" : \"1\" , \"lazySupply\" : \"1\" , \"owners\" : [ \"0x8108800667cb3859020c77f7643cedb794b44557\" ], \"royalties\" : [ { \"account\" : \"0x8108800667cb3859020c77f7643cedb794b44557\" , \"value\" : 1000 } ], \"date\" : \"2021-11-23T14:31:04.204Z\" , \"pending\" : [], \"deleted\" : false , \"meta\" : { \"name\" : \"Rampows the Daltons\" , \"description\" : \"\" , \"attributes\" : [], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmWXtdxkrR33rNxoNAbUDELsv2YBjajE4nhHGrgwT7UBHQ/image.jpeg\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/jpeg\" , \"width\" : 1792 , \"height\" : 1401 } } } } } ] } Response parameters: total \u2014 the number of items returned on request continuation \u2014 continuation token from the previous response items \u2014 list of found items & basic information about them","title":"Search Items"},{"location":"ethereum/api/search-items/#search-items","text":"The main requests for working with Items relate to the nft-item-controller . Let's look at the example of getNftAllItems.","title":"Search Items"},{"location":"ethereum/api/search-items/#getnftallitems","text":"It will return all NFT items. Example request: curl --request GET 'https://ethereum-api.rarible.org/v0.1/nft/items/all?size=1' Request parameters: size \u2014 the number of items to be returned showDeleted \u2014 display deleted items or not lastUpdatedFrom \u2014 returns items that have been updated since that date (timestamp in ms) lastUpdatedTo \u2014 returns items that have been updated to this date (timestamp in ms) continuation \u2014 continuation token from the previous response Response example (status 200): { \"total\" : 1 , \"continuation\" : \"1637677864204_0xf6793da657495ffeff9ee6350824910abc21356c:0x8108800667cb3859020c77f7643cedb794b4455700000000000000000000000e\" , \"items\" : [ { \"id\" : \"0xf6793da657495ffeff9ee6350824910abc21356c:58363375839982426315252321964399886024230569048144758096248518895130164330510\" , \"contract\" : \"0xf6793da657495ffeff9ee6350824910abc21356c\" , \"tokenId\" : \"58363375839982426315252321964399886024230569048144758096248518895130164330510\" , \"creators\" : [ { \"account\" : \"0x8108800667cb3859020c77f7643cedb794b44557\" , \"value\" : 10000 } ], \"supply\" : \"1\" , \"lazySupply\" : \"1\" , \"owners\" : [ \"0x8108800667cb3859020c77f7643cedb794b44557\" ], \"royalties\" : [ { \"account\" : \"0x8108800667cb3859020c77f7643cedb794b44557\" , \"value\" : 1000 } ], \"date\" : \"2021-11-23T14:31:04.204Z\" , \"pending\" : [], \"deleted\" : false , \"meta\" : { \"name\" : \"Rampows the Daltons\" , \"description\" : \"\" , \"attributes\" : [], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmWXtdxkrR33rNxoNAbUDELsv2YBjajE4nhHGrgwT7UBHQ/image.jpeg\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/jpeg\" , \"width\" : 1792 , \"height\" : 1401 } } } } } ] } Response parameters: total \u2014 the number of items returned on request continuation \u2014 continuation token from the previous response items \u2014 list of found items & basic information about them","title":"getNftAllItems"},{"location":"ethereum/api/search-orders/","text":"Search Orders \u00b6 The main requests for working with Orders refer to order-controller . Let's look at the example of getOrdersAllByStatus. getOrdersAllByStatus \u00b6 Returns all orders sorted by status. Example request: curl --request GET 'https://ethereum-api.rarible.org/v0.1/order/orders/all/byStatus?sort=LAST_UPDATE_DESC&size=1&status=ACTIVE' Request parameters: sort \u2014 sort by last updated orders LAST_UPDATE_ASC , LAST_UPDATE_DESC size \u2014 number of orders to be returned continuation \u2014 continuation token from the previous response status \u2014 order status ACTIVE , FILLED , HISTORICAL , INACTIVE , CANCELLED Response example (status 200): { \"orders\" : [ { \"type\" : \"RARIBLE_V2\" , \"maker\" : \"0x1a68bab3ebe18ffe95508b2d4e1362addc2cbdd6\" , \"make\" : { \"assetType\" : { \"assetClass\" : \"ERC20\" , \"contract\" : \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\" }, \"value\" : \"260000000000000000\" , \"valueDecimal\" : 0.260000000000000000 }, \"take\" : { \"assetType\" : { \"assetClass\" : \"ERC721\" , \"contract\" : \"0x918f677b3ab4b9290ca96a95430fd228b2d84817\" , \"tokenId\" : \"260\" }, \"value\" : \"1\" , \"valueDecimal\" : 1 }, \"fill\" : \"0\" , \"fillValue\" : 0 , \"makeStock\" : \"260000000000000000\" , \"makeStockValue\" : 0.260000000000000000 , \"cancelled\" : false , \"salt\" : \"0xf7f9ca62eceb7ee9021a89ac2a77976287721cc56a28f9d8d12c1332898e12e4\" , \"signature\" : \"0x382bd104f4497119c75b36e5f0954a03692ab1c3b995266b20623bc718a58f423ff68e2caacb93668811e52b6a099260b3147ded35dc3ad5d65970efde9587761c\" , \"createdAt\" : \"2021-11-23T15:08:20.925Z\" , \"lastUpdateAt\" : \"2021-11-23T15:08:20.925Z\" , \"pending\" : [], \"hash\" : \"0x3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\" , \"makeBalance\" : \"0\" , \"takePrice\" : 0.260000000000000000 , \"takePriceUsd\" : 1089.887807206807960000000000000000 , \"priceHistory\" : [ { \"date\" : \"2021-11-23T15:08:20.925Z\" , \"makeValue\" : 0.260000000000000000 , \"takeValue\" : 1 } ], \"status\" : \"ACTIVE\" , \"data\" : { \"dataType\" : \"RARIBLE_V2_DATA_V1\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\" , \"value\" : 250 } ] } } ], \"continuation\" : \"1637680100925_3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\" } Response parameters: orders \u2014 list of found orders with basic information on them continuation \u2014 continuation token from the previous response","title":"Search Orders"},{"location":"ethereum/api/search-orders/#search-orders","text":"The main requests for working with Orders refer to order-controller . Let's look at the example of getOrdersAllByStatus.","title":"Search Orders"},{"location":"ethereum/api/search-orders/#getordersallbystatus","text":"Returns all orders sorted by status. Example request: curl --request GET 'https://ethereum-api.rarible.org/v0.1/order/orders/all/byStatus?sort=LAST_UPDATE_DESC&size=1&status=ACTIVE' Request parameters: sort \u2014 sort by last updated orders LAST_UPDATE_ASC , LAST_UPDATE_DESC size \u2014 number of orders to be returned continuation \u2014 continuation token from the previous response status \u2014 order status ACTIVE , FILLED , HISTORICAL , INACTIVE , CANCELLED Response example (status 200): { \"orders\" : [ { \"type\" : \"RARIBLE_V2\" , \"maker\" : \"0x1a68bab3ebe18ffe95508b2d4e1362addc2cbdd6\" , \"make\" : { \"assetType\" : { \"assetClass\" : \"ERC20\" , \"contract\" : \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\" }, \"value\" : \"260000000000000000\" , \"valueDecimal\" : 0.260000000000000000 }, \"take\" : { \"assetType\" : { \"assetClass\" : \"ERC721\" , \"contract\" : \"0x918f677b3ab4b9290ca96a95430fd228b2d84817\" , \"tokenId\" : \"260\" }, \"value\" : \"1\" , \"valueDecimal\" : 1 }, \"fill\" : \"0\" , \"fillValue\" : 0 , \"makeStock\" : \"260000000000000000\" , \"makeStockValue\" : 0.260000000000000000 , \"cancelled\" : false , \"salt\" : \"0xf7f9ca62eceb7ee9021a89ac2a77976287721cc56a28f9d8d12c1332898e12e4\" , \"signature\" : \"0x382bd104f4497119c75b36e5f0954a03692ab1c3b995266b20623bc718a58f423ff68e2caacb93668811e52b6a099260b3147ded35dc3ad5d65970efde9587761c\" , \"createdAt\" : \"2021-11-23T15:08:20.925Z\" , \"lastUpdateAt\" : \"2021-11-23T15:08:20.925Z\" , \"pending\" : [], \"hash\" : \"0x3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\" , \"makeBalance\" : \"0\" , \"takePrice\" : 0.260000000000000000 , \"takePriceUsd\" : 1089.887807206807960000000000000000 , \"priceHistory\" : [ { \"date\" : \"2021-11-23T15:08:20.925Z\" , \"makeValue\" : 0.260000000000000000 , \"takeValue\" : 1 } ], \"status\" : \"ACTIVE\" , \"data\" : { \"dataType\" : \"RARIBLE_V2_DATA_V1\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\" , \"value\" : 250 } ] } } ], \"continuation\" : \"1637680100925_3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\" } Response parameters: orders \u2014 list of found orders with basic information on them continuation \u2014 continuation token from the previous response","title":"getOrdersAllByStatus"},{"location":"ethereum/assets/asset-discovery/","text":"Asset Discovery \u00b6 Search Items \u00b6 {% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for item-controller part There are some controllers to query items: get all items get items by owner get items by collection other controllers in item-controller section of the api-reference These controllers have common parameters: size - how many items you want to get continuation - send this parameter to fetch next portion of data (you can find continuation value in the server response) also they have different query parameters for each. Please, see api-reference {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId/meta\" method=\"get\" summary=\"Item Metadata\" %} {% swagger-description %} Displays all item Metadata (Stored on IPFS) {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% swagger-response status=\"200\" description=\"\" %} { \"name\": \"string\", \"description\": \"string\", \"image\": \"string\", \"external_url\": \"string\", \"animation_url\": \"string\", \"attributes\": {} } {% endswagger-response %} {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId\" method=\"get\" summary=\"Item Data\" %} {% swagger-description %} Displays Item data such as Royalties, Unlockable content, etc. {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% swagger-response status=\"200\" description=\"\" %} { \"id\": \"string\", \"token\": \"string\", \"tokenId\": 0, \"unlockable\": true, \"creator\": \"string\", \"supply\": 0, \"owners\": [ \"string\" ], \"royalties\": [ { \"recipient\": \"string\", \"value\": 0 } ] } {% endswagger-response %} {% hint style=\"danger\" %} If you wish to build an order for an ERC1155, it is important you also record the amount returned by the query. Visit the next section on how to create a sell order !","title":"Asset Discovery"},{"location":"ethereum/assets/asset-discovery/#asset-discovery","text":"","title":"Asset Discovery"},{"location":"ethereum/assets/asset-discovery/#search-items","text":"{% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for item-controller part There are some controllers to query items: get all items get items by owner get items by collection other controllers in item-controller section of the api-reference These controllers have common parameters: size - how many items you want to get continuation - send this parameter to fetch next portion of data (you can find continuation value in the server response) also they have different query parameters for each. Please, see api-reference {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId/meta\" method=\"get\" summary=\"Item Metadata\" %} {% swagger-description %} Displays all item Metadata (Stored on IPFS) {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% swagger-response status=\"200\" description=\"\" %} { \"name\": \"string\", \"description\": \"string\", \"image\": \"string\", \"external_url\": \"string\", \"animation_url\": \"string\", \"attributes\": {} } {% endswagger-response %} {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId\" method=\"get\" summary=\"Item Data\" %} {% swagger-description %} Displays Item data such as Royalties, Unlockable content, etc. {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% swagger-response status=\"200\" description=\"\" %} { \"id\": \"string\", \"token\": \"string\", \"tokenId\": 0, \"unlockable\": true, \"creator\": \"string\", \"supply\": 0, \"owners\": [ \"string\" ], \"royalties\": [ { \"recipient\": \"string\", \"value\": 0 } ] } {% endswagger-response %} {% hint style=\"danger\" %} If you wish to build an order for an ERC1155, it is important you also record the amount returned by the query. Visit the next section on how to create a sell order !","title":"Search Items"},{"location":"ethereum/assets/creating-an-asset/","text":"Asset Creation \u00b6 Asset Introduction \u00b6 Rarible protocol has two asset types, ERC721, and ERC1155, the main difference between them is that ERC721 creates unique 1 of 1 item, whereas ERC1155, allows the user to create an item with multiple editions (The maximum amount of editions is 2**256 - 1). You can find the protocol smart contracts here. Ropsten \u00b6 Asset Contract ERC721 Etherscan link \u2197 \u00b6 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Asset Contract ERC1155 Etherscan link \u2197 \u00b6 0x6a94aC200342AC823F909F142a65232E2f052183 Rinkeby \u00b6 Asset Contract ERC721 Etherscan link \u2197 \u00b6 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 Asset Contract ERC1155 Etherscan link \u2197 \u00b6 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 Asset Types Explained \u00b6 ERC721 & ERC1155 \u00b6 With the new ERC721 & ERC1155 Asset contracts we no longer call the mint function directly, instead, we implement lazy minting via the mintAndTransfer function. Lazy minting allows the item to be created and store off-chain until someone purchases/transfers this item, only at this point does the item get created on-chain. Direct calls to mint() should be avoided and replaced with mintAndTransfer() . However, standard minting is still possible with this function. See ERC721 Standard Minting or ERC1155 Standard Minting for details. Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC721 Standard Minting . ERC721 mintAndTransfer ABI // ABI for ERC-721 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC721LazyMint.Mint721Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ERC721 Lazy Minting \u00b6 If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here . For 721 (Ropsten) \u00b6 Step 1 : Generate a token ID. GET from https://ethereum-api-dev.rarible.com/protocol/v0.1/ethereum/nft/collections/{ContractAddress}/generate_token_id?minter=${account} Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See EIP1271 for information on how smart contracts can interact with this order book. First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint721\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint721\", version: \"1\", chainId: 3, verifyingContract: \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\" }, \"primaryType\": \"Mint721\", \"message\": { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\ ERC721 Standard Minting \u00b6 You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) struct Mint721Data { uint tokenId; string uri; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info Example \u00b6 async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); } ERC1155 Overview \u00b6 mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) Mint1155Data Parameter Structure struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. supply supply should be a uint256, this is the number of copies (or Editions) of this token that will ever exist. (Maximum value is 2**256 - 1). creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC1155 Standard Minting . ERC1155 mintAndTransfer ABI // ABI for ERC-1155 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"internalType\": \"uint256\", \"name\": \"supply\", \"type\": \"uint256\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC1155LazyMint.Mint1155Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"_amount\", \"type\": \"uint256\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ERC1155 Lazy Minting \u00b6 If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here . For 1155 (Ropsten) \u00b6 Step 1 : Generate a token ID. Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} // Sample Call const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator . { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See Signatures for more details on typed data and EIP-712 and EIP-1271. First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint1155\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, { name: 'supply', type: 'uint256' }, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint1155\", version: \"1\", chainId: 3, verifyingContract: \"0x6a94aC200342AC823F909F142a65232E2f052183 \" }, \"primaryType\": \"Mint1155\", \"message\": { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10 \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\ ERC1155 Standard Minting \u00b6 You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info Example \u00b6 async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , totalSupply , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , amount ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); } Uploading the image to IPFS \u00b6 The image needs to be hosted on IPFS, at Rarible we use pinata, below is a NodeJS example of uploading an image using their API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; This will return our IPFS CID, the full response looks like this: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) } Creating our NFT's Metadata \u00b6 Now that we have our IPFS CID (Called hash here on out), we can begin constructing our NFT's Metadata file that will be linked to the NFT on-chain. Below is a Metadata file with an explanation of the key and its value. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] } Adding Generated Metadata to IPFS \u00b6 First, we need to make sure our external_url is a Rarible link. We can calculate this link based on the tokenId we create (The tokenId typically is made up of two sections, the first 20 bytes in the users' address and the next 12 bytes can be any random number. We will provide an API to allow you to get the next free available ID.), for this example, our external_url must be the collection address + tokenId and it will look like this \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Notice we use the collection address and value address from our previous call to the tokens endpoint. Now we need to post our NFT's Metadata to IPFS below is an example of how to do this: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Our Result will look something similar to this: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Make a note of your new IpfsHash since this is now the hash we need to attach to our NFT. Custom Contracts \u00b6 If you are not storing your metadata on IPFS, you will need to use your own contracts that have a baseURI better suited for where the metadata is stored. As a starting point, so long as your contract follows the ERC-721 or ERC-1155 standard it's NFTs can be bought and sold on Rarible and most other NFT marketplaces. Helpful guides on these standards can be found at OpenZeppelin . However, you'll need to add more to support royalties and lazy minting as these are not built into the current standards. To support royalties, your contract will need to inherit from the appropriate interfaces, which you can find here or here for an upgradeable version. Similarly for lazy minting support, you will need to add a mintAndTransfer function in your contract for the protocol to call that inherits the expected behavior. You can add this yourself or use this interface . In many cases, it may be easier and faster to just fork the protocol contracts you wanted to use and change the baseURI and any other data upon deployment. {% hint style=\"info\" %} You can supply your own tokenId instead of getting one from the API call used for Lazy Minting when rolling your own contracts, however, the token id needs to have the minter's address followed by 96 bits, which can include any number you want, in order to pass the require checks in the default mintAndTransfer function. Alternatively, you can still use the generate token id API used above to supply a tokenId for them. YAY! Your NFT is now minted! Visit the next section on how to create a sell order or to check if your Asset is indexed you can view this page .","title":"Asset Creation"},{"location":"ethereum/assets/creating-an-asset/#asset-creation","text":"","title":"Asset Creation"},{"location":"ethereum/assets/creating-an-asset/#asset-introduction","text":"Rarible protocol has two asset types, ERC721, and ERC1155, the main difference between them is that ERC721 creates unique 1 of 1 item, whereas ERC1155, allows the user to create an item with multiple editions (The maximum amount of editions is 2**256 - 1). You can find the protocol smart contracts here.","title":"Asset Introduction"},{"location":"ethereum/assets/creating-an-asset/#ropsten","text":"","title":"Ropsten"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc721-etherscan-link","text":"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05","title":"Asset Contract ERC721 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc1155-etherscan-link","text":"0x6a94aC200342AC823F909F142a65232E2f052183","title":"Asset Contract ERC1155 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#rinkeby","text":"","title":"Rinkeby"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc721-etherscan-link_1","text":"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82","title":"Asset Contract ERC721 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc1155-etherscan-link_1","text":"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7","title":"Asset Contract ERC1155 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-types-explained","text":"","title":"Asset Types Explained"},{"location":"ethereum/assets/creating-an-asset/#erc721-erc1155","text":"With the new ERC721 & ERC1155 Asset contracts we no longer call the mint function directly, instead, we implement lazy minting via the mintAndTransfer function. Lazy minting allows the item to be created and store off-chain until someone purchases/transfers this item, only at this point does the item get created on-chain. Direct calls to mint() should be avoided and replaced with mintAndTransfer() . However, standard minting is still possible with this function. See ERC721 Standard Minting or ERC1155 Standard Minting for details. Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC721 Standard Minting . ERC721 mintAndTransfer ABI // ABI for ERC-721 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC721LazyMint.Mint721Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }","title":"ERC721 &amp; ERC1155"},{"location":"ethereum/assets/creating-an-asset/#erc721-lazy-minting","text":"If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here .","title":"ERC721 Lazy Minting"},{"location":"ethereum/assets/creating-an-asset/#for-721-ropsten","text":"Step 1 : Generate a token ID. GET from https://ethereum-api-dev.rarible.com/protocol/v0.1/ethereum/nft/collections/{ContractAddress}/generate_token_id?minter=${account} Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See EIP1271 for information on how smart contracts can interact with this order book. First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint721\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint721\", version: \"1\", chainId: 3, verifyingContract: \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\" }, \"primaryType\": \"Mint721\", \"message\": { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\","title":"For 721 (Ropsten)"},{"location":"ethereum/assets/creating-an-asset/#erc721-standard-minting","text":"You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) struct Mint721Data { uint tokenId; string uri; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info","title":"ERC721 Standard Minting"},{"location":"ethereum/assets/creating-an-asset/#example","text":"async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); }","title":"Example"},{"location":"ethereum/assets/creating-an-asset/#erc1155-overview","text":"mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) Mint1155Data Parameter Structure struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. supply supply should be a uint256, this is the number of copies (or Editions) of this token that will ever exist. (Maximum value is 2**256 - 1). creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC1155 Standard Minting . ERC1155 mintAndTransfer ABI // ABI for ERC-1155 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"internalType\": \"uint256\", \"name\": \"supply\", \"type\": \"uint256\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC1155LazyMint.Mint1155Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"_amount\", \"type\": \"uint256\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }","title":"ERC1155 Overview"},{"location":"ethereum/assets/creating-an-asset/#erc1155-lazy-minting","text":"If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here .","title":"ERC1155 Lazy Minting"},{"location":"ethereum/assets/creating-an-asset/#for-1155-ropsten","text":"Step 1 : Generate a token ID. Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} // Sample Call const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator . { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See Signatures for more details on typed data and EIP-712 and EIP-1271. First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint1155\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, { name: 'supply', type: 'uint256' }, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint1155\", version: \"1\", chainId: 3, verifyingContract: \"0x6a94aC200342AC823F909F142a65232E2f052183 \" }, \"primaryType\": \"Mint1155\", \"message\": { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10 \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\","title":"For 1155 (Ropsten)"},{"location":"ethereum/assets/creating-an-asset/#erc1155-standard-minting","text":"You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info","title":"ERC1155 Standard Minting"},{"location":"ethereum/assets/creating-an-asset/#example_1","text":"async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , totalSupply , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , amount ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); }","title":"Example"},{"location":"ethereum/assets/creating-an-asset/#uploading-the-image-to-ipfs","text":"The image needs to be hosted on IPFS, at Rarible we use pinata, below is a NodeJS example of uploading an image using their API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; This will return our IPFS CID, the full response looks like this: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) }","title":"Uploading the image to IPFS"},{"location":"ethereum/assets/creating-an-asset/#creating-our-nfts-metadata","text":"Now that we have our IPFS CID (Called hash here on out), we can begin constructing our NFT's Metadata file that will be linked to the NFT on-chain. Below is a Metadata file with an explanation of the key and its value. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] }","title":"Creating our NFT's Metadata"},{"location":"ethereum/assets/creating-an-asset/#adding-generated-metadata-to-ipfs","text":"First, we need to make sure our external_url is a Rarible link. We can calculate this link based on the tokenId we create (The tokenId typically is made up of two sections, the first 20 bytes in the users' address and the next 12 bytes can be any random number. We will provide an API to allow you to get the next free available ID.), for this example, our external_url must be the collection address + tokenId and it will look like this \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Notice we use the collection address and value address from our previous call to the tokens endpoint. Now we need to post our NFT's Metadata to IPFS below is an example of how to do this: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Our Result will look something similar to this: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Make a note of your new IpfsHash since this is now the hash we need to attach to our NFT.","title":"Adding Generated Metadata to IPFS"},{"location":"ethereum/assets/creating-an-asset/#custom-contracts","text":"If you are not storing your metadata on IPFS, you will need to use your own contracts that have a baseURI better suited for where the metadata is stored. As a starting point, so long as your contract follows the ERC-721 or ERC-1155 standard it's NFTs can be bought and sold on Rarible and most other NFT marketplaces. Helpful guides on these standards can be found at OpenZeppelin . However, you'll need to add more to support royalties and lazy minting as these are not built into the current standards. To support royalties, your contract will need to inherit from the appropriate interfaces, which you can find here or here for an upgradeable version. Similarly for lazy minting support, you will need to add a mintAndTransfer function in your contract for the protocol to call that inherits the expected behavior. You can add this yourself or use this interface . In many cases, it may be easier and faster to just fork the protocol contracts you wanted to use and change the baseURI and any other data upon deployment. {% hint style=\"info\" %} You can supply your own tokenId instead of getting one from the API call used for Lazy Minting when rolling your own contracts, however, the token id needs to have the minter's address followed by 96 bits, which can include any number you want, in order to pass the require checks in the default mintAndTransfer function. Alternatively, you can still use the generate token id API used above to supply a tokenId for them. YAY! Your NFT is now minted! Visit the next section on how to create a sell order or to check if your Asset is indexed you can view this page .","title":"Custom Contracts"},{"location":"ethereum/assets/token-factories/","text":"Token Factories \u00b6 You can easily create ERC721 and ERC1155 smart contracts using our Token Factories. Find addresses for token factories on Addresses page. Token Factories create Beacon proxies : this means Rarible Protocol can upgrade these contracts automatically (when all token contracts are upgraded). Currently, two token factories are available: ERC-721 and ERC-1155. These both contracts are public in terms of minting: anyone can mint tokens there. Invoke function createToken to create tokens with custom name, symbol. Set base uri to \"ipfs:/\" if you want to use ipfs for metadata storage. There are the parameters supported: name - name of the smart contract symbol - symbol of the smart contract base URI - prefix for the URI for created tokens (will be prepended to URI for every token minted). By default, use \"ipfs:/\" contractURI - URI holding metadata for the contract. Set https://api-mainnet.rarible.com/contractMetadata/{address} if you want to control metadata using Rarible UI","title":"Token Factories"},{"location":"ethereum/assets/token-factories/#token-factories","text":"You can easily create ERC721 and ERC1155 smart contracts using our Token Factories. Find addresses for token factories on Addresses page. Token Factories create Beacon proxies : this means Rarible Protocol can upgrade these contracts automatically (when all token contracts are upgraded). Currently, two token factories are available: ERC-721 and ERC-1155. These both contracts are public in terms of minting: anyone can mint tokens there. Invoke function createToken to create tokens with custom name, symbol. Set base uri to \"ipfs:/\" if you want to use ipfs for metadata storage. There are the parameters supported: name - name of the smart contract symbol - symbol of the smart contract base URI - prefix for the URI for created tokens (will be prepended to URI for every token minted). By default, use \"ipfs:/\" contractURI - URI holding metadata for the contract. Set https://api-mainnet.rarible.com/contractMetadata/{address} if you want to control metadata using Rarible UI","title":"Token Factories"},{"location":"ethereum/exchange/accepting-a-buy-order/","text":"Accepting a Buy Order \u00b6 To buy an item or accept a bid user should send transaction to Exchange contract's matchOrders function. Example for sending matchOrders is here . matchOrders function defined in ExchangeV2Core has 4 parameters: left order. left order signature right order right order signature More about order structure can be found here - Order Structure Pay ETH for ERC721 \u00b6 You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. Encoded order { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"100000000000000000\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000005\" }, \"value\": \"1\" }, \"salt\": \"0\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Example transaction that has both a signed sell order and an unsigned buy order, submitted by the buyer. Bid Orders \u00b6 A bid is just an unmatched buy order. The bidder submits the order to the indexer, like shown in Creating a sell order . The seller accepts it by creating a matched order.","title":"Accepting a Buy Order"},{"location":"ethereum/exchange/accepting-a-buy-order/#accepting-a-buy-order","text":"To buy an item or accept a bid user should send transaction to Exchange contract's matchOrders function. Example for sending matchOrders is here . matchOrders function defined in ExchangeV2Core has 4 parameters: left order. left order signature right order right order signature More about order structure can be found here - Order Structure","title":"Accepting a Buy Order"},{"location":"ethereum/exchange/accepting-a-buy-order/#pay-eth-for-erc721","text":"You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. Encoded order { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"100000000000000000\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000005\" }, \"value\": \"1\" }, \"salt\": \"0\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Example transaction that has both a signed sell order and an unsigned buy order, submitted by the buyer.","title":"Pay ETH for ERC721"},{"location":"ethereum/exchange/accepting-a-buy-order/#bid-orders","text":"A bid is just an unmatched buy order. The bidder submits the order to the indexer, like shown in Creating a sell order . The seller accepts it by creating a matched order.","title":"Bid Orders"},{"location":"ethereum/exchange/contract-wallets/","text":"Contract Wallets \u00b6 Example implementation: https://rinkeby.etherscan.io/address/0x998Cf6fDd7FF1EB258c288762284142D28D0ee39#code EIP1271 allows a contract to delegate authorized signers. Usually EIP1271 expects an authorized delegate to submit a signature via the contract, and uses typical ECrecover to see if the signature is valid. EIP1271 returns valid signature: true** if the signature is valid & the signer is authorized by the contract ** not actually true , but instead a magic value to guard against mistaken 'true' bit The Rarible contract checks if the signature is valid with the following code require( ERC1271(order.maker).isValidSignature(_hashTypedDataV4(hash), signature) == MAGICVALUE, \"contract order signature verification error\" );","title":"Contract Wallets"},{"location":"ethereum/exchange/contract-wallets/#contract-wallets","text":"Example implementation: https://rinkeby.etherscan.io/address/0x998Cf6fDd7FF1EB258c288762284142D28D0ee39#code EIP1271 allows a contract to delegate authorized signers. Usually EIP1271 expects an authorized delegate to submit a signature via the contract, and uses typical ECrecover to see if the signature is valid. EIP1271 returns valid signature: true** if the signature is valid & the signer is authorized by the contract ** not actually true , but instead a magic value to guard against mistaken 'true' bit The Rarible contract checks if the signature is valid with the following code require( ERC1271(order.maker).isValidSignature(_hashTypedDataV4(hash), signature) == MAGICVALUE, \"contract order signature verification error\" );","title":"Contract Wallets"},{"location":"ethereum/exchange/creating-a-sell-order/","text":"Creating A Sell Order \u00b6 Creating an order \u00b6 Step 1. Approval We need to call approval on the transfer proxy contract. {% hint style=\"danger\" %} The approval on the transfer proxy only needs to be called if a previous approval does not exist. Step 2. Creating signature Sell ERC721 for ETH \u00b6 You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. First Encode the order for signing POST to https://ethereum-api-staging.rarible.org/v0.1/order/encoder/order { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"3621\" } Response: { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000001\" }, \"value\": \"1\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"1000000000000000000\" }, \"salt\": \"3621\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Then Sign the order async function sign(provider, order, account, verifyingContract) { const chainId = Number(provider._network.chainId); const data = EIP712.createTypeData({ name: \"Exchange\", version: \"2\", chainId, verifyingContract }, 'Order', order, Types); console.log({data}) return (await EIP712.signTypedData(provider, account, data)).sig; } Step 3. Send order with signature to our API POST to https://ethereum-api-staging.rarible.org/v0.1/order/orders Payload { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"5422\", \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\" } Response { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x000000000000000000000000000000000000000000000000000000000000152e\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\", \"createdAt\": \"2021-05-25T02:04:28.836+00:00\", \"lastUpdateAt\": \"2021-05-25T02:04:28.983+00:00\", \"pending\": [], \"hash\": \"0xc9cb92588fc1434a417f4cacb9e1267750e6f1cbe650988a6fdc1d0be8a310a9\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.1365826056253000000000000000000 } {% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for createOrUpdateOrder","title":"Creating A Sell Order"},{"location":"ethereum/exchange/creating-a-sell-order/#creating-a-sell-order","text":"","title":"Creating A Sell Order"},{"location":"ethereum/exchange/creating-a-sell-order/#creating-an-order","text":"Step 1. Approval We need to call approval on the transfer proxy contract. {% hint style=\"danger\" %} The approval on the transfer proxy only needs to be called if a previous approval does not exist. Step 2. Creating signature","title":"Creating an order"},{"location":"ethereum/exchange/creating-a-sell-order/#sell-erc721-for-eth","text":"You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. First Encode the order for signing POST to https://ethereum-api-staging.rarible.org/v0.1/order/encoder/order { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"3621\" } Response: { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000001\" }, \"value\": \"1\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"1000000000000000000\" }, \"salt\": \"3621\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Then Sign the order async function sign(provider, order, account, verifyingContract) { const chainId = Number(provider._network.chainId); const data = EIP712.createTypeData({ name: \"Exchange\", version: \"2\", chainId, verifyingContract }, 'Order', order, Types); console.log({data}) return (await EIP712.signTypedData(provider, account, data)).sig; } Step 3. Send order with signature to our API POST to https://ethereum-api-staging.rarible.org/v0.1/order/orders Payload { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"5422\", \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\" } Response { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x000000000000000000000000000000000000000000000000000000000000152e\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\", \"createdAt\": \"2021-05-25T02:04:28.836+00:00\", \"lastUpdateAt\": \"2021-05-25T02:04:28.983+00:00\", \"pending\": [], \"hash\": \"0xc9cb92588fc1434a417f4cacb9e1267750e6f1cbe650988a6fdc1d0be8a310a9\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.1365826056253000000000000000000 } {% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for createOrUpdateOrder","title":"Sell ERC721 for ETH"},{"location":"ethereum/exchange/exchange-overview/","text":"Exchange Overview \u00b6 Asset matching \u00b6 The purpose of this is to validate that makeAsset of the left order matches takeAsset from the right order and vice versa. New types of assets can be added without a smart contract upgrade. This is done using a custom IAssetMatcher. There are possible improvements to the protocol using these custom matcher contracts such as: Support for parametric assets. For example, the user can put an order to exchange 10ETH for any NFT from a popular collection. Support for NFT bundles. The general process for completing an order with the Rarible Exchange is as follows: Seller approves the Rarible exchange contract to transfer NFT on their behalf Seller creates and signs an order. They specify the types and amounts of assets they would like in return. Seller submits the order to the indexer Potential buyers query the indexer to get sell orders for a specific item or collection Buyers can create a matching buy order for a sell order from the indexer. The buyer can then submit a matching buy order to the smart contract and execute the transfer (no sig required). Or the buyer can create a new bid and submit it to the indexer (requires signature) If the buyer submits a bid, the seller can choose to accept it by creating the matching sell order and submitting it to the contract, or they can send a signed order back to the buyer which the buyer would submit to the contract. Order Structure \u00b6 Each order (both buy & sell) consist of a makeAsset and a takeAsset Make Asset is what you are sending. In a buy order this is what you are paying for the seller's NFT. This can be ETH, ERC20, ERC721, ERC1155, or any custom asset using their Asset Matcher interface In a sell order this is the NFT you are selling Take Asset is what you are accepting in return In a buy order this is the NFT you are buying In a sell order this is what you are willing to accept. Order \u00b6 Field Description Required Maker Address of entity giving up makeAsset Yes makeAsset Asset the entity is giving up Yes taker Address of counterparty no, if 0 then anyone can fill the order takeAsset Asset the entity is receving Yes salt nonce for signatures submitted with the order Generally signatures are only needed if msg.sender != maker start uint - order can't be filled before this time no end uint - order can't be filled after this time no dataType bytes4, usually hash of a string like v1 or v2 Yes data generic bytes . Can be used for protocol extensions no Asset \u00b6 Field Description Required assetType Specifies ETH, specific ERC20, ERC721, ERC1155 Yes value uint Yes AssetType \u00b6 Field Description Required assetClass bytes4 specifies ETH, ERC20, ERC721 Yes data bytes - generic data depending on tp. Ex. address for ERC20, token + tokenID for ERC721 yes Asset Types \u00b6 Asset Class data field is calculated as follows bytes4 constant public ETH_ASSET_CLASS = bytes4(keccak256(\"ETH\")); bytes4 constant public ERC20_ASSET_CLASS = bytes4(keccak256(\"ERC20\")); bytes4 constant public ERC721_ASSET_CLASS = bytes4(keccak256(\"ERC721\")); bytes4 constant public ERC1155_ASSET_CLASS = bytes4(keccak256(\"ERC1155\")); All asset types get encoded using these helper functions https://github.com/rariblecom/protocol-contracts/blob/master/exchange-v2/test/assets.js ERC721 \u00b6 assetClass : Truncated hash of string \"ERC721\" data : ABI encoded parameters of address and tokenId value : 1 ERC721 Input (Pre encoding) { assetType: { assetClass: \"ERC721\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"1\", } ERC1155 \u00b6 assetClass : Truncated hash of string \"ERC1155\" data : ABI encoded parameters of address and tokenId value : 1->totalSupply ERC1155 Input (Pre encoding) { assetType: { assetClass: \"ERC1155\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"100\", } ERC20 \u00b6 assetClass : Truncated hash of string \"ERC20\" data : ABI encoded parameters of address value : 1->totalSupply ERC20 Input (Pre encoding) { assetType: { assetClass: \"ERC20\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", }, value: \"10000000000000000\", } ETH \u00b6 assetClass : Truncated hash of string \"ETH\" data : 0x value : 1->1e18 Input (pre encoding) { assetType: { assetClass: \"ETH\" }, value: \"10000000000000000\", }, Custom Asset Matcher \u00b6 Any asset can be added assetClass : Truncated hash of any string data : Whatever is relevant value : some uint Order validation \u00b6 Check the start/end date of the orders. Check if the taker of the order is blank or taker = order.taker Check if the order is signed by its maker or maker of the order is executing the transaction. If the maker of the order is a contract, then an ERC-1271 check is performed. {% hint style=\"info\" %} Currently, only off-chain orders are supported, this part of the smart contract can be easily updated to support on-chain order books. Order execution \u00b6 Order execution is done by TransferManager. There are 2 variants: SimpleTransferManager (it simply transfers assets from maker to taker and vice versa). RaribleTransferManager (sophisticated version, it takes into account protocol commissions, royalties, etc). {% hint style=\"success\" %} There are plans to extend RaribleTransferManager to support more royalty schemes and add new features like custom fees, multiple order beneficiaries. This part of the algorithm can be extended with a custom ITransferExecutor. In the future, new executors will be added to support new asset types, for example, executor for handling bundles can be added. {% hint style=\"info\" %} Possible improvements: Support bundles. Support random boxes. Fees \u00b6 RaribleTransferManager supports these types of fees: Protocol fees (These fees are taken from both sides of the deal). Origin fees (Origin and origin fee is set for every order. it can be different for two orders involved). Royalties (Authors of the work will receive part of each sale). Fees calculation, fee side To take a fee we need to calculate, what side of the deal can be used as money. There is a simple algorithm to do it: If ETH is from any side of the deal, it's used. If not, then if ERC-20 is in the deal, it's used. If not, then if ERC-1155 is in the deal, it's used. Otherwise, the fee is not taken (for example, two ERC-721 are involved in the deal). When we established, what part of the deal can be treated as money, then we can establish, that The Buyer is the side of the deal who owns the money. The Seller is the other side of the deal. Then the total amount of the asset (money side) should be calculated Protocol fee is added on top of the filled amount. The origin fee of the buyer's order is added on top too. If the buyer is using an ERC-20 token for payment, then he must approve at least this calculated amount of tokens. If the buyer is using ETH, then he must send this calculated amount of ETH with the transaction.","title":"Exchange Overview"},{"location":"ethereum/exchange/exchange-overview/#exchange-overview","text":"","title":"Exchange Overview"},{"location":"ethereum/exchange/exchange-overview/#asset-matching","text":"The purpose of this is to validate that makeAsset of the left order matches takeAsset from the right order and vice versa. New types of assets can be added without a smart contract upgrade. This is done using a custom IAssetMatcher. There are possible improvements to the protocol using these custom matcher contracts such as: Support for parametric assets. For example, the user can put an order to exchange 10ETH for any NFT from a popular collection. Support for NFT bundles. The general process for completing an order with the Rarible Exchange is as follows: Seller approves the Rarible exchange contract to transfer NFT on their behalf Seller creates and signs an order. They specify the types and amounts of assets they would like in return. Seller submits the order to the indexer Potential buyers query the indexer to get sell orders for a specific item or collection Buyers can create a matching buy order for a sell order from the indexer. The buyer can then submit a matching buy order to the smart contract and execute the transfer (no sig required). Or the buyer can create a new bid and submit it to the indexer (requires signature) If the buyer submits a bid, the seller can choose to accept it by creating the matching sell order and submitting it to the contract, or they can send a signed order back to the buyer which the buyer would submit to the contract.","title":"Asset matching"},{"location":"ethereum/exchange/exchange-overview/#order-structure","text":"Each order (both buy & sell) consist of a makeAsset and a takeAsset Make Asset is what you are sending. In a buy order this is what you are paying for the seller's NFT. This can be ETH, ERC20, ERC721, ERC1155, or any custom asset using their Asset Matcher interface In a sell order this is the NFT you are selling Take Asset is what you are accepting in return In a buy order this is the NFT you are buying In a sell order this is what you are willing to accept.","title":"Order Structure"},{"location":"ethereum/exchange/exchange-overview/#order","text":"Field Description Required Maker Address of entity giving up makeAsset Yes makeAsset Asset the entity is giving up Yes taker Address of counterparty no, if 0 then anyone can fill the order takeAsset Asset the entity is receving Yes salt nonce for signatures submitted with the order Generally signatures are only needed if msg.sender != maker start uint - order can't be filled before this time no end uint - order can't be filled after this time no dataType bytes4, usually hash of a string like v1 or v2 Yes data generic bytes . Can be used for protocol extensions no","title":"Order"},{"location":"ethereum/exchange/exchange-overview/#asset","text":"Field Description Required assetType Specifies ETH, specific ERC20, ERC721, ERC1155 Yes value uint Yes","title":"Asset"},{"location":"ethereum/exchange/exchange-overview/#assettype","text":"Field Description Required assetClass bytes4 specifies ETH, ERC20, ERC721 Yes data bytes - generic data depending on tp. Ex. address for ERC20, token + tokenID for ERC721 yes","title":"AssetType"},{"location":"ethereum/exchange/exchange-overview/#asset-types","text":"Asset Class data field is calculated as follows bytes4 constant public ETH_ASSET_CLASS = bytes4(keccak256(\"ETH\")); bytes4 constant public ERC20_ASSET_CLASS = bytes4(keccak256(\"ERC20\")); bytes4 constant public ERC721_ASSET_CLASS = bytes4(keccak256(\"ERC721\")); bytes4 constant public ERC1155_ASSET_CLASS = bytes4(keccak256(\"ERC1155\")); All asset types get encoded using these helper functions https://github.com/rariblecom/protocol-contracts/blob/master/exchange-v2/test/assets.js","title":"Asset Types"},{"location":"ethereum/exchange/exchange-overview/#erc721","text":"assetClass : Truncated hash of string \"ERC721\" data : ABI encoded parameters of address and tokenId value : 1 ERC721 Input (Pre encoding) { assetType: { assetClass: \"ERC721\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"1\", }","title":"ERC721"},{"location":"ethereum/exchange/exchange-overview/#erc1155","text":"assetClass : Truncated hash of string \"ERC1155\" data : ABI encoded parameters of address and tokenId value : 1->totalSupply ERC1155 Input (Pre encoding) { assetType: { assetClass: \"ERC1155\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"100\", }","title":"ERC1155"},{"location":"ethereum/exchange/exchange-overview/#erc20","text":"assetClass : Truncated hash of string \"ERC20\" data : ABI encoded parameters of address value : 1->totalSupply ERC20 Input (Pre encoding) { assetType: { assetClass: \"ERC20\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", }, value: \"10000000000000000\", }","title":"ERC20"},{"location":"ethereum/exchange/exchange-overview/#eth","text":"assetClass : Truncated hash of string \"ETH\" data : 0x value : 1->1e18 Input (pre encoding) { assetType: { assetClass: \"ETH\" }, value: \"10000000000000000\", },","title":"ETH"},{"location":"ethereum/exchange/exchange-overview/#custom-asset-matcher","text":"Any asset can be added assetClass : Truncated hash of any string data : Whatever is relevant value : some uint","title":"Custom Asset Matcher"},{"location":"ethereum/exchange/exchange-overview/#order-validation","text":"Check the start/end date of the orders. Check if the taker of the order is blank or taker = order.taker Check if the order is signed by its maker or maker of the order is executing the transaction. If the maker of the order is a contract, then an ERC-1271 check is performed. {% hint style=\"info\" %} Currently, only off-chain orders are supported, this part of the smart contract can be easily updated to support on-chain order books.","title":"Order validation"},{"location":"ethereum/exchange/exchange-overview/#order-execution","text":"Order execution is done by TransferManager. There are 2 variants: SimpleTransferManager (it simply transfers assets from maker to taker and vice versa). RaribleTransferManager (sophisticated version, it takes into account protocol commissions, royalties, etc). {% hint style=\"success\" %} There are plans to extend RaribleTransferManager to support more royalty schemes and add new features like custom fees, multiple order beneficiaries. This part of the algorithm can be extended with a custom ITransferExecutor. In the future, new executors will be added to support new asset types, for example, executor for handling bundles can be added. {% hint style=\"info\" %} Possible improvements: Support bundles. Support random boxes.","title":"Order execution"},{"location":"ethereum/exchange/exchange-overview/#fees","text":"RaribleTransferManager supports these types of fees: Protocol fees (These fees are taken from both sides of the deal). Origin fees (Origin and origin fee is set for every order. it can be different for two orders involved). Royalties (Authors of the work will receive part of each sale). Fees calculation, fee side To take a fee we need to calculate, what side of the deal can be used as money. There is a simple algorithm to do it: If ETH is from any side of the deal, it's used. If not, then if ERC-20 is in the deal, it's used. If not, then if ERC-1155 is in the deal, it's used. Otherwise, the fee is not taken (for example, two ERC-721 are involved in the deal). When we established, what part of the deal can be treated as money, then we can establish, that The Buyer is the side of the deal who owns the money. The Seller is the other side of the deal. Then the total amount of the asset (money side) should be calculated Protocol fee is added on top of the filled amount. The origin fee of the buyer's order is added on top too. If the buyer is using an ERC-20 token for payment, then he must approve at least this calculated amount of tokens. If the buyer is using ETH, then he must send this calculated amount of ETH with the transaction.","title":"Fees"},{"location":"ethereum/exchange/order-discovery/","text":"Order Discovery \u00b6 Search orders \u00b6 Example of how to query orders for all NFTs in a collection curl --location --request GET 'https://ethereum-api-staging.rarible.org/v0.1/order/orders/sell/byCollection?collection=0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575&sort=LAST_UPDATE' Response { \"orders\": [ { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x00000000000000000000000000000000000000000000000000000000000002b3\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0xf45a9adfb58fdd9da808b5f80302ebdb7d75f032d6aaee9700ee93f567fff3b148116a93ad2bd908a2d8e9576295650460a653d442f7c3472cb8f1275739075e1c\", \"createdAt\": \"2021-05-25T01:33:43.358+00:00\", \"lastUpdateAt\": \"2021-05-25T01:33:43.532+00:00\", \"pending\": [], \"hash\": \"0x0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.136582605625300000000000000000 } ], \"continuation\": \"1621906423532_0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\" } For more information on the order indexer and options for discoring orders, see the API Reference","title":"Order Discovery"},{"location":"ethereum/exchange/order-discovery/#order-discovery","text":"","title":"Order Discovery"},{"location":"ethereum/exchange/order-discovery/#search-orders","text":"Example of how to query orders for all NFTs in a collection curl --location --request GET 'https://ethereum-api-staging.rarible.org/v0.1/order/orders/sell/byCollection?collection=0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575&sort=LAST_UPDATE' Response { \"orders\": [ { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x00000000000000000000000000000000000000000000000000000000000002b3\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0xf45a9adfb58fdd9da808b5f80302ebdb7d75f032d6aaee9700ee93f567fff3b148116a93ad2bd908a2d8e9576295650460a653d442f7c3472cb8f1275739075e1c\", \"createdAt\": \"2021-05-25T01:33:43.358+00:00\", \"lastUpdateAt\": \"2021-05-25T01:33:43.532+00:00\", \"pending\": [], \"hash\": \"0x0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.136582605625300000000000000000 } ], \"continuation\": \"1621906423532_0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\" } For more information on the order indexer and options for discoring orders, see the API Reference","title":"Search orders"},{"location":"ethereum/exchange/updating-cancelling-an-order/","text":"Updating/Canceling an Order \u00b6 Updating an Order \u00b6 To update an order we need to make the changes and send a POST request to the API this can be found on the Creating A Sell Order page . New Orders check the Start, End, taker, make and value. If any of these are invalid you will receive a 400 response code from the API. {% hint style=\"danger\" %} The price can only be lowered and not increased, to increase the price you will need to cancel the order and create a new one. Canceling an Order \u00b6 Canceling an order needs to be done on-chain by calling the cancel method on the exchange contract . function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); }","title":"Updating/Canceling an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#updatingcanceling-an-order","text":"","title":"Updating/Canceling an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#updating-an-order","text":"To update an order we need to make the changes and send a POST request to the API this can be found on the Creating A Sell Order page . New Orders check the Start, End, taker, make and value. If any of these are invalid you will receive a 400 response code from the API. {% hint style=\"danger\" %} The price can only be lowered and not increased, to increase the price you will need to cancel the order and create a new one.","title":"Updating an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#canceling-an-order","text":"Canceling an order needs to be done on-chain by calling the cancel method on the exchange contract . function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); }","title":"Canceling an Order"},{"location":"ethereum/metadata/ethereum-metadata/","text":"Ethereum Metadata \u00b6 Providing Assets Metadata allows applications to extract data for digital assets and display them in an application. URIs usually represent digital assets in a smart contract. Metadata allows assets to have additional properties, such as name, description, and image. tokenURI \u00b6 To get metadata for ERC-721 and ERC-1155, you need to return the URI. To do this, use the function: tokenURI in ERC-721 uri in ERC-1155 . ERC-721 /** * @dev See {IERC721Metadata-tokenURI}. */ function tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\"); string memory _tokenURI = _tokenURIs[tokenId]; string memory base = baseURI(); // If there is no base URI, return the token URI. if (bytes(base).length == 0) { return _tokenURI; } // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked). if (bytes(_tokenURI).length > 0) { return LibURI.checkPrefix(base, _tokenURI); } // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI. return string(abi.encodePacked(base, tokenId.toString())); } ERC-1155 /** * @dev See {IERC1155MetadataURI-uri}. * * This implementation returns the same URI for *all* token types. It relies * on the token type ID substitution mechanism * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. * * Clients calling this function must replace the `\\{id\\}` substring with the * actual token type ID. */ function uri(uint256) external view virtual override returns (string memory) { return _uri; } The tokenURI or uri function returns an HTTP or IPFS URL. When requesting the URL, JSON with metadata for the token should be returned. Metadata Structure \u00b6 The Rarible Ethereum Protocol supports the Metadata structure according to the standards EIP-721 and EIP-1155 . Example of a Metadata structure for ERC-1155 NFT: { \"name\" : \"CryptoParrot#17\" , \"description\" : \"The CryptoParrot is a collection of 10,000 unique Parrot NFTs\" , \"attributes\" : [ { \"key\" : \"/background\" , \"value\" : \"rust\" }, { \"key\" : \"/body\" , \"value\" : \"lavender down\" }, { \"key\" : \"/color\" , \"value\" : \"gray\" }, { \"key\" : \"/eye\" , \"value\" : \"small 1\" }, { \"key\" : \"/head\" , \"value\" : \"navy blue nightcap\" }, { \"key\" : \"/mouth\" , \"value\" : \"yellow 6\" } ], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmUoc2LDDnHxHsesLXtpxTLupzVuyfVkJomWWHmvKNCjrL/image.png\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/png\" , \"width\" : 999 , \"height\" : 999 } } } } Description of properties: name Name of the item description A human-readable description of the item attributes key, value These are the attributes for the item image url This is the URL to the image of the item meta This is meta-information about media. Include type, width, and height animation url This is the URL to the animation of the item meta This is meta-information about media. Include type, width, and height For the Rarible Ethereum Protocol, it does not matter where the Metadata for NFT will be placed. See the example of uploading and using metadata with IPFS .","title":"Ethereum Metadata"},{"location":"ethereum/metadata/ethereum-metadata/#ethereum-metadata","text":"Providing Assets Metadata allows applications to extract data for digital assets and display them in an application. URIs usually represent digital assets in a smart contract. Metadata allows assets to have additional properties, such as name, description, and image.","title":"Ethereum Metadata"},{"location":"ethereum/metadata/ethereum-metadata/#tokenuri","text":"To get metadata for ERC-721 and ERC-1155, you need to return the URI. To do this, use the function: tokenURI in ERC-721 uri in ERC-1155 . ERC-721 /** * @dev See {IERC721Metadata-tokenURI}. */ function tokenURI(uint256 tokenId) public view virtual override returns (string memory) { require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\"); string memory _tokenURI = _tokenURIs[tokenId]; string memory base = baseURI(); // If there is no base URI, return the token URI. if (bytes(base).length == 0) { return _tokenURI; } // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked). if (bytes(_tokenURI).length > 0) { return LibURI.checkPrefix(base, _tokenURI); } // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI. return string(abi.encodePacked(base, tokenId.toString())); } ERC-1155 /** * @dev See {IERC1155MetadataURI-uri}. * * This implementation returns the same URI for *all* token types. It relies * on the token type ID substitution mechanism * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. * * Clients calling this function must replace the `\\{id\\}` substring with the * actual token type ID. */ function uri(uint256) external view virtual override returns (string memory) { return _uri; } The tokenURI or uri function returns an HTTP or IPFS URL. When requesting the URL, JSON with metadata for the token should be returned.","title":"tokenURI"},{"location":"ethereum/metadata/ethereum-metadata/#metadata-structure","text":"The Rarible Ethereum Protocol supports the Metadata structure according to the standards EIP-721 and EIP-1155 . Example of a Metadata structure for ERC-1155 NFT: { \"name\" : \"CryptoParrot#17\" , \"description\" : \"The CryptoParrot is a collection of 10,000 unique Parrot NFTs\" , \"attributes\" : [ { \"key\" : \"/background\" , \"value\" : \"rust\" }, { \"key\" : \"/body\" , \"value\" : \"lavender down\" }, { \"key\" : \"/color\" , \"value\" : \"gray\" }, { \"key\" : \"/eye\" , \"value\" : \"small 1\" }, { \"key\" : \"/head\" , \"value\" : \"navy blue nightcap\" }, { \"key\" : \"/mouth\" , \"value\" : \"yellow 6\" } ], \"image\" : { \"url\" : { \"ORIGINAL\" : \"ipfs://ipfs/QmUoc2LDDnHxHsesLXtpxTLupzVuyfVkJomWWHmvKNCjrL/image.png\" }, \"meta\" : { \"ORIGINAL\" : { \"type\" : \"image/png\" , \"width\" : 999 , \"height\" : 999 } } } } Description of properties: name Name of the item description A human-readable description of the item attributes key, value These are the attributes for the item image url This is the URL to the image of the item meta This is meta-information about media. Include type, width, and height animation url This is the URL to the animation of the item meta This is meta-information about media. Include type, width, and height For the Rarible Ethereum Protocol, it does not matter where the Metadata for NFT will be placed. See the example of uploading and using metadata with IPFS .","title":"Metadata Structure"},{"location":"ethereum/metadata/ipfs-example/","text":"Example of uploading & using Metadata with IPFS \u00b6 Uploading images to IPFS \u00b6 To upload images to IPFS, will use the Pinata service. Here you can see an example using Node JS to upload an image using the Pinata API. const axios = require(\"axios\"); const fs = require(\"fs\"); const FormData = require(\"form-data\"); export const pinFileToIPFS = (pinataApiKey, pinataSecretApiKey) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS`; let data = new FormData(); data.append(\"file\", fs.createReadStream(\"./yourfile.png\")); return axios.post(url, data, { headers: { \"Content-Type\": `multipart/form-data; boundary= ${data._boundary}`, pinata_api_key: pinataApiKey, pinata_secret_api_key: pinataSecretApiKey, }, }) .then(function (response) { console.log(repsonse.IpfsHash); }) .catch(function (error) { console.log(error) }); }; Response to the request: { IpfsHash: // This is the IPFS multi-hash provided back for your content, PinSize: // This is how large (in bytes) the content you just pinned is, Timestamp: // This is the timestamp for your content pinning (represented in ISO 8601 format) } Creating a Metadata file for NFT \u00b6 With the IpfsHash , we can create a Metadata file. It will be connected to the NFT inside the blockchain network. { \"name\": /* NFT Name - This must be a string */, \"description\": /* Description of the NFT - This must be a string */, \"image\": /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */, \"external_url\": /* This is the link to Rarible which we currently don't have, we can fill this in shortly */, \"animation_url\": /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */, // the below section is not needed. \"attributes\": [ { \"key\": /* Key name - This must be a string */, \"trait_type\": /* Trait name - This must be a string */, \"value\": /* Key Value - This must be a string */ } ] } Adding generated Metadata to IPFS \u00b6 Specify external_url in the format ${contractAddress}:${tokenId} , for example: \"external_url\": \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Publish Metadata to IPFS: var axios = require('axios'); var data = JSON.stringify({\"name\":\"Test NFT\",\"description\":\"Test NFT\",\"image\":\"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\",\"external_url\":\"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\",\"attributes\":[{\"key\":\"Test\",\"trait_type\":\"Test\",\"value\":\"Test\"}]}); var config = { method: 'post', url: 'https://api.pinata.cloud/pinning/pinFileToIPFS', headers: { 'pinata_api_key': // KEY_HERE, 'pinata_secret_api_key': // SECRET_KEY_HERE, 'Content-Type': 'application/json' }, data: data }; axios(config).then(function (response) { console.log(JSON.stringify(response.data)); }).catch(function (error) { console.log(error); }); Response example: { \"IpfsHash\": \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\", \"PinSize\": 290, \"Timestamp\": \"2021-02-10T14:06:09.255Z\" } Attach the new IpfsHash to your NFT.","title":"Example of uploading and using Metadata with IPFS"},{"location":"ethereum/metadata/ipfs-example/#example-of-uploading-using-metadata-with-ipfs","text":"","title":"Example of uploading &amp; using Metadata with IPFS"},{"location":"ethereum/metadata/ipfs-example/#uploading-images-to-ipfs","text":"To upload images to IPFS, will use the Pinata service. Here you can see an example using Node JS to upload an image using the Pinata API. const axios = require(\"axios\"); const fs = require(\"fs\"); const FormData = require(\"form-data\"); export const pinFileToIPFS = (pinataApiKey, pinataSecretApiKey) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS`; let data = new FormData(); data.append(\"file\", fs.createReadStream(\"./yourfile.png\")); return axios.post(url, data, { headers: { \"Content-Type\": `multipart/form-data; boundary= ${data._boundary}`, pinata_api_key: pinataApiKey, pinata_secret_api_key: pinataSecretApiKey, }, }) .then(function (response) { console.log(repsonse.IpfsHash); }) .catch(function (error) { console.log(error) }); }; Response to the request: { IpfsHash: // This is the IPFS multi-hash provided back for your content, PinSize: // This is how large (in bytes) the content you just pinned is, Timestamp: // This is the timestamp for your content pinning (represented in ISO 8601 format) }","title":"Uploading images to IPFS"},{"location":"ethereum/metadata/ipfs-example/#creating-a-metadata-file-for-nft","text":"With the IpfsHash , we can create a Metadata file. It will be connected to the NFT inside the blockchain network. { \"name\": /* NFT Name - This must be a string */, \"description\": /* Description of the NFT - This must be a string */, \"image\": /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */, \"external_url\": /* This is the link to Rarible which we currently don't have, we can fill this in shortly */, \"animation_url\": /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */, // the below section is not needed. \"attributes\": [ { \"key\": /* Key name - This must be a string */, \"trait_type\": /* Trait name - This must be a string */, \"value\": /* Key Value - This must be a string */ } ] }","title":"Creating a Metadata file for NFT"},{"location":"ethereum/metadata/ipfs-example/#adding-generated-metadata-to-ipfs","text":"Specify external_url in the format ${contractAddress}:${tokenId} , for example: \"external_url\": \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Publish Metadata to IPFS: var axios = require('axios'); var data = JSON.stringify({\"name\":\"Test NFT\",\"description\":\"Test NFT\",\"image\":\"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\",\"external_url\":\"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\",\"attributes\":[{\"key\":\"Test\",\"trait_type\":\"Test\",\"value\":\"Test\"}]}); var config = { method: 'post', url: 'https://api.pinata.cloud/pinning/pinFileToIPFS', headers: { 'pinata_api_key': // KEY_HERE, 'pinata_secret_api_key': // SECRET_KEY_HERE, 'Content-Type': 'application/json' }, data: data }; axios(config).then(function (response) { console.log(JSON.stringify(response.data)); }).catch(function (error) { console.log(error); }); Response example: { \"IpfsHash\": \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\", \"PinSize\": 290, \"Timestamp\": \"2021-02-10T14:06:09.255Z\" } Attach the new IpfsHash to your NFT.","title":"Adding generated Metadata to IPFS"},{"location":"ethereum/sdk/ethereum-sdk/","text":"Ethereum SDK \u00b6 Rarible Protocol Ethereum SDK enables apps to easily interact with Rarible protocol. Take a look at this sample app with React for a quick start. Installation \u00b6 npm install -D @rarible/protocol-ethereum-sdk or inject package into your web page with web3 instance <script src=\"https://unpkg.com/@rarible/web3-ethereum@0.10.0/umd/rarible-web3-ethereum.js\" type=\"text/javascript\"></script> <script src=\"https://unpkg.com/@rarible/protocol-ethereum-sdk@0.10.0/umd/rarible-ethereum-sdk.js\" type=\"text/javascript\"></script> <script src=\"https://unpkg.com/web3@1.6.0/dist/web3.min.js\" type=\"text/javascript\"></script> Usage with web3.js \u00b6 Configure and create Rarible SDK object \u00b6 import { createRaribleSdk } from \"@rarible/protocol-ethereum-sdk\" const sdk = createRaribleSdk(web3, env, { fetchApi: fetch }) web3 - configured with your provider web3js client env - environment configuration name, it should accept one of these values ropsten , rinkeby , mainnet or e2e Configure Rarible SDK in browser \u00b6 const web = new Web3(ethereum) const web3Ethereum = new window.raribleWeb3Ethereum.Web3Ethereum({ web3: web }) const env = \"mainnet\" // \"e2e\" | \"ropsten\" | \"rinkeby\" | \"mainnet\" const raribleSdk = new window.raribleEthereumSdk.createRaribleSdk(web3Ethereum, env) ethereum - metamask browser instance (window.ethereum) For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.","title":"Ethereum SDK"},{"location":"ethereum/sdk/ethereum-sdk/#ethereum-sdk","text":"Rarible Protocol Ethereum SDK enables apps to easily interact with Rarible protocol. Take a look at this sample app with React for a quick start.","title":"Ethereum SDK"},{"location":"ethereum/sdk/ethereum-sdk/#installation","text":"npm install -D @rarible/protocol-ethereum-sdk or inject package into your web page with web3 instance <script src=\"https://unpkg.com/@rarible/web3-ethereum@0.10.0/umd/rarible-web3-ethereum.js\" type=\"text/javascript\"></script> <script src=\"https://unpkg.com/@rarible/protocol-ethereum-sdk@0.10.0/umd/rarible-ethereum-sdk.js\" type=\"text/javascript\"></script> <script src=\"https://unpkg.com/web3@1.6.0/dist/web3.min.js\" type=\"text/javascript\"></script>","title":"Installation"},{"location":"ethereum/sdk/ethereum-sdk/#usage-with-web3js","text":"","title":"Usage with web3.js"},{"location":"ethereum/sdk/ethereum-sdk/#configure-and-create-rarible-sdk-object","text":"import { createRaribleSdk } from \"@rarible/protocol-ethereum-sdk\" const sdk = createRaribleSdk(web3, env, { fetchApi: fetch }) web3 - configured with your provider web3js client env - environment configuration name, it should accept one of these values ropsten , rinkeby , mainnet or e2e","title":"Configure and create Rarible SDK object"},{"location":"ethereum/sdk/ethereum-sdk/#configure-rarible-sdk-in-browser","text":"const web = new Web3(ethereum) const web3Ethereum = new window.raribleWeb3Ethereum.Web3Ethereum({ web3: web }) const env = \"mainnet\" // \"e2e\" | \"ropsten\" | \"rinkeby\" | \"mainnet\" const raribleSdk = new window.raribleEthereumSdk.createRaribleSdk(web3Ethereum, env) ethereum - metamask browser instance (window.ethereum) For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.","title":"Configure Rarible SDK in browser"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/","text":"ExchangeV2 Matching Orders \u00b6 The main function of ExchangeV2 is matchOrders. This function takes two sides of an order and attempts to match them. The matching order process can be divided into stages: Order Validation \u2014 checks if the order parameters are valid and the caller is authorized to execute the order. Asset Matching \u2014 checks the assets from left & right order match and then extracts the matching assets. Calculating Fill \u2014 checks and finds out what exact values should be filled. Orders can also be matched partly. This occurs if one of the sides doesn't want to fill other orders completely. Order Execution, Transfers - execute the transfers of the assets, saving Order filling if necessary. Order Validation \u00b6 Check the start/end date of the order. Check whether the receiver of this order is empty or the receiver is the same as order.taker. Check whether the order is signed by its creator or the creator of the order performs a transaction. If the creator of the order is a contract, then an ERC-1271 check is performed. Currently, only orders outside the blockchain network are supported. This part of the smart contract can be easily updated to support Order Book on-chain. Asset Matching \u00b6 The main goal is to check that makeAsset (left) matches takeAsset (right) and vice versa. makeAsset is what you sell. The purchase order is what you pay for the seller's NFT. It can be ERC-20, ERC-721, ERC-1155, or any custom resource that uses the asset mapping interface. The sales order is the NFT that you are selling. takeAsset is what you accept in return. The purchase order is the NFT that you are buying. The sales order is what you are willing to accept. New asset types can be added without updating the smart contract. You can do it with a custom IAssetMatcher. Possible improvements: Support for parametric assets. For example, a user can place an order to exchange 10 ETH for any NFT from a popular collection. Support for NFT packages. Calculating Fill and Order Execution \u00b6 The order fill is stored inside the smart contract and refers to the taking part of the order. Fill is stored inside the mapping slot, the key to which is calculated using the fields: maker make asset type take asset type salt Fill orders that differ only in the exchange rate are stored in one mapping slot. In addition, full filled orders can be expanded: users can sign new orders using the same salt. For example, they can increase make.value and take.value. Priority of the order rate \u2014 if the exchange rates differ, but orders can be filled (for example, the left order is 10X -> 100Y, and the right one is 100Y -> 5X), then the part on the left determines the exchange rate. Rounding errors \u2014 mathematical operations calculate the filling volumes. When rounding is performed and the error exceeds 0.1%, a rounding error will be issued, and the order will not be executed. Transfer Execution \u00b6 Transfers are made using Transfer Manager: SimpleTransferManager - transfers assets from maker to taker and vice versa. RaribleTransferManager - is a complex version. It takes into account protocol commissions, royalties, etc. It is planned to expand the RaribleTransferManager to support more royalty schemes and add new features. For example, user fees or multiple order recipients. This part of the algorithm can be extended using ITransferExecutor. It will be added new executors to support new asset types. For example, an executor may be added to process packages. Possible improvements: Package support. Support for random boxes.","title":"ExchangeV2 Matching Orders"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#exchangev2-matching-orders","text":"The main function of ExchangeV2 is matchOrders. This function takes two sides of an order and attempts to match them. The matching order process can be divided into stages: Order Validation \u2014 checks if the order parameters are valid and the caller is authorized to execute the order. Asset Matching \u2014 checks the assets from left & right order match and then extracts the matching assets. Calculating Fill \u2014 checks and finds out what exact values should be filled. Orders can also be matched partly. This occurs if one of the sides doesn't want to fill other orders completely. Order Execution, Transfers - execute the transfers of the assets, saving Order filling if necessary.","title":"ExchangeV2 Matching Orders"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#order-validation","text":"Check the start/end date of the order. Check whether the receiver of this order is empty or the receiver is the same as order.taker. Check whether the order is signed by its creator or the creator of the order performs a transaction. If the creator of the order is a contract, then an ERC-1271 check is performed. Currently, only orders outside the blockchain network are supported. This part of the smart contract can be easily updated to support Order Book on-chain.","title":"Order Validation"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#asset-matching","text":"The main goal is to check that makeAsset (left) matches takeAsset (right) and vice versa. makeAsset is what you sell. The purchase order is what you pay for the seller's NFT. It can be ERC-20, ERC-721, ERC-1155, or any custom resource that uses the asset mapping interface. The sales order is the NFT that you are selling. takeAsset is what you accept in return. The purchase order is the NFT that you are buying. The sales order is what you are willing to accept. New asset types can be added without updating the smart contract. You can do it with a custom IAssetMatcher. Possible improvements: Support for parametric assets. For example, a user can place an order to exchange 10 ETH for any NFT from a popular collection. Support for NFT packages.","title":"Asset Matching"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#calculating-fill-and-order-execution","text":"The order fill is stored inside the smart contract and refers to the taking part of the order. Fill is stored inside the mapping slot, the key to which is calculated using the fields: maker make asset type take asset type salt Fill orders that differ only in the exchange rate are stored in one mapping slot. In addition, full filled orders can be expanded: users can sign new orders using the same salt. For example, they can increase make.value and take.value. Priority of the order rate \u2014 if the exchange rates differ, but orders can be filled (for example, the left order is 10X -> 100Y, and the right one is 100Y -> 5X), then the part on the left determines the exchange rate. Rounding errors \u2014 mathematical operations calculate the filling volumes. When rounding is performed and the error exceeds 0.1%, a rounding error will be issued, and the order will not be executed.","title":"Calculating Fill and Order Execution"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#transfer-execution","text":"Transfers are made using Transfer Manager: SimpleTransferManager - transfers assets from maker to taker and vice versa. RaribleTransferManager - is a complex version. It takes into account protocol commissions, royalties, etc. It is planned to expand the RaribleTransferManager to support more royalty schemes and add new features. For example, user fees or multiple order recipients. This part of the algorithm can be extended using ITransferExecutor. It will be added new executors to support new asset types. For example, an executor may be added to process packages. Possible improvements: Package support. Support for random boxes.","title":"Transfer Execution"},{"location":"ethereum/smart-contracts/exchangev2-overview/","text":"ExchangeV2 Overview \u00b6 ExchangeV2 is a smart contract for the decentralized exchange of any assets represented in the Ethereum blockchain (or EVM compatible). To make an exchange two orders are required: Sale Order \u2014 Created by the seller. Purchase Order \u2014 Bid made by the buyer. The exchange occurs if the two orders above match. The general process of creating and executing an order is as follows: The seller confirms that the exchange contract can dispose of their assets/tokens. The seller creates and signs an order. Specifies the types and amounts of assets they want to receive in return. The seller sends the order to the indexer. The buyer sends an indexer request to get an order for a specific item or collection. The buyer creates a bid. If the order and bid are matched, an exchange takes place. If the order and bid do not match, then the seller can accept the Bid or not. If it accepts, then an exchange takes place. The order can be signed or not. The signature may be missing if the transaction is executed by the person who created this order. See more information about: ExchangeV2 Matching Orders ExchangeV2 Sell and Bid ExchangeV2 Update and Cancel","title":"ExchangeV2 Overview"},{"location":"ethereum/smart-contracts/exchangev2-overview/#exchangev2-overview","text":"ExchangeV2 is a smart contract for the decentralized exchange of any assets represented in the Ethereum blockchain (or EVM compatible). To make an exchange two orders are required: Sale Order \u2014 Created by the seller. Purchase Order \u2014 Bid made by the buyer. The exchange occurs if the two orders above match. The general process of creating and executing an order is as follows: The seller confirms that the exchange contract can dispose of their assets/tokens. The seller creates and signs an order. Specifies the types and amounts of assets they want to receive in return. The seller sends the order to the indexer. The buyer sends an indexer request to get an order for a specific item or collection. The buyer creates a bid. If the order and bid are matched, an exchange takes place. If the order and bid do not match, then the seller can accept the Bid or not. If it accepts, then an exchange takes place. The order can be signed or not. The signature may be missing if the transaction is executed by the person who created this order. See more information about: ExchangeV2 Matching Orders ExchangeV2 Sell and Bid ExchangeV2 Update and Cancel","title":"ExchangeV2 Overview"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/","text":"ExchangeV2 Sell and Bid \u00b6 Sell Order \u00b6 To create a Sell Order, use the Ethereum SDK: Check that the exchange contract can dispose of assets, tokens. Call setApprovalForAll if necessary. Create a signature: Encrypt the order for signing . Sign the order . Send the signed order to the API. Example of creating a Sell Order in SDK. Bid \u00b6 To make a purchase or accept a Bid, send a transaction to the matchOrders function of the contract ExchangeV2 . matchOrders function has parameters: left order left order signature right order right order signature Example of creating a Bid in SDK.","title":"ExchangeV2 Sell and Bid"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#exchangev2-sell-and-bid","text":"","title":"ExchangeV2 Sell and Bid"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#sell-order","text":"To create a Sell Order, use the Ethereum SDK: Check that the exchange contract can dispose of assets, tokens. Call setApprovalForAll if necessary. Create a signature: Encrypt the order for signing . Sign the order . Send the signed order to the API. Example of creating a Sell Order in SDK.","title":"Sell Order"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#bid","text":"To make a purchase or accept a Bid, send a transaction to the matchOrders function of the contract ExchangeV2 . matchOrders function has parameters: left order left order signature right order right order signature Example of creating a Bid in SDK.","title":"Bid"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/","text":"ExchangeV2 Update and Cancel \u00b6 Update \u00b6 To update the order: Make changes. Send a request to the API (see Sell Order ). New orders check the: start, end, take, make and value fields. The price can only be reduced. You will need to cancel the order and create a new one to increase the price. Since if the user has already signed a message with a lower price, someone could save this message and signature. You can't cancel it without contacting the contract. Cancel \u00b6 To cancel the order, call the cancellation method in the ExchangeV2 contract. function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); } An error will be returned when matching such an order. Orders makers can only call this function. It marks orders that cannot be filled.","title":"ExchangeV2 Update and Cancel"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#exchangev2-update-and-cancel","text":"","title":"ExchangeV2 Update and Cancel"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#update","text":"To update the order: Make changes. Send a request to the API (see Sell Order ). New orders check the: start, end, take, make and value fields. The price can only be reduced. You will need to cancel the order and create a new one to increase the price. Since if the user has already signed a message with a lower price, someone could save this message and signature. You can't cancel it without contacting the contract.","title":"Update"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#cancel","text":"To cancel the order, call the cancellation method in the ExchangeV2 contract. function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); } An error will be returned when matching such an order. Orders makers can only call this function. It marks orders that cannot be filled.","title":"Cancel"},{"location":"ethereum/smart-contracts/fees/","text":"Fees \u00b6 RaribleTransferManager supports the following types of fees: Protocol fees \u2014 are charged on both sides of the transaction. Origin fees \u2014 set for each order. It may differ for two orders. Royalties \u2014 the author of the work will receive a part of each sale. Algorithm \u00b6 The transfer of assets takes place inside the doTransfers . The following parameters are used as arguments: LibAsset.AssetType makeMatch \u2014 AssetType on the make-side order LibAsset.AssetType takeMatch \u2014 AssetType on the take-side order LibFill.FillResult fill \u2014 values on both sides that will be passed by match LibOrder.Order leftOrder \u2014 left order data LibOrder.Order rightOrder \u2014 right order data In this method, the following actions are performed. How do we calculate the commission side of the transaction? \u00b6 Use LibFeeSide.getFeeSide . It takes as arguments assetClasses of both sides (for example, ETH and ERC20 ). LibFeeSide.getFeeSide tries to determine side to pay fees: If there is ETH on any side of the transaction, it is used. If there is no ETH, we check if there is an ERC-20 and use it. If there is no ERC-20, check if there is an ERC-1155 and use it. Otherwise, no fee will be charged. (e.g. if two ERC-721 are involved in the transaction) Transfer \u00b6 If the make-side pays fees: calling doTransfersWithFees for the make-side calling transferPayouts for the take-side If the take-side pays fees: calling doTransfersWithFees for the take-side calling transferPayouts for the make-side If the side for the payment of fees are not defined: call transferPayouts for both sides When computing the total amount of the asset: The protocol fee is added on top of the filled amount. The fee for sending the buyer's order is also added on top. If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens. If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction. For more information about fees, see the page RaribleTransferManager on GitHub.","title":"Fees"},{"location":"ethereum/smart-contracts/fees/#fees","text":"RaribleTransferManager supports the following types of fees: Protocol fees \u2014 are charged on both sides of the transaction. Origin fees \u2014 set for each order. It may differ for two orders. Royalties \u2014 the author of the work will receive a part of each sale.","title":"Fees"},{"location":"ethereum/smart-contracts/fees/#algorithm","text":"The transfer of assets takes place inside the doTransfers . The following parameters are used as arguments: LibAsset.AssetType makeMatch \u2014 AssetType on the make-side order LibAsset.AssetType takeMatch \u2014 AssetType on the take-side order LibFill.FillResult fill \u2014 values on both sides that will be passed by match LibOrder.Order leftOrder \u2014 left order data LibOrder.Order rightOrder \u2014 right order data In this method, the following actions are performed.","title":"Algorithm"},{"location":"ethereum/smart-contracts/fees/#how-do-we-calculate-the-commission-side-of-the-transaction","text":"Use LibFeeSide.getFeeSide . It takes as arguments assetClasses of both sides (for example, ETH and ERC20 ). LibFeeSide.getFeeSide tries to determine side to pay fees: If there is ETH on any side of the transaction, it is used. If there is no ETH, we check if there is an ERC-20 and use it. If there is no ERC-20, check if there is an ERC-1155 and use it. Otherwise, no fee will be charged. (e.g. if two ERC-721 are involved in the transaction)","title":"How do we calculate the commission side of the transaction?"},{"location":"ethereum/smart-contracts/fees/#transfer","text":"If the make-side pays fees: calling doTransfersWithFees for the make-side calling transferPayouts for the take-side If the take-side pays fees: calling doTransfersWithFees for the take-side calling transferPayouts for the make-side If the side for the payment of fees are not defined: call transferPayouts for both sides When computing the total amount of the asset: The protocol fee is added on top of the filled amount. The fee for sending the buyer's order is also added on top. If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens. If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction. For more information about fees, see the page RaribleTransferManager on GitHub.","title":"Transfer"},{"location":"ethereum/smart-contracts/royalties/","text":"Royalties \u00b6 Royalties V2 \u00b6 Rarible defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts . It exposes getRoyalties method, which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. function getRaribleV2Royalties ( uint256 id ) override external view returns ( LibPart . Part [] memory ) { return royalties [ id ]; } Royalties V1 \u00b6 The exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry . The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array. This allows for Rarible to support different royalty standards for different collections. Rarible Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient and fees.value . fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received. fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here . Below you can find the code block from ExchangeV1, which handles the on-chain royalties. contract HasSecondarySaleFees is ERC165 { event SecondarySaleFees ( uint256 tokenId , address [] recipients , uint [] bps ); /* * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb * * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584 */ bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584 ; constructor () public { _registerInterface ( _INTERFACE_ID_FEES ); } function getFeeRecipients ( uint256 id ) public view returns ( address payable [] memory ); function getFeeBps ( uint256 id ) public view returns ( uint [] memory ); } Examples \u00b6 Setting Up Royalties on an External Collection","title":"Royalties"},{"location":"ethereum/smart-contracts/royalties/#royalties","text":"","title":"Royalties"},{"location":"ethereum/smart-contracts/royalties/#royalties-v2","text":"Rarible defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts . It exposes getRoyalties method, which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. function getRaribleV2Royalties ( uint256 id ) override external view returns ( LibPart . Part [] memory ) { return royalties [ id ]; }","title":"Royalties V2"},{"location":"ethereum/smart-contracts/royalties/#royalties-v1","text":"The exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry . The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array. This allows for Rarible to support different royalty standards for different collections. Rarible Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient and fees.value . fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received. fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here . Below you can find the code block from ExchangeV1, which handles the on-chain royalties. contract HasSecondarySaleFees is ERC165 { event SecondarySaleFees ( uint256 tokenId , address [] recipients , uint [] bps ); /* * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb * * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584 */ bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584 ; constructor () public { _registerInterface ( _INTERFACE_ID_FEES ); } function getFeeRecipients ( uint256 id ) public view returns ( address payable [] memory ); function getFeeBps ( uint256 id ) public view returns ( uint [] memory ); }","title":"Royalties V1"},{"location":"ethereum/smart-contracts/royalties/#examples","text":"Setting Up Royalties on an External Collection","title":"Examples"},{"location":"ethereum/smart-contracts/smart-contracts/","text":"Smart Contracts Overview \u00b6 Rarible Smart Contracts for Ethereum consist of: Exchange V2 \u2014 purchase and sale of tokens Tokens, TokenFactories \u2014 tokens contracts and Token Factories RoyaltiesRegistry \u2014 embedded royalties in NFT RoyaltiesProviders \u2014 commissions getting from individual contracts TransferProxy \u2014 token exchange according of the type Betting \u2014 tokens deposit in exchange for raising points. That makes it possible to take an active part in solving DAO issues Auctions \u2014 fixed-bid auction OnChainOrders \u2014 will be added to ExchangeV2 soon Let's look closer at the following components: Exchange V2 Tokens Fees Royalties For more information on using Rarible Smart Contracts, see the page Protocol Contracts on GitHub.","title":"Smart Contracts Overview"},{"location":"ethereum/smart-contracts/smart-contracts/#smart-contracts-overview","text":"Rarible Smart Contracts for Ethereum consist of: Exchange V2 \u2014 purchase and sale of tokens Tokens, TokenFactories \u2014 tokens contracts and Token Factories RoyaltiesRegistry \u2014 embedded royalties in NFT RoyaltiesProviders \u2014 commissions getting from individual contracts TransferProxy \u2014 token exchange according of the type Betting \u2014 tokens deposit in exchange for raising points. That makes it possible to take an active part in solving DAO issues Auctions \u2014 fixed-bid auction OnChainOrders \u2014 will be added to ExchangeV2 soon Let's look closer at the following components: Exchange V2 Tokens Fees Royalties For more information on using Rarible Smart Contracts, see the page Protocol Contracts on GitHub.","title":"Smart Contracts Overview"},{"location":"ethereum/smart-contracts/tokens/","text":"Tokens \u00b6 Rarible Protocol Ethereum supports two types of tokens: ERC-721 is a standard interface for non-interchangeable tokens. This type of token is unique and may have a value different from the value of another token from the same smart contract. ERC-1155 is a standard interface for contracts that manage multiple types of tokens. One deployed contract can include any combination of interchangeable tokens, non-interchangeable tokens, or other configurations. You can mint both types of tokens as follows: A regular minting in a blockchain network using a contract. Lazy minting \u2014 minting of the token occurs outside the blockchain network. Entry into the blockchain and payment for gas is made when the token is purchased or transferred. Users can create tokens in different smart contracts. Tokens also support saving information about Royalties and information about all creators. Token Factories \u00b6 To create ERC-721 and ERC-1155 smart contracts, use our Token Factories. The addresses are available on the Contract Addresses page. Using Token Factories, you can create the following types of smart contracts: Public ERC-721 and ERC-1155 Private ERC-721 and ERC-1155 Token Factories create beacon proxy servers . Rarible Protocol can automatically update these contracts when all token contracts are updated. Minting \u00b6 Minting is using the mintAndTransfer function for ERC-721 and ERC-1155 contracts. For ERC-721, the function has the following signature: mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) . struct Mint721Data { uint tokenId; string tokenURI; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-721 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs:/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. For ERC-1155, the function has the following signature: mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) . struct Mint1155Data { uint tokenId; string tokenURI; uint supply; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-1155 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs:/ supply \u2014 total number of tokens for minting creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. Lazy Minting \u00b6 Lazy Minting is supported for ERC-721 and ERC-1155. To create Lazy Minting: Generate a token ID. Create a Lazy Minting request body that the creator must sign. The creator signs the provided data. Add signature to the request body Send the data to the API. See an example of creating Lazy Minting by using API. For more information about Lazy Minting, see SDK page. Transfer \u00b6 This function transfers the token from the sender to the new owner. Arguments: owner: Address \u2014 address of the asset owner asset: Asset \u2014 asset type The function checks the asset type and performs one of the following functions: transferErc721 transferErc1155 transferErc1155 arguments: export async function transferErc1155( ethereum: Ethereum, send: SendFunction, contract: Address, from: Address, to: Address, tokenId: string | string[], tokenAmount: string | string[] contract: Address \u2014 contract address ERC-1155 from: Address \u2014 address of the ERC-1155 token owner to: Address \u2014 address of the new owner tokenId: string | string[] \u2014 token ID or token array for transfer tokenAmount: string | string[] \u2014 number of ERC-1155 tokens or an array of tokens for transfer transferErc721 arguments: export async function transferErc721( ethereum: Ethereum, send: SendFunction, contract: Address, from: Address, to: Address, tokenId: string contract: Address \u2014 contract address ERC-721 from: Address \u2014 address of the ERC-721 token owner to: Address \u2014 address of the new owner tokenId: string | string[] \u2014 token ID for transfer Deploy \u00b6 TODO Burn \u00b6 To Burn a token, call the function: const hash = await sdk.nft.burn({ contract: contractAddress, tokenId: toBigNumber(tokenId), }) contract \u2014 smart contract address tokenId \u2014 token identifier","title":"Tokens"},{"location":"ethereum/smart-contracts/tokens/#tokens","text":"Rarible Protocol Ethereum supports two types of tokens: ERC-721 is a standard interface for non-interchangeable tokens. This type of token is unique and may have a value different from the value of another token from the same smart contract. ERC-1155 is a standard interface for contracts that manage multiple types of tokens. One deployed contract can include any combination of interchangeable tokens, non-interchangeable tokens, or other configurations. You can mint both types of tokens as follows: A regular minting in a blockchain network using a contract. Lazy minting \u2014 minting of the token occurs outside the blockchain network. Entry into the blockchain and payment for gas is made when the token is purchased or transferred. Users can create tokens in different smart contracts. Tokens also support saving information about Royalties and information about all creators.","title":"Tokens"},{"location":"ethereum/smart-contracts/tokens/#token-factories","text":"To create ERC-721 and ERC-1155 smart contracts, use our Token Factories. The addresses are available on the Contract Addresses page. Using Token Factories, you can create the following types of smart contracts: Public ERC-721 and ERC-1155 Private ERC-721 and ERC-1155 Token Factories create beacon proxy servers . Rarible Protocol can automatically update these contracts when all token contracts are updated.","title":"Token Factories"},{"location":"ethereum/smart-contracts/tokens/#minting","text":"Minting is using the mintAndTransfer function for ERC-721 and ERC-1155 contracts. For ERC-721, the function has the following signature: mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) . struct Mint721Data { uint tokenId; string tokenURI; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-721 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs:/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. For ERC-1155, the function has the following signature: mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) . struct Mint1155Data { uint tokenId; string tokenURI; uint supply; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-1155 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs:/ supply \u2014 total number of tokens for minting creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction.","title":"Minting"},{"location":"ethereum/smart-contracts/tokens/#lazy-minting","text":"Lazy Minting is supported for ERC-721 and ERC-1155. To create Lazy Minting: Generate a token ID. Create a Lazy Minting request body that the creator must sign. The creator signs the provided data. Add signature to the request body Send the data to the API. See an example of creating Lazy Minting by using API. For more information about Lazy Minting, see SDK page.","title":"Lazy Minting"},{"location":"ethereum/smart-contracts/tokens/#transfer","text":"This function transfers the token from the sender to the new owner. Arguments: owner: Address \u2014 address of the asset owner asset: Asset \u2014 asset type The function checks the asset type and performs one of the following functions: transferErc721 transferErc1155 transferErc1155 arguments: export async function transferErc1155( ethereum: Ethereum, send: SendFunction, contract: Address, from: Address, to: Address, tokenId: string | string[], tokenAmount: string | string[] contract: Address \u2014 contract address ERC-1155 from: Address \u2014 address of the ERC-1155 token owner to: Address \u2014 address of the new owner tokenId: string | string[] \u2014 token ID or token array for transfer tokenAmount: string | string[] \u2014 number of ERC-1155 tokens or an array of tokens for transfer transferErc721 arguments: export async function transferErc721( ethereum: Ethereum, send: SendFunction, contract: Address, from: Address, to: Address, tokenId: string contract: Address \u2014 contract address ERC-721 from: Address \u2014 address of the ERC-721 token owner to: Address \u2014 address of the new owner tokenId: string | string[] \u2014 token ID for transfer","title":"Transfer"},{"location":"ethereum/smart-contracts/tokens/#deploy","text":"TODO","title":"Deploy"},{"location":"ethereum/smart-contracts/tokens/#burn","text":"To Burn a token, call the function: const hash = await sdk.nft.burn({ contract: contractAddress, tokenId: toBigNumber(tokenId), }) contract \u2014 smart contract address tokenId \u2014 token identifier","title":"Burn"},{"location":"flow/flow-overview/","text":"Flow overview \u00b6 Rarible is currently testing this integration, aiming to release it between 8th and the 12nd of November. Support for the Flow blockchain was built by the Rarible team: smart contracts: https://github.com/rarible/flow-contracts indexer: https://github.com/rarible/flow-nft-indexer SDK: https://github.com/rarible/flow-sdk","title":"Flow overview"},{"location":"flow/flow-overview/#flow-overview","text":"Rarible is currently testing this integration, aiming to release it between 8th and the 12nd of November. Support for the Flow blockchain was built by the Rarible team: smart contracts: https://github.com/rarible/flow-contracts indexer: https://github.com/rarible/flow-nft-indexer SDK: https://github.com/rarible/flow-sdk","title":"Flow overview"},{"location":"getting-started/protocol-example/","text":"Example app \u00b6 Start with Rarible Protocol SDK . Also, you can create a Protocol Example App for a quick start. In this example, you can: Configure Rarible SDK Create Lazy mint NFT item Create sell order Purchase (buy item) an order Get your NFT from your current wallet Also, you can try scaffold-eth Rarible Starter App . Example of NFT purchase flow \u00b6 Click buy NFT in the app. The frontend calls the Buy function in the Union SDK. Union SDK calls the Buy function in the SDK of the desired network. SDK prepares and sends the transaction to the underlying blockchain. Indexer listens to purchase, transfer events, updates NFT state internally. Indexer transmits the event to Union. Union sends the information about the event to the backend of the application.","title":"Protocol Example"},{"location":"getting-started/protocol-example/#example-app","text":"Start with Rarible Protocol SDK . Also, you can create a Protocol Example App for a quick start. In this example, you can: Configure Rarible SDK Create Lazy mint NFT item Create sell order Purchase (buy item) an order Get your NFT from your current wallet Also, you can try scaffold-eth Rarible Starter App .","title":"Example app"},{"location":"getting-started/protocol-example/#example-of-nft-purchase-flow","text":"Click buy NFT in the app. The frontend calls the Buy function in the Union SDK. Union SDK calls the Buy function in the SDK of the desired network. SDK prepares and sends the transaction to the underlying blockchain. Indexer listens to purchase, transfer events, updates NFT state internally. Indexer transmits the event to Union. Union sends the information about the event to the backend of the application.","title":"Example of NFT purchase flow"},{"location":"overview/api-reference/","text":"API Reference \u00b6 Use these base URLs to access our API on different networks. api.rarible.org or any testnet equivalent is compatible with all blockchains supported by the Rarirble Protocol. We also use the term union to describe this compatibility case in the docs. ethereum-api.rarible.org or any testnet equivalent is only compatible with the ethereum blockchain. Mainnet \u00b6 Base URL Name https://api.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api.rarible.org/v0.1/doc Ethereum Staging (Rinkeby) \u00b6 Base URL Name https://api-staging.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api-staging.rarible.org/v0.1/doc Ethereum Development (Ropsten) \u00b6 Base URL Name https://api-dev.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api-dev.rarible.org/v0.1/doc Ethereum e2e \u00b6 Base URL Name https://api-e2e.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api-e2e.rarible.org/v0.1/doc Ethereum","title":"API Reference"},{"location":"overview/api-reference/#api-reference","text":"Use these base URLs to access our API on different networks. api.rarible.org or any testnet equivalent is compatible with all blockchains supported by the Rarirble Protocol. We also use the term union to describe this compatibility case in the docs. ethereum-api.rarible.org or any testnet equivalent is only compatible with the ethereum blockchain.","title":"API Reference"},{"location":"overview/api-reference/#mainnet","text":"Base URL Name https://api.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api.rarible.org/v0.1/doc Ethereum","title":"Mainnet"},{"location":"overview/api-reference/#staging-rinkeby","text":"Base URL Name https://api-staging.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api-staging.rarible.org/v0.1/doc Ethereum","title":"Staging (Rinkeby)"},{"location":"overview/api-reference/#development-ropsten","text":"Base URL Name https://api-dev.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api-dev.rarible.org/v0.1/doc Ethereum","title":"Development (Ropsten)"},{"location":"overview/api-reference/#e2e","text":"Base URL Name https://api-e2e.rarible.org/v0.1/doc Rarible Protocol https://ethereum-api-e2e.rarible.org/v0.1/doc Ethereum","title":"e2e"},{"location":"overview/glossary/","text":"Glossary \u00b6 This document contains a glossary with an alphabetical list, definitions, and terms related to API. A | B | C | E | I | F | L | M | N | O | P | R | S | T A \u00b6 API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.). Asset Class Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.). B \u00b6 Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain. C \u00b6 Collection NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted. Continuation Continuation token from the previous response. Contract Address of the Smart Contract. Creator Address of the NFT item creator. E \u00b6 ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations. I \u00b6 Item Address of the NFT item. Id of the Item has format ${contract}:${tokenId} . F \u00b6 Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties. L \u00b6 Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer. M \u00b6 Make Make the side of the Order. Make - what maker (order creator) has. Maker Creator of the order. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain. N \u00b6 NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art. O \u00b6 Origin Fee Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize. Owner Address of the NFT item owner. Ownership Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format ${contract}:${tokenId}:${owner} . P \u00b6 Payouts Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users. Platform The platform where the order was created. R \u00b6 Royalties Fees that are usually paid to the creator on every sale. S \u00b6 Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Supply Total number of tokens minted or to be minted. T \u00b6 Take Take the side of the order, what order creator wants to get in return for make side. Token ID Token identifier.","title":"Glossary"},{"location":"overview/glossary/#glossary","text":"This document contains a glossary with an alphabetical list, definitions, and terms related to API. A | B | C | E | I | F | L | M | N | O | P | R | S | T","title":"Glossary"},{"location":"overview/glossary/#a","text":"API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.). Asset Class Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.).","title":"A"},{"location":"overview/glossary/#b","text":"Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain.","title":"B"},{"location":"overview/glossary/#c","text":"Collection NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted. Continuation Continuation token from the previous response. Contract Address of the Smart Contract. Creator Address of the NFT item creator.","title":"C"},{"location":"overview/glossary/#e","text":"ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations.","title":"E"},{"location":"overview/glossary/#i","text":"Item Address of the NFT item. Id of the Item has format ${contract}:${tokenId} .","title":"I"},{"location":"overview/glossary/#f","text":"Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties.","title":"F"},{"location":"overview/glossary/#l","text":"Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer.","title":"L"},{"location":"overview/glossary/#m","text":"Make Make the side of the Order. Make - what maker (order creator) has. Maker Creator of the order. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain.","title":"M"},{"location":"overview/glossary/#n","text":"NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art.","title":"N"},{"location":"overview/glossary/#o","text":"Origin Fee Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize. Owner Address of the NFT item owner. Ownership Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format ${contract}:${tokenId}:${owner} .","title":"O"},{"location":"overview/glossary/#p","text":"Payouts Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users. Platform The platform where the order was created.","title":"P"},{"location":"overview/glossary/#r","text":"Royalties Fees that are usually paid to the creator on every sale.","title":"R"},{"location":"overview/glossary/#s","text":"Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Supply Total number of tokens minted or to be minted.","title":"S"},{"location":"overview/glossary/#t","text":"Take Take the side of the order, what order creator wants to get in return for make side. Token ID Token identifier.","title":"T"},{"location":"overview/reasons/","text":"Why build on Rarible protocol? \u00b6 Rarible pursues the goal of creating a highly liquid environment for all NFTs out there: a robust on-chain protocol designed for NFTs to exist in a connected space. A separate initiative with a dedicated team will enable direct interactions with the protocol from multiple front ends like storefronts or wallets, offering additional distribution channels and enhancing liquidity. It will also fuel the discovery of new NFT trading mechanics. NFT protocol designed by Rarible for all, owned and governed by the community. In this regard, a special place in the initiative is reserved for Rarible native governance token $RARI as the basic building block for the future NFT ecosystem. Supply and demand of the whole Rarible ecosystem \u00b6 Rarible is one of the biggest NFT marketplaces out there with over $64 million in total lifetime volume and 57k monthly protocol users, slick UX, and a variety of use cases across industries. You can utilize the shared order book with Rarible. Advanced and robust tech done for you \u00b6 Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years with wide functionality and data on all the NFTs created. Monetization \u00b6 Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations. Decentralized autonomous organization (DAO) \u00b6 Rarible is steadily moving towards becoming a fully decentralized autonomous organization. The DAO will offer multiple opportunities for creators to get funding and exposure. It will incentivize people to build on top of the protocol, and we expect the DAO to reward the early builders.","title":"Reasons for using protocol"},{"location":"overview/reasons/#why-build-on-rarible-protocol","text":"Rarible pursues the goal of creating a highly liquid environment for all NFTs out there: a robust on-chain protocol designed for NFTs to exist in a connected space. A separate initiative with a dedicated team will enable direct interactions with the protocol from multiple front ends like storefronts or wallets, offering additional distribution channels and enhancing liquidity. It will also fuel the discovery of new NFT trading mechanics. NFT protocol designed by Rarible for all, owned and governed by the community. In this regard, a special place in the initiative is reserved for Rarible native governance token $RARI as the basic building block for the future NFT ecosystem.","title":"Why build on Rarible protocol?"},{"location":"overview/reasons/#supply-and-demand-of-the-whole-rarible-ecosystem","text":"Rarible is one of the biggest NFT marketplaces out there with over $64 million in total lifetime volume and 57k monthly protocol users, slick UX, and a variety of use cases across industries. You can utilize the shared order book with Rarible.","title":"Supply and demand of the whole Rarible ecosystem"},{"location":"overview/reasons/#advanced-and-robust-tech-done-for-you","text":"Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years with wide functionality and data on all the NFTs created.","title":"Advanced and robust tech done for you"},{"location":"overview/reasons/#monetization","text":"Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.","title":"Monetization"},{"location":"overview/reasons/#decentralized-autonomous-organization-dao","text":"Rarible is steadily moving towards becoming a fully decentralized autonomous organization. The DAO will offer multiple opportunities for creators to get funding and exposure. It will incentivize people to build on top of the protocol, and we expect the DAO to reward the early builders.","title":"Decentralized autonomous organization (DAO)"},{"location":"overview/resources/","text":"Resources \u00b6 DAO \u00b6 If you're a builder or you're looking to participate to the Rarible Protocol DAO here are a few useful places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organised, and builders take their first steps towards building with the protocol. Github is where everything lives, since we are open-source, a lot of resources and help from other builders are available there. Notion is the platform where we hold information for DAO members and $RARI token holders. OpenAPI is the place where we document the current API capabilities. Submitting \u00b6 You are welcome to suggest features and report bugs found! You can do it here: Submit an issue Submit a question or suggestion Hackathon docs \u00b6 Rarible Hackathon Docs HackMD by Isaac for Ethereum network.","title":"Resources"},{"location":"overview/resources/#resources","text":"","title":"Resources"},{"location":"overview/resources/#dao","text":"If you're a builder or you're looking to participate to the Rarible Protocol DAO here are a few useful places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organised, and builders take their first steps towards building with the protocol. Github is where everything lives, since we are open-source, a lot of resources and help from other builders are available there. Notion is the platform where we hold information for DAO members and $RARI token holders. OpenAPI is the place where we document the current API capabilities.","title":"DAO"},{"location":"overview/resources/#submitting","text":"You are welcome to suggest features and report bugs found! You can do it here: Submit an issue Submit a question or suggestion","title":"Submitting"},{"location":"overview/resources/#hackathon-docs","text":"Rarible Hackathon Docs HackMD by Isaac for Ethereum network.","title":"Hackathon docs"},{"location":"overview/union-sdk/","text":"SDK Overview \u00b6 Rarible Protocol Software Development Kit enables applications to interact with Rarible protocol easily: query, issue, trade NFTs on any blockchain supported. Currently, these blockchains are supported: Ethereum (mainnet, ropsten, rinkeby) Flow (currently on devnet only) Tezos (on granada testnet) Installation \u00b6 Using SDK should be fast, easy and intuitive - that's for what we're aiming for. Below you can see an example of implementation. Install required packages using npm or yarn. For most of the projects, apart of the Rarible SDK we'll also need web3. npm install -D @rarible/sdk npm install web3 or using yarn yarn add @rarible/sdk -D yarn add web3 Create a project with the JS framework of your choice (we'll be using NextJS here) In order to properly set up the Rarible SDK we need to follow some standard web3 practices. Grab ethereum object out of the global window object Use it to create a new instance of Web3 Create new instance of EthereumWallet class Create Rarible SDK with a new instance of ethereumWallet, created in previous step In code it looks like that (using TypeScript): // Imports import Web3 from \"web3\"; import { createRaribleSdk } from \"@rarible/sdk\"; import { EthereumWallet } from \"@rarible/sdk-wallet\"; // Code const { ethereum } = window as any; const web3 = new Web3(ethereum); const ethWallet = new EthereumWallet(ethereum); const raribleSdk = createRaribleSdk(ethWallet, \"staging\"); Boomm! \ud83d\udc4a RaribleSdk object is ready for use. Few more things: If you're wondering what's \"staging\" in createRaribleSdk it's environment parameter. We have four options here: prod (mainnet) dev (ropsten) staging (rinkeby) e2e (you probably won't use this) The difference between them is the chain Id and the Rarible API endpoint. If you're creating any sort of blockchain application which will interact with users you'll still need to implement connect metamask button in order to get their wallet connected. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"SDK"},{"location":"overview/union-sdk/#sdk-overview","text":"Rarible Protocol Software Development Kit enables applications to interact with Rarible protocol easily: query, issue, trade NFTs on any blockchain supported. Currently, these blockchains are supported: Ethereum (mainnet, ropsten, rinkeby) Flow (currently on devnet only) Tezos (on granada testnet)","title":"SDK Overview"},{"location":"overview/union-sdk/#installation","text":"Using SDK should be fast, easy and intuitive - that's for what we're aiming for. Below you can see an example of implementation. Install required packages using npm or yarn. For most of the projects, apart of the Rarible SDK we'll also need web3. npm install -D @rarible/sdk npm install web3 or using yarn yarn add @rarible/sdk -D yarn add web3 Create a project with the JS framework of your choice (we'll be using NextJS here) In order to properly set up the Rarible SDK we need to follow some standard web3 practices. Grab ethereum object out of the global window object Use it to create a new instance of Web3 Create new instance of EthereumWallet class Create Rarible SDK with a new instance of ethereumWallet, created in previous step In code it looks like that (using TypeScript): // Imports import Web3 from \"web3\"; import { createRaribleSdk } from \"@rarible/sdk\"; import { EthereumWallet } from \"@rarible/sdk-wallet\"; // Code const { ethereum } = window as any; const web3 = new Web3(ethereum); const ethWallet = new EthereumWallet(ethereum); const raribleSdk = createRaribleSdk(ethWallet, \"staging\"); Boomm! \ud83d\udc4a RaribleSdk object is ready for use. Few more things: If you're wondering what's \"staging\" in createRaribleSdk it's environment parameter. We have four options here: prod (mainnet) dev (ropsten) staging (rinkeby) e2e (you probably won't use this) The difference between them is the chain Id and the Rarible API endpoint. If you're creating any sort of blockchain application which will interact with users you'll still need to implement connect metamask button in order to get their wallet connected. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Installation"},{"location":"resources/meetings/meeting-doc-15th-of-october/","text":"Meeting document for dev meeting on the 15th of October. Github \u00b6 https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've recently started also looking through github discussions, and cherry picking the ones with high priority, but for this week all github discussions are either answered or more clarification is needed. Discord \u00b6 Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. alexon#6056 Quote: \"I was just trying to do this on rinkeby but it failed for me with INCORRECT_LAZY_NFT Invalid creator and signature size. Did this ever work for you?\" Quote 2: \"It\u2019s about minting an 1155 with 2+ more creators. The signature part keeps failing because there\u2019s only one signature in the request, mine, and not from the other creators. I was just wondering how we could mint an nft with 2+ creators if only one of the creators is the one doing the mint action.\" Answer: You should include signatures for every creator (and you can include zero-length signature for the creator who is executing transaction) inartin#9707 Quote: \"Is there an API call that will return ALL types of order activities? Not a separate one but all of them at once, MINT, TRANSFER, BURN, BID, LIST, SELL (or MATCH)? The getNftOrderAllActivities does not have the Sell or MATCH type (it has in the documentation but it was a typo and will be removed from docs).... So, how do I get all activities in one API call? \" Answer: https://ethereum-api-dev.rarible.org/v0.1/doc#operation/getNftOrderAllActivities There is a SELL type chusla#6031 Quote: \"Should a minted (bought and minted not just lazy minted) nft that's been burned still be visible on rarible.com? Etherscan shows it's been burned. Do these also have to be manually deleted in lazy db? https://etherscan.io/tx/0xb496e0e664c4529020ebd4ba5d2734f0d9aa1ecf2bacaeaa499d7ee1542da5e2. Thank you! trying to come with a plan of action to clear the collection for new mints If they do need to be manually deleted can we include in list of items to be cleared this week? Thank you!\" Answer: \"If it was fully burned, it should not appear on .com\" Quote: \"Thanks Eduard we might want to test or check this if you burn an item even in rinkeby after it's been bought or minted it just goes back to the original owner. The original owner can then put it back in for sale and then it can get purchased again! Fyi screen above shows history of an item that was put back on sale AFTER being burned. I am have confirmed in rinkeby that this item can also be repurchased a second time by the buyer after it was burned.\" Andrew has also opened an issue here: https://github.com/rarible/protocol-issues/issues/135 Answer: This looks like a serious bug. Will wix it. mynamebrody#5466 Quote: \"Don't have time at the moment to write up an issue, but the production API endpoint for bidsByItem has \"valueDecimal\": null, under the make object, where in the rinkeby/ropsten version of the API return the value field as ETH instead of GWEI\" Answer: This is because prod version was not updated to the latest version. I think everything should be fine now. tgb2929#1533 Quote: \"When creating a sell order using the SDK, if we want to sell for Ether, what do we input here: \"takeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address }\" https://docs.rarible.org/sdk#create-sell-order\" Answer: you should use assetClass: \"ETH\" for this and not \"ERC20\" Quote 2: \"I'm using the SDK to create Buy orders. The issue is that almost always on the first buy attempt, the estimated gas fee is several Ether, which isn't really true. If I close and try again, then usually it's more reasonable. Anyone know how to deal with handling buy orders and showing reasonable gas fees?\" Answer: Pls, give me tx or item example or code example, what you trying to do. What amount of gas is calculated in the wallet? lazycaramel#4474 Quote: \"Hey guys, I was interested if I could use ERC1155Factory directly, or should I use SDK? Also, what's the caveat to using this vs deploying my own ERC1155? Is there some kind of lock-in with Rarible taking 2.5% on each token sale even outside of the platform?\" Answer: ERC1155Factory creates a proxy to our contract implementation, Rarible protocol will upgrade these tokens when new features are available. You can use your own version of the token contract. It's not related to 2.5% on each sale. 2.5% for each sale is taken by rarible.com website when order is created. Rhabdodon#4653 Quote: \"We've been experiencing a tremendous amount of interest and usage of cocoNFT which is amazing! Want to first thank you all for the support along the way! \u2764\ufe0f I also wanted to share the 5 biggest pieces of feedback we're getting from users that are related to the protocol. Users want to be able to burn lazy minted NFTs without paying gas fees. There is certainly confusion around this. Users also want to be able to remove lazy minted NFTs from sale without paying gas fees. Users want more sale types supported (i.e. auctions for 721 and Open for Bids for 1155s). We're on an 1155 collection so the latter would be particularly helpful. Users want to setup their Rarible profile within cocoNFT. They don't understand why they have 2 different profiles. I really think the Rarible protocol could do something cool here for the ecosystem by building a unified profile system similar to what exists on Tezos but maybe the Rarible one is cross-chain. Users want to change the price for their lazy minted NFTs (I believe this is coming soon!)\" Answer: I think we covered this on the call. We will implement feature to burn lazy minted NFTs with 2 options: 1. by just removing from the website. 2. by calling contract to invalidate signatures agamanin#2389 Quote: \"Hi. I'm new to the community, glad to be here. I have a question about the protocol smart contracts licensing. There is no LICENCE file on github. Some research indicates that it means 'forbidden for private or commercial use' (i.e. https://github.com/github/choosealicense.com/issues/196). Does it basically mean one cannot fork it, then adapt to her own needs (i.e. change the protocol fees structure, and the fee recipient address) and run her own markeplace? \ud83d\ude42 An open github issue with similar question does not make it more transparent as well Also, 77 forks (at the moment of writing) would only make sense for educational purposes in this case, right?\" Answer - Eduard: AFAIK, anyone is allowed to fork and use rarible-protocol code for their own projects and whatnot. It's open source. Quote: \"Wow, that would be just great. BTW, as far as I can understand, tools like https://one2all.io/ already do this - they let anyone set an arbitrary fee recipient and assign the fee structure. But they may have special permission of Rarible to do that, I don't know. Anyhow, having a more explicit license stating what can be done and what cannot would be beneficial for everyone.\" Answer - Eugene: Thanks, we will check if licenses are set everywhere. If you are talking about protocol-contracts repo, then MIT license should be set there. Unnatural Space#0655 Quote: \"is the rarible protocol compatible with polygon network?\" Answer - Eduard: I'd have answered that it's in the plans to be implemented soon, but Eugene, it'd be best for a more accurate answer. Answer - Eugene: It's WIP. Will be live in the end of the year, may be soonerhttps://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28 chusla#6031 Quote: \"Hi all question on sdk. My recent understanding is that the mint function automatically generates the contract token ID. But how does this work with including token id in external URI in Json metadata? Don't we need to generate token id before Json/ipfs upload and then mint? Any thoughts on this much appreciated. Seems like there may be an order of operations issue here? I've been doing some testing and think lack of token id on external URI May cause issue with opensea rendering. Previously we were able to do in two steps. Generate token id, then get ipfs content id then mint. Would be great to discuss on today's call thanks!\" Answer: We covered this on the call. Pls see https://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28","title":"Meeting doc 15th of october"},{"location":"resources/meetings/meeting-doc-15th-of-october/#github","text":"https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've recently started also looking through github discussions, and cherry picking the ones with high priority, but for this week all github discussions are either answered or more clarification is needed.","title":"Github"},{"location":"resources/meetings/meeting-doc-15th-of-october/#discord","text":"Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. alexon#6056 Quote: \"I was just trying to do this on rinkeby but it failed for me with INCORRECT_LAZY_NFT Invalid creator and signature size. Did this ever work for you?\" Quote 2: \"It\u2019s about minting an 1155 with 2+ more creators. The signature part keeps failing because there\u2019s only one signature in the request, mine, and not from the other creators. I was just wondering how we could mint an nft with 2+ creators if only one of the creators is the one doing the mint action.\" Answer: You should include signatures for every creator (and you can include zero-length signature for the creator who is executing transaction) inartin#9707 Quote: \"Is there an API call that will return ALL types of order activities? Not a separate one but all of them at once, MINT, TRANSFER, BURN, BID, LIST, SELL (or MATCH)? The getNftOrderAllActivities does not have the Sell or MATCH type (it has in the documentation but it was a typo and will be removed from docs).... So, how do I get all activities in one API call? \" Answer: https://ethereum-api-dev.rarible.org/v0.1/doc#operation/getNftOrderAllActivities There is a SELL type chusla#6031 Quote: \"Should a minted (bought and minted not just lazy minted) nft that's been burned still be visible on rarible.com? Etherscan shows it's been burned. Do these also have to be manually deleted in lazy db? https://etherscan.io/tx/0xb496e0e664c4529020ebd4ba5d2734f0d9aa1ecf2bacaeaa499d7ee1542da5e2. Thank you! trying to come with a plan of action to clear the collection for new mints If they do need to be manually deleted can we include in list of items to be cleared this week? Thank you!\" Answer: \"If it was fully burned, it should not appear on .com\" Quote: \"Thanks Eduard we might want to test or check this if you burn an item even in rinkeby after it's been bought or minted it just goes back to the original owner. The original owner can then put it back in for sale and then it can get purchased again! Fyi screen above shows history of an item that was put back on sale AFTER being burned. I am have confirmed in rinkeby that this item can also be repurchased a second time by the buyer after it was burned.\" Andrew has also opened an issue here: https://github.com/rarible/protocol-issues/issues/135 Answer: This looks like a serious bug. Will wix it. mynamebrody#5466 Quote: \"Don't have time at the moment to write up an issue, but the production API endpoint for bidsByItem has \"valueDecimal\": null, under the make object, where in the rinkeby/ropsten version of the API return the value field as ETH instead of GWEI\" Answer: This is because prod version was not updated to the latest version. I think everything should be fine now. tgb2929#1533 Quote: \"When creating a sell order using the SDK, if we want to sell for Ether, what do we input here: \"takeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address }\" https://docs.rarible.org/sdk#create-sell-order\" Answer: you should use assetClass: \"ETH\" for this and not \"ERC20\" Quote 2: \"I'm using the SDK to create Buy orders. The issue is that almost always on the first buy attempt, the estimated gas fee is several Ether, which isn't really true. If I close and try again, then usually it's more reasonable. Anyone know how to deal with handling buy orders and showing reasonable gas fees?\" Answer: Pls, give me tx or item example or code example, what you trying to do. What amount of gas is calculated in the wallet? lazycaramel#4474 Quote: \"Hey guys, I was interested if I could use ERC1155Factory directly, or should I use SDK? Also, what's the caveat to using this vs deploying my own ERC1155? Is there some kind of lock-in with Rarible taking 2.5% on each token sale even outside of the platform?\" Answer: ERC1155Factory creates a proxy to our contract implementation, Rarible protocol will upgrade these tokens when new features are available. You can use your own version of the token contract. It's not related to 2.5% on each sale. 2.5% for each sale is taken by rarible.com website when order is created. Rhabdodon#4653 Quote: \"We've been experiencing a tremendous amount of interest and usage of cocoNFT which is amazing! Want to first thank you all for the support along the way! \u2764\ufe0f I also wanted to share the 5 biggest pieces of feedback we're getting from users that are related to the protocol. Users want to be able to burn lazy minted NFTs without paying gas fees. There is certainly confusion around this. Users also want to be able to remove lazy minted NFTs from sale without paying gas fees. Users want more sale types supported (i.e. auctions for 721 and Open for Bids for 1155s). We're on an 1155 collection so the latter would be particularly helpful. Users want to setup their Rarible profile within cocoNFT. They don't understand why they have 2 different profiles. I really think the Rarible protocol could do something cool here for the ecosystem by building a unified profile system similar to what exists on Tezos but maybe the Rarible one is cross-chain. Users want to change the price for their lazy minted NFTs (I believe this is coming soon!)\" Answer: I think we covered this on the call. We will implement feature to burn lazy minted NFTs with 2 options: 1. by just removing from the website. 2. by calling contract to invalidate signatures agamanin#2389 Quote: \"Hi. I'm new to the community, glad to be here. I have a question about the protocol smart contracts licensing. There is no LICENCE file on github. Some research indicates that it means 'forbidden for private or commercial use' (i.e. https://github.com/github/choosealicense.com/issues/196). Does it basically mean one cannot fork it, then adapt to her own needs (i.e. change the protocol fees structure, and the fee recipient address) and run her own markeplace? \ud83d\ude42 An open github issue with similar question does not make it more transparent as well Also, 77 forks (at the moment of writing) would only make sense for educational purposes in this case, right?\" Answer - Eduard: AFAIK, anyone is allowed to fork and use rarible-protocol code for their own projects and whatnot. It's open source. Quote: \"Wow, that would be just great. BTW, as far as I can understand, tools like https://one2all.io/ already do this - they let anyone set an arbitrary fee recipient and assign the fee structure. But they may have special permission of Rarible to do that, I don't know. Anyhow, having a more explicit license stating what can be done and what cannot would be beneficial for everyone.\" Answer - Eugene: Thanks, we will check if licenses are set everywhere. If you are talking about protocol-contracts repo, then MIT license should be set there. Unnatural Space#0655 Quote: \"is the rarible protocol compatible with polygon network?\" Answer - Eduard: I'd have answered that it's in the plans to be implemented soon, but Eugene, it'd be best for a more accurate answer. Answer - Eugene: It's WIP. Will be live in the end of the year, may be soonerhttps://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28 chusla#6031 Quote: \"Hi all question on sdk. My recent understanding is that the mint function automatically generates the contract token ID. But how does this work with including token id in external URI in Json metadata? Don't we need to generate token id before Json/ipfs upload and then mint? Any thoughts on this much appreciated. Seems like there may be an order of operations issue here? I've been doing some testing and think lack of token id on external URI May cause issue with opensea rendering. Previously we were able to do in two steps. Generate token id, then get ipfs content id then mint. Would be great to discuss on today's call thanks!\" Answer: We covered this on the call. Pls see https://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28","title":"Discord"},{"location":"resources/meetings/meeting-doc-22nd-of-october/","text":"Meeting document for dev meeting on the 22nd of October. Github \u00b6 None. There are two \"unanswered\" questions that on which we're waiting on a reply from the question owner. Discord \u00b6 Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. owenmurovec#8687 Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\", \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\", \"status\": 400 } According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type. Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\" richexplorer.eth#8225 Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done data: { } code: 'VALIDATION', message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address', status: 400 Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\" fruitybits#4442 Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\"","title":"Meeting doc 22nd of october"},{"location":"resources/meetings/meeting-doc-22nd-of-october/#github","text":"None. There are two \"unanswered\" questions that on which we're waiting on a reply from the question owner.","title":"Github"},{"location":"resources/meetings/meeting-doc-22nd-of-october/#discord","text":"Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. owenmurovec#8687 Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\", \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\", \"status\": 400 } According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type. Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\" richexplorer.eth#8225 Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done data: { } code: 'VALIDATION', message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address', status: 400 Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\" fruitybits#4442 Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\"","title":"Discord"},{"location":"resources/meetings/meeting-doc-29th-of-october/","text":"Meeting document for dev meeting on the 29th of October. Github discussions: https://github.com/rarible/protocol/discussions/142 whitespace#2877 Answer: Eugene to look into it later. Meeting is too short to review there. https://github.com/rarible/protocol/discussions/11 - related to spam NFT's being minted to someone's collection Answer: We already have discussed about this. There is now a contract where only the owner can mint. We will have the possibility to deploy private contracts via the SDK, adding the feature is in our backlog. The release can be expected Monday / Tuesday next week (first week of November) Any collection that has already been released won't be able to benefit from this. Github issues: Most important: https://github.com/rarible/protocol/issues/148 owenmurovec#8687 Answer: We already fixed this in our contract. There is a PR waiting to be merged, will probably be done by Monday / Tuesday next week (first week of November) https://github.com/rarible/protocol/issues/147 Jaacob#1962 and Branko#7207 Answer: Need a TXID / Hash github issue was updated https://github.com/rarible/protocol/issues/143 tgb29#1533 Answer: Metamask should say that there is an exception in the transaction, but that isn't shown correctly. We have raised this issue to the metamask team. https://github.com/rarible/protocol-ethereum-sdk/issues/52 from inartin#9707 Answer: Need to check at another time / Please DM Eugene on TG Discord: chusla#6031 Quote: \"could we get an update on latest browser compatible sdk as well that would be much appreciated if there is any way at all to include that in next week's release for tezos etc that would unblock us thanks!\" Answer: We've got a PR open for the browser compatible SDK, we will try to move it to review within the next week. mynamebrody#5466 Quote: \"I think I'm having issues with the encodeOrder endpoint as it wants a signature but that's not required for this call yet so I haven't been including it. But adding the field with an empty value gets past this error, however, I don't think it should be there\" Answer: Will check. platocrat#4224 Quote: \"@Matt a friend just sent me this, which comes from your documentation. Is this correct? We should just fork Rarible Protocol, deploy the protocol to Polygon, then use those contracts to deploy our ERC1155 contracts?\" Just to clarify, i wish to use Rarible's contracts, which i assume to be on, Polygon to deploy our contracts \ud83d\ude42 Answer: I believe that is correct, to deploy contracts you can fork/clone the repo. What's needed to be done is to put the configuration for Polygon and deploy it to this network. But that's not everything. Rarible Protocol is not only about contracts, is about indexer and sdk as well. We have already deployed our indexer on polygon testnets but with SDK this is a bit harder because we would like to use meta transactions which means we would need to change our SDK to support these meta transactions. These are these main tasks we need to get done in order to use Polygon. We'll try it after we deploy on Tezos and Flow. Might try initial testing next week. Would be better to wait imo. idan.angel#8635 Quote: \"Hi All, I'm looking for a Rarible API that would return the assetType for any NFT listed on the marketplace. In other words, I'm looking for something like: GET ?itemId= : and I expect to get an answer that would contain a field with ERC721 or ERC1155 or Lazy_mint, something of that sort, so that I can use that value to create a new buy order. I haven't found anything of that sort. For some NFTs there are open orders which hold the assetType, but I'm looking for a standard way that would work on every NFT on Rarible, not just NFTs with open or past orders. Any help would be appreciated.\" Answer: If SDK is used, that's not needed. They just need to get an order and execute field in the SDK and the inverted order will be automatically made. If any further help is needed contact owenmurovec#8687 Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\", \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\", \"status\": 400 } According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type. Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\" Answer: creating-a-sell-order in the docs is a bit outdated, we'll fix that. Also. encodeOrder is deprecated, it's better to use SDK. Rarible docs now have a blockchain agnostic structure that isn't tied to Ethereum, there is information on how to use the SDK there. richexplorer.eth#8225 Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done data: { } code: 'VALIDATION', message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address', status: 400 Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\" Answer: Same as the answer above, please use SDK. fruitybits#4442 Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\" Answer: Royalties V1 or V2 will do. Any version will be working on Polygon without a problem once we deploy there.","title":"Meeting doc 29th of october"},{"location":"resources/meetings/meeting-doc-5th-of-november/","text":"Meeting document for dev meeting on the 5th of November. Update on the 12k$ contract upgrade. When are we going to deploy that fix now that the gas fees seem to have lowered down? Update on Flow. Are we still on track to deploy between 8th and the 12nd of November? Update on the bidding function. The bid function doesn't seem to be fully supported by the SDK. What is the situation with that? (Question is related to alexon#6056 's question below) Github \u00b6 https://github.com/rarible/protocol/issues/140 - > When will the error message / html status be changed? https://github.com/rarible/protocol/issues/133 - > Has this been fixed? If not, what is an ETA for a fix. https://github.com/rarible/protocol/issues/120 - > Have we found a way to implement this? https://github.com/rarible/protocol/issues/152 - > https://github.com/rarible/protocol/issues/151 - > https://github.com/rarible/protocol-ethereum-sdk/issues/52 - > Discord \u00b6 Nick - Ownerfy#8137 Quote: \"simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\" Answer: Zoomer#5825 Quote: \"Hi frens. I'm trying to parse Rarible trades on Ethereum. I see here in the exchange contract's events that the events with topic0 as 0x268820db288a211986b26a8fda86b1e0046281b21206936bb0e61c67b5c79ef4 have all useful info in the arguments But the event with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e does not seem to contain the address of the traded NFT What is the difference between these two events? And is there any simple way for me to get the contract address of the NFT being traded in the transaction with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e? (Here's a link of what I'm looking at https://etherscan.io/address/0x9757F2d2b135150BBeb65308D4a91804107cd8D6#events)\" Answer: alexon#6056 Quote: \"are you guys migrating to a new sdk? Just saw the docs link to a new repo. I ask because I just created a bid with the procotol-ethereum-sdk and I used ETH as the make asset. The issue I'm seeing is that it's not coming back in the bids api from https://api-staging.rarible.com/protocol/v0.1/ethereum/order/bids/byItem. I made a bit through rarible and that one does show up. Actually, I noticed it's just because it's marked as INACTIVE. Is there a reason why it's that way? I know rarible makes you convert eth to weth first to place a bid. But there is no exaplanation on how to do that in the docs. \" Answer: rimb05#3257 Quote: \"When will the 721 lazy minting minimal version be deployed?\" Answer:","title":"Meeting doc 5th of november"},{"location":"resources/meetings/meeting-doc-5th-of-november/#github","text":"https://github.com/rarible/protocol/issues/140 - > When will the error message / html status be changed? https://github.com/rarible/protocol/issues/133 - > Has this been fixed? If not, what is an ETA for a fix. https://github.com/rarible/protocol/issues/120 - > Have we found a way to implement this? https://github.com/rarible/protocol/issues/152 - > https://github.com/rarible/protocol/issues/151 - > https://github.com/rarible/protocol-ethereum-sdk/issues/52 - >","title":"Github"},{"location":"resources/meetings/meeting-doc-5th-of-november/#discord","text":"Nick - Ownerfy#8137 Quote: \"simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\" Answer: Zoomer#5825 Quote: \"Hi frens. I'm trying to parse Rarible trades on Ethereum. I see here in the exchange contract's events that the events with topic0 as 0x268820db288a211986b26a8fda86b1e0046281b21206936bb0e61c67b5c79ef4 have all useful info in the arguments But the event with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e does not seem to contain the address of the traded NFT What is the difference between these two events? And is there any simple way for me to get the contract address of the NFT being traded in the transaction with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e? (Here's a link of what I'm looking at https://etherscan.io/address/0x9757F2d2b135150BBeb65308D4a91804107cd8D6#events)\" Answer: alexon#6056 Quote: \"are you guys migrating to a new sdk? Just saw the docs link to a new repo. I ask because I just created a bid with the procotol-ethereum-sdk and I used ETH as the make asset. The issue I'm seeing is that it's not coming back in the bids api from https://api-staging.rarible.com/protocol/v0.1/ethereum/order/bids/byItem. I made a bit through rarible and that one does show up. Actually, I noticed it's just because it's marked as INACTIVE. Is there a reason why it's that way? I know rarible makes you convert eth to weth first to place a bid. But there is no exaplanation on how to do that in the docs. \" Answer: rimb05#3257 Quote: \"When will the 721 lazy minting minimal version be deployed?\" Answer:","title":"Discord"},{"location":"resources/meetings/meeting-doc-8th-of-october/","text":"Meeting document for dev meeting on the 8th of October. Addresing the https://api-staging.rarible.com/ to https://ethereum-api.rarible.org/ replacement in the docs. \u00b6 There are 4 instances where api-staging is used in the docs. 1. https://docs.rarible.org/example-projects/picnic#api-calls 2. https://docs.rarible.org/exchange/order-discovery#search-orders 3. https://docs.rarible.org/exchange/creating-a-sell-order#creating-an-order 4. https://docs.rarible.org/asset/creating-an-asset#erc1155-lazy-minting Github \u00b6 https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've realised that discussions that are not in the Q&A section won't get indexed in the link above so I've changed the section for a few of them, that's the reason there might be some older questions in there. Discord \u00b6 All members who have a question listed below have been invited to participate in this call All members will be notified about the answer to their question privately or in #dev-general (discord) Only the past 7 days of unanswered questions are indexed here. Konstantin#3916 Quote: \"The question for lazy mint. Can I mint nft myself from order? For example, I will hit any sales order with a lazy mint, and I just do mint nft. Will the excenge method be able to make a new duplicate nft since the order remains?\" Answer: No, if it was minted, then no more NFT's will be minted. It's controlled by the smart contract. So if we're talking about ERC721 of course not because they're unique. If we're talking about ERC1155 no, the total supply of the token is controlled by the smart contract so if there's a message saying only 5 will be minted, no more will be minted. Rhabdodon#4653 Quote: \"Thanks! Would love an update on how we're addressing this on the protocol. I believe @Eugene Nacu | Rarible has an idea for how we can address this but needs someone to work on it.\" \"this\" meant: \"Regarding the opensea bug it's caused by the function in the lazy minting contract that does the minting transfer as it was originally calling the function doing the minting at the Blackhole address and then doing the transfer to the OpenSea address. The fix requires minting, sending to the creator of the lazy minter address and then to the buyer vs minting and sending from the blackHole address.\" \"@Eugene Nacu | Rarible do you think a fix to the OpenSea issue would be completed and shipped by the end of the week?\" Answer: Skipped -- alexon#6056 Quote: \"Is there a way to use the protocol-ethereum-sdk in node without having to pass a web3 instance (since I don't need it)\" \"I just tried it by configuring a web3 instance in node, but I'm getting FormData is not defined. So I'm guessing the sdk is not meant to be used in node then?\" Answer: It can be used in node, look in tests, here's a walkaround. Link with example: https://github.com/rarible/protocol-ethereum-sdk/blob/master/packages/protocol-ethereum-sdk/jest.setup.js Laviniao#9840 Quote: \"Hi, does anyone in this chat know when L2 will be available on rarible?\" \"Also, will generative art projects be able to be minted on platforms built on the protocol, in reglf to the smart contract element?\" Answer: If you consider polygon to be L2, the exact implementation date is not known, but we'll start looking into it in the first week of November. Peter Watts#5307 Quote: \"Hi. Is there a delay when adding Royalties to existing external contract? I followed the steps here (https://docs.rarible.org/asset/royalties-on-a-external-collection) and tx is here (https://etherscan.io/tx/0xb5f625595fed64d629818401b61342d1f0443867fa866fe588d442f36804f834) but it doesn't show up when selling on Rarible, nor when querying the API (https://api.rarible.com/protocol/v0.1/ethereum/nft/items/0x819327e005a3ed85f7b634e195b8f25d4a2a45f8:35739319466029867409935893104794648465119721019613204601875682368845852747852?includeMeta=true)\" Answer: Add to github issues. AzFlin#5259 Quote: \"hey, can we not post a fixed price auction on rarible UI with an expiration date?\" Answer: Not yet. It will be available soon (almost implemented). When you create a sell/bid order you will be able to set an end date for the order. It almost works, soon will be on rarible.com as well. Will prioritise this task. Alexandr Devyatkin#4906 Quote: \"Hi! Having trouble with local publishing scala-rpc. While using sbt publishM2 i receive this error: unable to locate a valid GitHub token from GitConfig(token). Which token could be used in that case? Thanks in advance. Link to repo: https://github.com/rarible/scala-rpc\" Answer: This matter was already discussed between Eugene and Alexandr. bold#5220 Quote: \"Hey devs, many of these NFT projects (BAYC, Cool Cats, Pudgy Penguins, etc.) don't have the Rarible Royalties contracts built in. So do they just not receive royalties if traded on Rarible Marketplace, or does Rarible set up some kind of proxy contracts to account for royalties for them?\" \"@Eugene Nacu | Rarible just want to confirm that going forward with a custom contract, I'd only have to include the EIP-2981 standard and not the overall RaribleRoyalties contracts found on Rarible's github, right?\" Answer: Rarible exchange contract uses royalty registry. For some time there is a feature on rarible.com to update royalties for a specific collection, so creators of the collection can override and set custom royalties for their collections. Also if for example artblocks doesn't implement rarible royalties, but we implement this proxy contract to convert the royalties to our format and registered it, it works. Anyone from these contracts can register and override royalties on rarible. Answer for the EIP-2981 question: Currently it's not the case so exchange contract doesn't follow this standard but it will. This issue will be solved after we finish the auction contract. nullren#4914 Quote: \"for properties on an nft detail page, does rarible use the same metadata attributes as opensea? or does it use the enjin properties? ie following or does rarible have it's own version of this https://docs.opensea.io/docs/metadata-standards\" Answer: It's the same as opensea, so not like our own standard, we pretty much follow what opensea does. NiFTiChristian#7535 Quote: \"I'm using the ethereum sdk to create an order, but I get a 404: https://ethereum-api-staging.rarible.org/v0.1/nft/items/0x03c592e5f277C37A3e8dEE74f743a7972e5BF51B%3A1/lazy 404 has anyone experienced this while using the SDK?\" Answer: Add to github issues.","title":"Meeting doc 8th of october"},{"location":"resources/meetings/meeting-doc-8th-of-october/#addresing-the-httpsapi-stagingrariblecom-to-httpsethereum-apiraribleorg-replacement-in-the-docs","text":"There are 4 instances where api-staging is used in the docs. 1. https://docs.rarible.org/example-projects/picnic#api-calls 2. https://docs.rarible.org/exchange/order-discovery#search-orders 3. https://docs.rarible.org/exchange/creating-a-sell-order#creating-an-order 4. https://docs.rarible.org/asset/creating-an-asset#erc1155-lazy-minting","title":"Addresing the https://api-staging.rarible.com/ to https://ethereum-api.rarible.org/ replacement in the docs."},{"location":"resources/meetings/meeting-doc-8th-of-october/#github","text":"https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've realised that discussions that are not in the Q&A section won't get indexed in the link above so I've changed the section for a few of them, that's the reason there might be some older questions in there.","title":"Github"},{"location":"resources/meetings/meeting-doc-8th-of-october/#discord","text":"All members who have a question listed below have been invited to participate in this call All members will be notified about the answer to their question privately or in #dev-general (discord) Only the past 7 days of unanswered questions are indexed here. Konstantin#3916 Quote: \"The question for lazy mint. Can I mint nft myself from order? For example, I will hit any sales order with a lazy mint, and I just do mint nft. Will the excenge method be able to make a new duplicate nft since the order remains?\" Answer: No, if it was minted, then no more NFT's will be minted. It's controlled by the smart contract. So if we're talking about ERC721 of course not because they're unique. If we're talking about ERC1155 no, the total supply of the token is controlled by the smart contract so if there's a message saying only 5 will be minted, no more will be minted. Rhabdodon#4653 Quote: \"Thanks! Would love an update on how we're addressing this on the protocol. I believe @Eugene Nacu | Rarible has an idea for how we can address this but needs someone to work on it.\" \"this\" meant: \"Regarding the opensea bug it's caused by the function in the lazy minting contract that does the minting transfer as it was originally calling the function doing the minting at the Blackhole address and then doing the transfer to the OpenSea address. The fix requires minting, sending to the creator of the lazy minter address and then to the buyer vs minting and sending from the blackHole address.\" \"@Eugene Nacu | Rarible do you think a fix to the OpenSea issue would be completed and shipped by the end of the week?\" Answer: Skipped -- alexon#6056 Quote: \"Is there a way to use the protocol-ethereum-sdk in node without having to pass a web3 instance (since I don't need it)\" \"I just tried it by configuring a web3 instance in node, but I'm getting FormData is not defined. So I'm guessing the sdk is not meant to be used in node then?\" Answer: It can be used in node, look in tests, here's a walkaround. Link with example: https://github.com/rarible/protocol-ethereum-sdk/blob/master/packages/protocol-ethereum-sdk/jest.setup.js Laviniao#9840 Quote: \"Hi, does anyone in this chat know when L2 will be available on rarible?\" \"Also, will generative art projects be able to be minted on platforms built on the protocol, in reglf to the smart contract element?\" Answer: If you consider polygon to be L2, the exact implementation date is not known, but we'll start looking into it in the first week of November. Peter Watts#5307 Quote: \"Hi. Is there a delay when adding Royalties to existing external contract? I followed the steps here (https://docs.rarible.org/asset/royalties-on-a-external-collection) and tx is here (https://etherscan.io/tx/0xb5f625595fed64d629818401b61342d1f0443867fa866fe588d442f36804f834) but it doesn't show up when selling on Rarible, nor when querying the API (https://api.rarible.com/protocol/v0.1/ethereum/nft/items/0x819327e005a3ed85f7b634e195b8f25d4a2a45f8:35739319466029867409935893104794648465119721019613204601875682368845852747852?includeMeta=true)\" Answer: Add to github issues. AzFlin#5259 Quote: \"hey, can we not post a fixed price auction on rarible UI with an expiration date?\" Answer: Not yet. It will be available soon (almost implemented). When you create a sell/bid order you will be able to set an end date for the order. It almost works, soon will be on rarible.com as well. Will prioritise this task. Alexandr Devyatkin#4906 Quote: \"Hi! Having trouble with local publishing scala-rpc. While using sbt publishM2 i receive this error: unable to locate a valid GitHub token from GitConfig(token). Which token could be used in that case? Thanks in advance. Link to repo: https://github.com/rarible/scala-rpc\" Answer: This matter was already discussed between Eugene and Alexandr. bold#5220 Quote: \"Hey devs, many of these NFT projects (BAYC, Cool Cats, Pudgy Penguins, etc.) don't have the Rarible Royalties contracts built in. So do they just not receive royalties if traded on Rarible Marketplace, or does Rarible set up some kind of proxy contracts to account for royalties for them?\" \"@Eugene Nacu | Rarible just want to confirm that going forward with a custom contract, I'd only have to include the EIP-2981 standard and not the overall RaribleRoyalties contracts found on Rarible's github, right?\" Answer: Rarible exchange contract uses royalty registry. For some time there is a feature on rarible.com to update royalties for a specific collection, so creators of the collection can override and set custom royalties for their collections. Also if for example artblocks doesn't implement rarible royalties, but we implement this proxy contract to convert the royalties to our format and registered it, it works. Anyone from these contracts can register and override royalties on rarible. Answer for the EIP-2981 question: Currently it's not the case so exchange contract doesn't follow this standard but it will. This issue will be solved after we finish the auction contract. nullren#4914 Quote: \"for properties on an nft detail page, does rarible use the same metadata attributes as opensea? or does it use the enjin properties? ie following or does rarible have it's own version of this https://docs.opensea.io/docs/metadata-standards\" Answer: It's the same as opensea, so not like our own standard, we pretty much follow what opensea does. NiFTiChristian#7535 Quote: \"I'm using the ethereum sdk to create an order, but I get a 404: https://ethereum-api-staging.rarible.org/v0.1/nft/items/0x03c592e5f277C37A3e8dEE74f743a7972e5BF51B%3A1/lazy 404 has anyone experienced this while using the SDK?\" Answer: Add to github issues.","title":"Discord"},{"location":"tezos/tezos-overview/","text":"Tezos overview \u00b6 This is a work in progress, aiming to release before the end of November. Support for the Tezos was built by Tezos team: backend and SDK was built by Functori Edukera and Nomadic Labs managed the smart contracts Source code is available here: https://gitlab.com/tezos-paris-hub/rarible/rarible-backend/","title":"Tezos overview"},{"location":"tezos/tezos-overview/#tezos-overview","text":"This is a work in progress, aiming to release before the end of November. Support for the Tezos was built by Tezos team: backend and SDK was built by Functori Edukera and Nomadic Labs managed the smart contracts Source code is available here: https://gitlab.com/tezos-paris-hub/rarible/rarible-backend/","title":"Tezos overview"},{"location":"use-cases/bubblesdk/","text":"Rarible SDK No-Code plugin \u00b6 This plugin has been developed by EzCode . You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io . Link to the plugin Link to documentation Examples on using the plugin All examples are open source, you can see how it works from the inside. API supported features: \u00b6 Get Item Metadata Get Item Data Get Orders By Wallet Get Order By Hash Get NFT Ownership Get NFT Order Activities Get Order Activities By Item Get All NFT Items By Owner, Creator, Collection SDK supported features: \u00b6 ERC721 and ERC1155 supported Mint Lazy Mint (Buyer pays the fee) Custom Royalties Custom Origin Fees Create Order (Sell, Bid) Buy item Accept Bid Transfer an NFT to other wallet Cancel Order Burn For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here . How to use: \u00b6 Instructions Place the element Rarible SDK on the page Make sure it is visible (not in a popup or a hidden group) Select the network in the plugin element field \"Environment\" Ready to go? We are working on documentation and more demo pages. NFT Marketplaces being built with this plugin: - one2all","title":"EZCode SDK plugin"},{"location":"use-cases/bubblesdk/#rarible-sdk-no-code-plugin","text":"This plugin has been developed by EzCode . You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io . Link to the plugin Link to documentation Examples on using the plugin All examples are open source, you can see how it works from the inside.","title":"Rarible SDK No-Code plugin"},{"location":"use-cases/bubblesdk/#api-supported-features","text":"Get Item Metadata Get Item Data Get Orders By Wallet Get Order By Hash Get NFT Ownership Get NFT Order Activities Get Order Activities By Item Get All NFT Items By Owner, Creator, Collection","title":"API supported features:"},{"location":"use-cases/bubblesdk/#sdk-supported-features","text":"ERC721 and ERC1155 supported Mint Lazy Mint (Buyer pays the fee) Custom Royalties Custom Origin Fees Create Order (Sell, Bid) Buy item Accept Bid Transfer an NFT to other wallet Cancel Order Burn For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here .","title":"SDK supported features:"},{"location":"use-cases/bubblesdk/#how-to-use","text":"Instructions Place the element Rarible SDK on the page Make sure it is visible (not in a popup or a hidden group) Select the network in the plugin element field \"Environment\" Ready to go? We are working on documentation and more demo pages. NFT Marketplaces being built with this plugin: - one2all","title":"How to use:"},{"location":"use-cases/coconft/","text":"cocoNFT \u00b6 TLDR: cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How cocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process. In regards to the database side cocoNFT advises understanding how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for cocoNFT.","title":"cocoNFT"},{"location":"use-cases/coconft/#coconft","text":"TLDR: cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How cocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process. In regards to the database side cocoNFT advises understanding how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for cocoNFT.","title":"cocoNFT"},{"location":"use-cases/mintgate/","text":"MintGate \u00b6 TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"use-cases/mintgate/#mintgate","text":"TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"use-cases/picnic/","text":"Picnic \u00b6 We use Rarible to help us identify NFTs from creators and collectors in the [Picnic] showcase. The [Rarible API] provides a few great endpoints for fetching the necessary data. API Calls \u00b6 The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org Getting Tokens by Owner \u00b6 Paginate through owned tokens import axios from 'axios'; /* * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return / const fetchOwnedTokens = async (owner, opts = {}) => { const { continuation, size = 100 } = opts; try { const result = await axios.get('https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner', { params: { owner, continuation }, }); const { data } = result; // Paginate results let hist = []; if (data.continuation && data.items.length === size) { hist = await getOwnedTokens(owner, { ...opts, continuation: data.continuation }); } // Return full history return [...data.items, ...hist]; } catch (err) { console.error(err); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios'; /* * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} / const fetchTokenMetadata = async id => { const { data } = await axios.get( https://api.rarible.com/protocol/v0.1/ethereum/nft/items/${id}/meta ); if (!data?.name) { throw new Error('Invalid NFT data', { id, data }); } return data; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Picnic"},{"location":"use-cases/picnic/#picnic","text":"We use Rarible to help us identify NFTs from creators and collectors in the [Picnic] showcase. The [Rarible API] provides a few great endpoints for fetching the necessary data.","title":"Picnic"},{"location":"use-cases/picnic/#api-calls","text":"The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org","title":"API Calls"},{"location":"use-cases/picnic/#getting-tokens-by-owner","text":"Paginate through owned tokens import axios from 'axios'; /* * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return / const fetchOwnedTokens = async (owner, opts = {}) => { const { continuation, size = 100 } = opts; try { const result = await axios.get('https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner', { params: { owner, continuation }, }); const { data } = result; // Paginate results let hist = []; if (data.continuation && data.items.length === size) { hist = await getOwnedTokens(owner, { ...opts, continuation: data.continuation }); } // Return full history return [...data.items, ...hist]; } catch (err) { console.error(err); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios'; /* * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} / const fetchTokenMetadata = async id => { const { data } = await axios.get( https://api.rarible.com/protocol/v0.1/ethereum/nft/items/${id}/meta ); if (!data?.name) { throw new Error('Invalid NFT data', { id, data }); } return data; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Getting Tokens by Owner"},{"location":"use-cases/royalties-on-a-external-collection/","text":"Setting Up Royalties on an External Collection \u00b6 Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract Active Contract tab. Make sure Write as Proxy is selected near the top. Click Connect to Web3 . Expand the setRoyaltiesByToken function to set the royalties for the entire collection. You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below. The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. The maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection ( 0x4008c2482357632b06526b492c143f4e73ff1b0d ) the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) receives 2.5% (250) Royalties. Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection. Below is an example of a purchase transaction with annotations on what each fee is for:","title":"Setting Up Royalties on an External Collection"},{"location":"use-cases/royalties-on-a-external-collection/#setting-up-royalties-on-an-external-collection","text":"Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract Active Contract tab. Make sure Write as Proxy is selected near the top. Click Connect to Web3 . Expand the setRoyaltiesByToken function to set the royalties for the entire collection. You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below. The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. The maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection ( 0x4008c2482357632b06526b492c143f4e73ff1b0d ) the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) receives 2.5% (250) Royalties. Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection. Below is an example of a purchase transaction with annotations on what each fee is for:","title":"Setting Up Royalties on an External Collection"}]}