{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+","tags":false},"docs":[{"location":"","text":"<p>Rarible Protocol is a tool to query, issue and trade NFTs on these blockchains:</p> <ul> <li>Ethereum </li> <li>Flow (WIP)</li> <li>Tezos</li> <li>Polygon (WIP, coming soon)</li> <li>Other blockchains (tell us what blockchain you want)</li> </ul>","title":"Rarible Protocol Overview"},{"location":"#getting-started","text":"<ul> <li>Install and start to use Protocol SDK</li> <li>Use Protocol API</li> </ul> <p>Look at Example App for a quick start.</p>","title":"Getting Started"},{"location":"#protocol-features","text":"<ul> <li>query information about NFTs </li> <li>mint (issue, create) NFTs</li> <li>trade NFTs (sell, bid, auction)</li> <li>transfer</li> <li>burn </li> </ul>","title":"Protocol Features"},{"location":"#architecture","text":"<p>The architecture of the Protocol:</p> <p></p> <p>Protocol is based on the blockchain layer (smart contracts written for every blockchain supported). These smart contracts allow users to mint and exchange tokens.</p> <p>On top of the contracts we built indexers to index part of the blockchain state. This gives us the possibility to query data about NFTs.</p> <p>Then, SDKs were written to interact with smart contracts. </p> <p>All these components are written for every blockchain supported and are used in Union service and Union SDK</p> <p>Applications need to integrate Union service and Union SDK to be able to interact with all blockchains in the same way.</p>","title":"Architecture"},{"location":"#suggestions","text":"<p>You are welcome to suggest features and report bugs found!</p>","title":"Suggestions"},{"location":"#audits","text":"<p>Rarible Protocol is audited. Check this report by ChainSecurity.com.</p>","title":"Audits"},{"location":"#license","text":"<p>Rarible Protocol is available under GPL v3.</p> <p>SDK and openapi (with generated clients) are available under MIT.</p>","title":"License"},{"location":"ethereum/contract-addresses/","text":"<p>Here you can find Rarible Smart Contracts deployed instances across Ethereum Ropsten Testnet, Rinkeby Testnet and Mainnet.</p>","title":"Contract Addresses"},{"location":"ethereum/contract-addresses/#mainnet","text":"<ul> <li>Asset Contract ERC721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C\u2197</li> <li>Asset Contract ERC1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 \u2197</li> <li>Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 \u2197</li> <li>External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD \u2197</li> <li>ERC721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 \u2197</li> <li>ERC1155 Token Factory 0x81243681078bEE8e251D02Ee6872b1EAa6DD982A \u2197</li> </ul>","title":"Mainnet"},{"location":"ethereum/contract-addresses/#rinkeby","text":"<p>Is known to usually be more reliable than Ropsten.</p> <ul> <li>Asset Contract ERC721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\u2197</li> <li>Asset Contract ERC1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 \u2197</li> <li>Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b \u2197</li> <li>External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 \u2197</li> <li>NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 \u2197</li> <li>ERC721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf \u2197</li> <li>ERC1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d \u2197</li> </ul>","title":"Rinkeby"},{"location":"ethereum/contract-addresses/#ropsten","text":"<p>Is known to be less reliable.</p> <ul> <li>Asset Contract ERC721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\u2197</li> <li>Asset Contract ERC1155 0x6a94aC200342AC823F909F142a65232E2f052183 \u2197</li> <li>Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD \u2197</li> <li>External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B \u2197</li> <li>NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 \u2197</li> <li>ERC721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 \u2197</li> <li>ERC1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e \u2197</li> </ul>","title":"Ropsten"},{"location":"ethereum/ethereum-overview/","text":"","title":"Rarible Protocol Ethereum"},{"location":"ethereum/ethereum-overview/#overview","text":"<p>Rarible Protocol Ethereum is a set of tools to query, issue, and trade NFTs in the Ethereum blockchain network. It consists of Smart Contracts, Indexer, API, and SDK.</p> <p></p> <p>Main features:</p> <ul> <li>Decentralized Exchange</li> <li>Open Source Indexer</li> <li>Minting single (ERC-721) and multiple (ERC-1155) tokens, including lazy minting</li> <li>Ability to share Fees</li> <li>Royalties Support</li> <li>Public Order Book</li> </ul>","title":"Overview"},{"location":"ethereum/ethereum-overview/#smart-contracts","text":"<p>Rarible Smart Contracts for Ethereum are stored on the Ethereum blockchain. They will run when predetermined conditions are met.</p> <p>To see more details about the smart contracts as well as their code, check the Smart Contracts page or the Protocol Contracts github repo.</p>","title":"Smart Contracts"},{"location":"ethereum/ethereum-overview/#api-reference","text":"<p>Use these base URLs to access API on different Ethereum networks:</p>    Base URL Network Chain ID     https://ethereum-api.rarible.org/v0.1/doc Mainnet 1   https://ethereum-api-staging.rarible.org/v0.1/doc Rinkeby 4   https://ethereum-api-dev.rarible.org/v0.1/doc Ropsten 3   https://ethereum-api-e2e.rarible.org/v0.1/doc - -    <p>See the page API and Indexer to see how to work with the API.</p> <p>For more information, see Ethereum Indexer and Ethereum OpenAPI repos on GitHub.</p>","title":"API Reference"},{"location":"ethereum/ethereum-overview/#sdk","text":"<p>Rarible Protocol Ethereum SDK can help interact with your application and the Rarible protocol.</p> <p>Main features:</p> <ul> <li>Create Mint and Lazy Minting ERC-721 and ERC-1155 tokens</li> <li>Create Sell Orders</li> <li>Create and accept Bid</li> <li>Buy tokens</li> <li>Transfer tokens</li> <li>Burn tokens</li> </ul> <p>For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.</p>","title":"SDK"},{"location":"ethereum/api/create-lazy-minting/","text":"<p>To mint an NFT using Lazy Minting, use the mintNftAsset method in nft-lazy-mint-controller.</p>","title":"Using Lazy Minting"},{"location":"ethereum/api/create-lazy-minting/#mintnftasset","text":"<p>Creates a Lazy Minted NFT token.</p> <p><code>https://ethereum-api-staging.rarible.org/v0.1/nft/mints</code></p> <p>Example request (staging):</p> <pre><code>curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/nft/mints' \\\n  --header 'content-type: application/json' \\\n  --data-raw '{\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"@type\":\"ERC721\",\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"]}'\n</code></pre> <p>Request parameters:</p> <ul> <li>@typerequired \u2014 token type <code>ERC721</code> or <code>ERC1155</code></li> <li>supply \u2014 the total number of tokens for Mint. Only for ERC-1155</li> <li>contract \u2014 address of the smart contract</li> <li>tokenId \u2014 token ID</li> <li>uri \u2014 suffix for the token URI. The prefix is usually <code>ipfs:/</code></li> <li>creators \u2014 an array of authors addresses</li> <li>royalties \u2014 royalty array</li> <li>signatures \u2014 array of digital signatures. Each creator must have a signature the only exception being when the creator sends a mint transaction.</li> </ul> <p>Response example (status 200):</p> <pre><code>{\n  \"id\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:83144199935168800027256855471009236590928205711995533202494108027144764391425\",\n  \"contract\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n  \"tokenId\": \"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\n  \"creators\": [\n    {\n      \"account\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n      \"value\": 10000\n    }\n  ],\n  \"supply\": \"1\",\n  \"lazySupply\": \"1\",\n  \"owners\": [\n    \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\"\n  ],\n  \"royalties\": [\n    {\n      \"account\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n      \"value\": 1000\n    }\n  ],\n  \"date\": \"2021-11-23T15:37:03.610Z\",\n  \"pending\": [],\n  \"deleted\": false,\n  \"meta\": {\n    \"name\": \"Violence Token\",\n    \"description\": \"\",\n    \"attributes\": [],\n    \"image\": {\n      \"url\": {\n        \"ORIGINAL\": \"ipfs://ipfs/QmbnW9qS5dcmXavo55yqzmF79wWT6qTcYKBAAaS3gDgrDa/image.jpeg\"\n      },\n      \"meta\": {\n        \"ORIGINAL\": {\n          \"type\": \"image/jpeg\",\n          \"width\": 400,\n          \"height\": 400\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Response parameters:</p> <ul> <li>id \u2014 item ID, has the format <code>${contract}:${tokenId}</code></li> <li>contract \u2014 address of the smart contract</li> <li>tokenId \u2014 token ID</li> <li>creators \u2014 array of information about creators</li> <li>supply \u2014 number of tokens created</li> <li>lazysupply \u2014 the number of Lazy Minting tokens created</li> <li>owners \u2014 array of information about token owners</li> <li>royalties \u2014 an array of information about royalties</li> <li>date \u2014 date of token creation</li> <li>pending \u2014 whether the item is incomplete. For example, it is in the status <code>TRANSFER</code></li> <li>deleted \u2014 is the order deleted</li> <li>meta \u2014 meta information about the item</li> </ul>","title":"mintNftAsset"},{"location":"ethereum/api/create-orders/","text":"<p>To create an order, use the upsertOrder method in order-controller.</p>","title":"Create Orders"},{"location":"ethereum/api/create-orders/#upsertorder","text":"<p>Creates or updates an Order.</p> <p><code>https://ethereum-api.rarible.org/v0.1/order/orders</code></p> <p>Example request (staging):</p> <pre><code>curl --request POST 'https://ethereum-api-staging.rarible.org/v0.1/order/orders' \\\n  --header 'content-type: application/json' \\\n  --data-raw '{\"maker\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"type\":\"RARIBLE_V2\",\"data\":{\"dataType\":\"RARIBLE_V2_DATA_V1\",\"payouts\":[],\"originFees\":[{\"account\":\"0x76c5855e93bd498b6331652854c4549d34bc3a30\",\"value\":250}]},\"salt\":\"86881339267547208763979074509610437060593762063071194041427040496432360352297\",\"signature\":\"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\",\"make\":{\"assetType\":{\"@type\":\"ERC721\",\"contract\":\"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\"tokenId\":\"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\"uri\":\"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\"creators\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":10000}],\"royalties\":[{\"account\":\"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\"value\":1000}],\"signatures\":[\"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"],\"assetClass\":\"ERC721_LAZY\"},\"value\":\"1\"},\"take\":{\"assetType\":{\"assetClass\":\"ETH\"},\"value\":\"10000000000000000\"}}'\n</code></pre> <p>Request parameters:</p> <ul> <li>type \u2014 order type <code>RARIBLE_V1</code> or <code>RARIBLE_V2</code></li> <li>data \u2014 data for creating or updating the order. The required fields depend on order type</li> <li>maker \u2014 address of the order creator</li> <li>taker \u2014 address of the recipient of the order (optional)</li> <li>make \u2014 make the side of the order. What the creator has</li> <li>take \u2014 take the side of the order. What the creator wants to get in exchange for the make side</li> <li>salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash</li> <li>start \u2014 the start date of the order placement, from which the buyer can make a Bid (optional) p.s. unix time is used </li> <li>end \u2014 the end date of the order placement, before which the buyer can make a Bid (optional) p.s. unix time is used </li> <li>signature \u2014 the digital signature of the order creator</li> </ul> <p>Response example (status 200):</p> <pre><code>{\n  \"type\": \"RARIBLE_V2\",\n  \"maker\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n  \"make\": {\n    \"assetType\": {\n      \"assetClass\": \"ERC721_LAZY\",\n      \"contract\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\",\n      \"tokenId\": \"83144199935168800027256855471009236590928205711995533202494108027144764391425\",\n      \"uri\": \"/ipfs/QmWeVMxWPbz2AdGhrZdi3ZQXVdppzPPakXfdavtu9syyA7\",\n      \"creators\": [\n        {\n          \"account\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n          \"value\": 10000\n        }\n      ],\n      \"royalties\": [\n        {\n          \"account\": \"0xb7d1f311ef648f0a9d9eff2b47f5bbb53e583dca\",\n          \"value\": 1000\n        }\n      ],\n      \"signatures\": [\n        \"0xf91e21cda6fc519f4b3ea77086393482a65f715b3e981da8d31c753bf5c5060018b4460cc9935f397808d14365e64214c18d0fc46441b55e0858a398ff7ffc8c1b\"\n      ]\n    },\n    \"value\": \"1\",\n    \"valueDecimal\": 1\n  },\n  \"take\": {\n    \"assetType\": {\n      \"assetClass\": \"ETH\"\n    },\n    \"value\": \"10000000000000000\",\n    \"valueDecimal\": 0.01\n  },\n  \"fill\": \"0\",\n  \"fillValue\": 0,\n  \"makeStock\": \"1\",\n  \"makeStockValue\": 1,\n  \"cancelled\": false,\n  \"salt\": \"0xc015186be955e586fb9d3bc1ddbbf43470a40d18b4ccdc750af405155eee6a29\",\n  \"signature\": \"0xd3147a72aa61e2ff970c05dac9b87c4a7187a5d0d6dc125f187e40612cea73d637608995704da1d35dc0f92c153811167860a85889de9b96c9c80e9b960d80681c\",\n  \"createdAt\": \"2021-11-23T15:37:13.158Z\",\n  \"lastUpdateAt\": \"2021-11-23T15:37:13.158Z\",\n  \"pending\": [],\n  \"hash\": \"0x279863b844f7bae2db201bff5abd9467f380eb029399e1339671d9d51f9a0280\",\n  \"makeBalance\": \"0\",\n  \"makePrice\": 0.01,\n  \"makePriceUsd\": 40.193574609729986,\n  \"priceHistory\": [\n    {\n      \"date\": \"2021-11-23T15:37:13.158Z\",\n      \"makeValue\": 1,\n      \"takeValue\": 0.01\n    }\n  ],\n  \"status\": \"ACTIVE\",\n  \"data\": {\n    \"dataType\": \"RARIBLE_V2_DATA_V1\",\n    \"payouts\": [],\n    \"originFees\": [\n      {\n        \"account\": \"0x76c5855e93bd498b6331652854c4549d34bc3a30\",\n        \"value\": 250\n      }\n    ]\n  }\n}\n</code></pre> <p>Response parameters:</p> <ul> <li>type \u2014 order type <code>RARIBLE_V1</code>, <code>RARIBLE_V2</code>, <code>OPEN_SEA_V1</code> or <code>CRYPTO_PUNK</code></li> <li>data \u2014 information about order type, Fees, etc.</li> <li>maker \u2014 address of the order creator</li> <li>taker \u2014 address of the recipient of the order</li> <li>make \u2014 make the order side. What the creator has</li> <li>take \u2014 take the side of the order. What the creator wants to get in exchange for the make side</li> <li>fill \u2014 filling in data when matching</li> <li>fillvalue \u2014 data filling value</li> <li>start \u2014 the starting date of the order placement, from which the buyer can make a Bid</li> <li>end \u2014 the end date of the order placement before which the buyer can make a Bid</li> <li>makestock \u2014 how much is available for sale</li> <li>makestockvalue \u2014 the value of how much is available for sale</li> <li>cancelled \u2014 the order is canceled or not</li> <li>salt \u2014 the string of data that is passed to the hash function along with the input array of data to calculate the hash</li> <li>signature \u2014 digital signature of the order creator</li> <li>createdAt \u2014 date of order creation</li> <li>lastupdateat \u2014 order update date</li> <li>pending \u2014 whether the order is incomplete. For example, it is in the status of <code>CANCEL</code>, <code>ORDER_SIDE_MATCH</code> or <code>ON_CHAIN_ORDER</code></li> <li>hash \u2014 hash of the order</li> <li>makebalance \u2014 balance of the order creator</li> <li>makeprice \u2014 order price</li> <li>Takeprice \u2014 buyer's suggested price</li> <li>makepriceusd \u2014 order price in USD</li> <li>takepriceusd \u2014 price in USD suggested by the buyer</li> <li>pricehistory \u2014 history of price changes</li> <li>status \u2014 order status <code>ACTIVE</code>, <code>FILLED</code>, <code>HISTORICAL</code>, <code>INACTIVE</code> or <code>CANCELLED</code></li> </ul>","title":"upsertOrder"},{"location":"ethereum/api/ethereum-api-indexer/","text":"<p>The main functions of the API and indexer are:</p> <ul> <li>Follow the blockchain</li> <li>Handle read requests</li> <li>Process creation requests</li> </ul>","title":"API and Indexer Overview"},{"location":"ethereum/api/ethereum-api-indexer/#architecture","text":"<p>The Rarible Protocol Ethereum indexer consists of the following parts:</p> <ul> <li>NFT indexer \u2014 aggregates NFTs data</li> <li>ERC-20 indexer \u2014 aggregates data about ERC-20 tokens and balances</li> <li>Order indexer \u2014 aggregates Orders data from different platforms</li> </ul> <p>Each indexer listens to a specific part of the Ethereum blockchain. The indexers can be used to request data about the state of the blockchain.</p> <p>Indexers generate events when the state changes. They are developed with Spring Framework and use these external services:</p> <ul> <li>MongoDB \u2014 main data storage</li> <li>Apache Kafka \u2014 event handling</li> </ul> <p></p>","title":"Architecture"},{"location":"ethereum/api/ethereum-api-indexer/#controllers","text":"<ol> <li>To create or modify NFTs and search information about them:<ul> <li>nft-transaction-controller</li> <li>nft-lazy-mint-controller</li> <li>nft-activity-controller</li> <li>nft-ownership-controller</li> <li>nft-item-controller</li> <li>nft-collection-controller</li> </ul> </li> <li>To create or modify orders and search information about them:<ul> <li>order-signature-controller</li> <li>order-encode-controller</li> <li>order-controller</li> <li>order-transaction-controller</li> <li>order-activity-controller</li> <li>order-aggregation-controller</li> <li>nft-order-ownership-controller</li> <li>nft-order-item-controller</li> <li>nft-order-activity-controller</li> <li>nft-order-collection-controller</li> </ul> </li> <li>Additional controllers:<ul> <li>gateway-controller</li> <li>erc20-balance-controller</li> <li>erc20-token-controller</li> <li>lock-controller</li> </ul> </li> </ol>","title":"Controllers"},{"location":"ethereum/api/ethereum-api-indexer/#api-usage-examples","text":"<ul> <li>Search Items</li> <li>Search Orders</li> <li>Create Lazy Minting</li> <li>Create Orders</li> </ul>","title":"API usage Examples"},{"location":"ethereum/api/search-items/","text":"<p>The main requests for working with Items relate to the nft-item-controller. Let's look at the example of getNftAllItems.</p>","title":"Search Items"},{"location":"ethereum/api/search-items/#getnftallitems","text":"<p>It will return all NFT items.</p> <p>Example request:</p> <pre><code>curl --request GET 'https://ethereum-api.rarible.org/v0.1/nft/items/all?size=1'\n</code></pre> <p>Request parameters:</p> <ul> <li>size \u2014 the number of items to be returned</li> <li>showDeleted \u2014 display deleted items or not</li> <li>lastUpdatedFrom \u2014 returns items that have been updated since that date (timestamp in ms)</li> <li>lastUpdatedTo \u2014 returns items that have been updated to this date (timestamp in ms)</li> <li>continuation \u2014 continuation token from the previous response</li> </ul> <p>Response example (status 200):</p> <pre><code>{\n    \"total\": 1,\n    \"continuation\": \"1637677864204_0xf6793da657495ffeff9ee6350824910abc21356c:0x8108800667cb3859020c77f7643cedb794b4455700000000000000000000000e\",\n    \"items\": [\n        {\n            \"id\": \"0xf6793da657495ffeff9ee6350824910abc21356c:58363375839982426315252321964399886024230569048144758096248518895130164330510\",\n            \"contract\": \"0xf6793da657495ffeff9ee6350824910abc21356c\",\n            \"tokenId\": \"58363375839982426315252321964399886024230569048144758096248518895130164330510\",\n            \"creators\": [\n                {\n                    \"account\": \"0x8108800667cb3859020c77f7643cedb794b44557\",\n                    \"value\": 10000\n                }\n            ],\n            \"supply\": \"1\",\n            \"lazySupply\": \"1\",\n            \"owners\": [\n                \"0x8108800667cb3859020c77f7643cedb794b44557\"\n            ],\n            \"royalties\": [\n                {\n                    \"account\": \"0x8108800667cb3859020c77f7643cedb794b44557\",\n                    \"value\": 1000\n                }\n            ],\n            \"date\": \"2021-11-23T14:31:04.204Z\",\n            \"pending\": [],\n            \"deleted\": false,\n            \"meta\": {\n                \"name\": \"Rampows the Daltons\",\n                \"description\": \"\",\n                \"attributes\": [],\n                \"image\": {\n                    \"url\": {\n                        \"ORIGINAL\": \"ipfs://ipfs/QmWXtdxkrR33rNxoNAbUDELsv2YBjajE4nhHGrgwT7UBHQ/image.jpeg\"\n                    },\n                    \"meta\": {\n                        \"ORIGINAL\": {\n                            \"type\": \"image/jpeg\",\n                            \"width\": 1792,\n                            \"height\": 1401\n                        }\n                    }\n                }\n            }\n        }\n    ]\n}\n</code></pre> <p>Response parameters:</p> <ul> <li>total \u2014 the number of items returned on request</li> <li>continuation \u2014 continuation token from the previous response</li> <li>items \u2014 list of found items &amp; basic information about them</li> </ul>","title":"getNftAllItems"},{"location":"ethereum/api/search-orders/","text":"<p>The main requests for working with Orders refer to order-controller. Let's look at the example of getOrdersAllByStatus.</p>","title":"Search Orders"},{"location":"ethereum/api/search-orders/#getordersallbystatus","text":"<p>Returns all orders sorted by status.</p> <p>Example request:</p> <pre><code>curl --request GET 'https://ethereum-api.rarible.org/v0.1/order/orders/all/byStatus?sort=LAST_UPDATE_DESC&amp;size=1&amp;status=ACTIVE'\n</code></pre> <p>Request parameters:</p> <ul> <li>sort  \u2014 sort by last updated orders <code>LAST_UPDATE_ASC</code>, <code>LAST_UPDATE_DESC</code></li> <li>size \u2014 number of orders to be returned</li> <li>continuation \u2014 continuation token from the previous response</li> <li>status \u2014 order status <code>ACTIVE</code>, <code>FILLED</code>, <code>HISTORICAL</code>, <code>INACTIVE</code>, <code>CANCELLED</code></li> </ul> <p>Response example (status 200):</p> <pre><code>{\n    \"orders\": [\n        {\n            \"type\": \"RARIBLE_V2\",\n            \"maker\": \"0x1a68bab3ebe18ffe95508b2d4e1362addc2cbdd6\",\n            \"make\": {\n                \"assetType\": {\n                    \"assetClass\": \"ERC20\",\n                    \"contract\": \"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\"\n                },\n                \"value\": \"260000000000000000\",\n                \"valueDecimal\": 0.260000000000000000\n            },\n            \"take\": {\n                \"assetType\": {\n                    \"assetClass\": \"ERC721\",\n                    \"contract\": \"0x918f677b3ab4b9290ca96a95430fd228b2d84817\",\n                    \"tokenId\": \"260\"\n                },\n                \"value\": \"1\",\n                \"valueDecimal\": 1\n            },\n            \"fill\": \"0\",\n            \"fillValue\": 0,\n            \"makeStock\": \"260000000000000000\",\n            \"makeStockValue\": 0.260000000000000000,\n            \"cancelled\": false,\n            \"salt\": \"0xf7f9ca62eceb7ee9021a89ac2a77976287721cc56a28f9d8d12c1332898e12e4\",\n            \"signature\": \"0x382bd104f4497119c75b36e5f0954a03692ab1c3b995266b20623bc718a58f423ff68e2caacb93668811e52b6a099260b3147ded35dc3ad5d65970efde9587761c\",\n            \"createdAt\": \"2021-11-23T15:08:20.925Z\",\n            \"lastUpdateAt\": \"2021-11-23T15:08:20.925Z\",\n            \"pending\": [],\n            \"hash\": \"0x3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\",\n            \"makeBalance\": \"0\",\n            \"takePrice\": 0.260000000000000000,\n            \"takePriceUsd\": 1089.887807206807960000000000000000,\n            \"priceHistory\": [\n                {\n                    \"date\": \"2021-11-23T15:08:20.925Z\",\n                    \"makeValue\": 0.260000000000000000,\n                    \"takeValue\": 1\n                }\n            ],\n            \"status\": \"ACTIVE\",\n            \"data\": {\n                \"dataType\": \"RARIBLE_V2_DATA_V1\",\n                \"payouts\": [],\n                \"originFees\": [\n                    {\n                        \"account\": \"0x1cf0df2a5a20cd61d68d4489eebbf85b8d39e18a\",\n                        \"value\": 250\n                    }\n                ]\n            }\n        }\n    ],\n    \"continuation\": \"1637680100925_3e23919b0ad64895792c49bb40a551a8e60d70081eb940fa3d1a56c17436eedf\"\n}\n</code></pre> <p>Response parameters:</p> <ul> <li>orders \u2014 list of found orders with basic information on them</li> <li>continuation \u2014 continuation token from the previous response</li> </ul>","title":"getOrdersAllByStatus"},{"location":"ethereum/assets/asset-discovery/","text":"","title":"Asset Discovery"},{"location":"ethereum/assets/asset-discovery/#search-items","text":"<p>{% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for item-controller part</p> <p>There are some controllers to query items:</p> <ul> <li>get all items</li> <li>get items by owner</li> <li>get items by collection</li> <li>other controllers in item-controller section of the api-reference</li> </ul> <p>These controllers have common parameters:</p> <ul> <li>size - how many items you want to get</li> <li>continuation - send this parameter to fetch next portion of data (you can find continuation value in the server response)</li> <li>also they have different query parameters for each. Please, see api-reference</li> </ul> <p>{% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId/meta\" method=\"get\" summary=\"Item Metadata\" %} {% swagger-description %} Displays all item Metadata (Stored on IPFS)</p> <p>{% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21</p> <p>{% swagger-response status=\"200\" description=\"\" %} <pre><code>{\n  \"name\": \"string\",\n  \"description\": \"string\",\n  \"image\": \"string\",\n  \"external_url\": \"string\",\n  \"animation_url\": \"string\",\n  \"attributes\": {}\n}\n</code></pre> {% endswagger-response %}</p> <p>{% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId\" method=\"get\" summary=\"Item Data\" %} {% swagger-description %} Displays Item data such as Royalties, Unlockable content, etc.</p> <p>{% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21</p> <p>{% swagger-response status=\"200\" description=\"\" %} <pre><code>{\n  \"id\": \"string\",\n  \"token\": \"string\",\n  \"tokenId\": 0,\n  \"unlockable\": true,\n  \"creator\": \"string\",\n  \"supply\": 0,\n  \"owners\": [\n    \"string\"\n  ],\n  \"royalties\": [\n    {\n      \"recipient\": \"string\",\n      \"value\": 0\n    }\n  ]\n}\n</code></pre> {% endswagger-response %}</p> <p>{% hint style=\"danger\" %} If you wish to build an order for an ERC1155, it is important you also record the amount returned by the query.</p> <p>Visit the next section on how to create a sell order!</p>","title":"Search Items"},{"location":"ethereum/assets/creating-an-asset/","text":"","title":"Asset Creation"},{"location":"ethereum/assets/creating-an-asset/#asset-introduction","text":"<p>Rarible protocol has two asset types, ERC721, and ERC1155, the main difference between them is that ERC721 creates unique 1 of 1 item, whereas ERC1155, allows the user to create an item with multiple editions (The maximum amount of editions is 2**256 - 1).</p> <p>You can find the protocol smart contracts here.</p>","title":"Asset Introduction"},{"location":"ethereum/assets/creating-an-asset/#ropsten","text":"","title":"Ropsten"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc721-etherscan-link","text":"<pre><code>0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\n</code></pre>","title":"Asset Contract ERC721 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc1155-etherscan-link","text":"<pre><code>0x6a94aC200342AC823F909F142a65232E2f052183\n</code></pre>","title":"Asset Contract ERC1155 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#rinkeby","text":"","title":"Rinkeby"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc721-etherscan-link_1","text":"<pre><code>0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\n</code></pre>","title":"Asset Contract ERC721 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc1155-etherscan-link_1","text":"<pre><code>0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7\n</code></pre>","title":"Asset Contract ERC1155 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-types-explained","text":"","title":"Asset Types Explained"},{"location":"ethereum/assets/creating-an-asset/#erc721-erc1155","text":"<p>With the new ERC721 &amp; ERC1155 Asset contracts we no longer call the mint function directly, instead, we implement lazy minting via the mintAndTransfer function. Lazy minting allows the item to be created and store off-chain until someone purchases/transfers this item, only at this point does the item get created on-chain.</p> <p>Direct calls to <code>mint()</code> should be avoided and replaced with <code>mintAndTransfer()</code>. However, standard minting is still possible with this function. See ERC721 Standard Minting or ERC1155 Standard Minting for details.</p> <p>Parameters</p> <ul> <li>tokenId</li> </ul> <p>The <code>tokenId</code> must be supplied as a uint256, which is a unique identifying number for the token.</p> <p>The <code>tokenId</code> is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID.</p> <ul> <li>uri</li> </ul> <p>This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is <code>ipfs://</code></p> <p>Sample IPFS uri:</p> <p><code>/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp</code></p> <p>Gets concatenated into the following upon minting:</p> <p><code>ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp</code></p> <p>{% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details.</p> <ul> <li>creators</li> </ul> <p><code>creators</code> is an array of addresses and values. The <code>LibPart.Part</code> struct it derives from is provided below.</p> <pre><code>struct Part {\n    address payable account;\n    uint96 value;\n}\n</code></pre> <p>This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone.</p> <p>Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways.</p> <p>I.e. The following array, <code>[[0x12345..., 5000], [0x6789..., 5000]]</code>, associates the creation of the given NFT to 2 creators at an equal 50% distribution.</p> <ul> <li>royalties</li> </ul> <p><code>royalties</code> is an array of addresses and values. Like <code>creators</code>, it's also derived from the <code>LibPart.Part</code> struct provided below.</p> <pre><code>struct Part {\n    address payable account;\n    uint96 value;\n}\n</code></pre> <p>The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%.</p> <p>I.e. One address recieves 20% royalties with the following array, <code>[[0x12345..., 2000]]</code>. But more than one address can be provided to recieve royalties at specified percentages.</p> <ul> <li>signatures</li> </ul> <p><code>signatures</code> is an array of wallet signatures for this transaction from every creator.</p> <p>However, an empty signature, <code>[[0x]]</code>, can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC721 Standard Minting.</p> <p>ERC721 mintAndTransfer ABI</p> <pre><code>    // ABI for ERC-721 mintAndTransfer\n    {\n      \"inputs\": [\n        {\n          \"components\": [\n            {\n              \"internalType\": \"uint256\",\n              \"name\": \"tokenId\",\n              \"type\": \"uint256\"\n            },\n            {\n              \"internalType\": \"string\",\n              \"name\": \"uri\",\n              \"type\": \"string\"\n            },\n            {\n              \"components\": [\n                {\n                  \"internalType\": \"address payable\",\n                  \"name\": \"account\",\n                  \"type\": \"address\"\n                },\n                {\n                  \"internalType\": \"uint256\",\n                  \"name\": \"value\",\n                  \"type\": \"uint256\"\n                }\n              ],\n              \"internalType\": \"struct LibPart.Part[]\",\n              \"name\": \"creators\",\n              \"type\": \"tuple[]\"\n            },\n            {\n              \"components\": [\n                {\n                  \"internalType\": \"address payable\",\n                  \"name\": \"account\",\n                  \"type\": \"address\"\n                },\n                {\n                  \"internalType\": \"uint256\",\n                  \"name\": \"value\",\n                  \"type\": \"uint256\"\n                }\n              ],\n              \"internalType\": \"struct LibPart.Part[]\",\n              \"name\": \"royalties\",\n              \"type\": \"tuple[]\"\n            },\n            {\n              \"internalType\": \"bytes[]\",\n              \"name\": \"signatures\",\n              \"type\": \"bytes[]\"\n            }\n          ],\n          \"internalType\": \"struct LibERC721LazyMint.Mint721Data\",\n          \"name\": \"data\",\n          \"type\": \"tuple\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"to\",\n          \"type\": \"address\"\n        }\n      ],\n      \"name\": \"mintAndTransfer\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }\n</code></pre>","title":"ERC721 &amp; ERC1155"},{"location":"ethereum/assets/creating-an-asset/#erc721-lazy-minting","text":"<p>If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict.</p> <p>Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance.</p> <p>We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here, here, and here.</p>","title":"ERC721 Lazy Minting"},{"location":"ethereum/assets/creating-an-asset/#for-721-ropsten","text":"<p>Step 1: Generate a token ID.</p> <p>GET from <code>https://ethereum-api-dev.rarible.com/protocol/v0.1/ethereum/nft/collections/{ContractAddress}/generate_token_id?minter=${account}</code></p> <p>Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted.</p> <p>GET from <code>https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}</code></p> <pre><code>const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) =&gt; res.json());\n</code></pre> <p>Response</p> <pre><code>{\n    tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", \n    signature: {\n        r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\"\n        s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\"\n        v: 28\n    }\n}\n</code></pre> <p>Get the <code>tokenId</code> from the response object.</p> <p>Step 2: Create the Lazy Mint Request Body to be signed by the creator.</p> <pre><code>{\n    \"@type\": \"ERC721\",\n    \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\",\n    \"tokenId\": tokenId,\n    \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\",\n    \"creators\": [\n        { \n            account: \"0x1234...\", \n            value: \"10000\" \n        }\n    ],\n    \"royalties\": [\n        { \n            account: \"0x1234...\", \n            value: 2000 \n        }\n    ],\n  };\n</code></pre> <p>Step 3: Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase.</p> <p>{% hint style=\"info\" %} See EIP1271 for information on how smart contracts can interact with this order book.</p> <p>First, construct the typed data structure:</p> <pre><code>\"types\": {\n    \"EIP712Domain\" [\n      {\n        type: \"string\",\n        name: \"name\",\n      },\n      {\n        type: \"string\",\n        name: \"version\",\n      },\n      {\n        type: \"uint256\",\n        name: \"chainId\",\n      },\n      {\n        type: \"address\",\n        name: \"verifyingContract\",\n      }\n    ],\n    \"Mint721\": [\n        {\"name\": \"@type\", \"type\": \"string\"},\n        {\"name\": \"contract\", \"type\": \"address\"},\n        {\"name\": \"tokenId\", \"type\": \"uint256\"},\n        {\"name\": \"tokenURI\", \"type\": \"string\"},\n        {\"name\": \"uri\", \"type\": \"string\"},\n        {\"name\": \"creators\", \"type\": \"Part[]\"},\n        {\"name\": \"royalties\", \"type\": \"Part[]\"}\n    ],\n    \"Part\": [\n        { name: \"account\", type: \"address\" },\n        { name: \"value\", type: \"uint96\" }\n    ]\n},\n\"domain\": {\n    name: \"Mint721\",\n    version: \"1\",\n    chainId: 3,\n    verifyingContract: \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\"\n},\n\"primaryType\": \"Mint721\",\n\"message\": {\n    \"@type\": \"ERC721\",\n    \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\",\n    \"tokenId\": tokenId,\n    \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\"\n    \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\",\n    \"creators\": [\n        { \n            account: \"0x1234...\", \n            value: \"10000\" \n        }\n    ],\n    \"royalties\": [\n        { \n            account: \"0x1234...\", \n            value: 2000 \n        }\n    ],\n };\n</code></pre> <p>Then provide the data structure above to the creator for signing.</p> <pre><code>// Sample code\n\nasync function signTypedData(web3Provider, from, dataStructure) {\n  const msgData = JSON.stringify(dataStructure);\n  const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]);\n  const sig0 = sig.substring(2);\n  const r = \"0x\" + sig0.substring(0, 64);\n  const s = \"0x\" + sig0.substring(64, 128);\n  const v = parseInt(sig0.substring(128, 130), 16);\n  return {\n    dataStructure,\n    signature,\n    v,\n    r,\n    s,\n  };\n}\n</code></pre> <p>Finally, get the <code>signature</code> from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2.</p> <p>E.g.</p> <pre><code>{\n    \"@type\": \"ERC721\",\n    \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\",\n    \"tokenId\": tokenId,\n    \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\",\n    \"creators\": [\n        { \n            account: \"0x1234...\", \n            value: \"10000\" \n        }\n    ],\n    \"royalties\": [\n        { \n            account: \"0x1234...\", \n            value: 2000 \n        }\n    ],\n    \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"]\n  };\n</code></pre> <p>Step 4: Create your Lazy Minted NFT.</p> <p>POST to <code>https://ethereum-api-dev.rarible.org/v0.1/nft/mints</code></p> <pre><code>{\n    \"@type\": \"ERC721\",\n    \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\",\n    \"tokenId\": tokenId,\n    \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\",\n    \"creators\": [\n        { \n            account: \"0x1234...\", \n            value: \"10000\" \n        }\n    ],\n    \"royalties\": [\n        { \n            account: \"0x1234...\", \n            value: 2000 \n        }\n    ],\n    \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"]\n  };\n</code></pre> <p>Response</p> <pre><code>{\n  \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\",\n  \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\",\n  \"tokenId\": tokenId,\n  \"creators\": [\n    {\n      \"account\": \"0x1234...\",\n      \"value\": 10000\n    }\n  ]\n  \"supply\": 1,\n  \"lazySupply\": 1,\n  \"owners\": [\n     \"0x1234...\"\n  ],\n  \"royalties\": [\n    {\n      \"account\": \"0x1234...\",\n      \"value\": 2000\n    }\n  ],\n  \"pending\": [\n    {\n      \"date\": \"2019-08-24T14:15:22Z\",\n      \"owner\": \"0x1234...\",\n      \"from\": \"0x1234...\",\n      \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\",\n      \"tokenId\": tokenId,\n      \"value\": 0,\n      \"type\": \"TRANSFER\"\n    }\n  ]\n}\n</code></pre> <p>You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\</p>","title":"For 721 (Ropsten)"},{"location":"ethereum/assets/creating-an-asset/#erc721-standard-minting","text":"<p>You can mint NFTs through the Rarible asset contracts using <code>mintAndTransfer</code> like you would for a standard <code>mint</code> call. You just need to provide all the expected parameters seen below.</p> <p><code>mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to)</code></p> <pre><code>struct Mint721Data {\n uint tokenId;\n string uri;\n LibPart.Part[] creators;\n LibPart.Part[] royalties;\n bytes[] signatures;\n}\n</code></pre> <p>You can do so by instantiating the contract in your app and calling the function directly using <code>ethers.js</code> or <code>web3.js</code>.</p> <p>{% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. <code>0x</code>.</p> <p>Royalties are set as basis point, so 1000 = 10%. More info</p>","title":"ERC721 Standard Minting"},{"location":"ethereum/assets/creating-an-asset/#example","text":"<pre><code>async function mintNow() {\n    // Get a token id\n    const tokenId = await fetch(`https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}`);\n\n    // Instantiate the contract\n    const provider = new ethers.providers.Web3Provider(userWalletProvider);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(contractAddress, abi, signer);\n\n    // Call the function\n    const tx = await contract.mintAndTransfer(\n        [\n          tokenId.tokenId,\n          uri,\n          [[creator, 5000], [creator2, 5000]], // You can assign one or add multiple creators, but the value must total 10000\n          [[creator, 1000], [creator2, 1000]], // Royalties are set as basis point, so 1000 = 10%. \n          [\"0x\"]\n        ],\n        minter,\n      );\n\n      const receipt = await tx.wait();\n      console.log('Minting Success', receipt);\n}\n</code></pre>","title":"Example"},{"location":"ethereum/assets/creating-an-asset/#erc1155-overview","text":"<p><code>mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount)</code></p> <p>Mint1155Data Parameter Structure</p> <pre><code>struct Mint1155Data {\n uint tokenId;\n string uri;\n uint supply;\n LibPart.Part[] creators;\n LibPart.Part[] royalties;\n bytes[] signatures;\n}\n</code></pre> <p>Parameters</p> <ul> <li>tokenId</li> </ul> <p>The <code>tokenId</code> must be supplied as a uint256, which is a unique identifying number for the token.</p> <p>The <code>tokenId</code> is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID.</p> <ul> <li>uri</li> </ul> <p>This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is <code>ipfs://</code></p> <p>Sample IPFS uri:</p> <p><code>/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp</code></p> <p>Gets concatenated into the following upon minting:</p> <p><code>ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp</code></p> <p>{% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details.</p> <ul> <li>supply</li> </ul> <p><code>supply</code> should be a uint256, this is the number of copies (or Editions) of this token that will ever exist. (Maximum value is 2**256 - 1).</p> <ul> <li>creators</li> </ul> <p><code>creators</code> is an array of addresses and values. The <code>LibPart.Part</code> struct it derives from is provided below.</p> <pre><code>struct Part {\n    address payable account;\n    uint96 value;\n}\n</code></pre> <p>This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone.</p> <p>Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways.</p> <p>I.e. The following array, <code>[[0x12345..., 5000], [0x6789..., 5000]]</code>, associates the creation of the given NFT to 2 creators at an equal 50% distribution.</p> <ul> <li>royalties</li> </ul> <p><code>royalties</code> is an array of addresses and values. Like <code>creators</code>, it's also derived from the <code>LibPart.Part</code> struct provided below.</p> <pre><code>struct Part {\n    address payable account;\n    uint96 value;\n}\n</code></pre> <p>The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%.</p> <p>I.e. One address recieves 20% royalties with the following array, <code>[[0x12345..., 2000]]</code>. But more than one address can be provided to recieve royalties at specified percentages.</p> <ul> <li>signatures</li> </ul> <p><code>signatures</code> is an array of wallet signatures for this transaction from every creator.</p> <p>However, an empty signature, <code>[[0x]]</code>, can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC1155 Standard Minting.</p> <p>ERC1155 mintAndTransfer ABI</p> <pre><code>    // ABI for ERC-1155 mintAndTransfer\n    {\n      \"inputs\": [\n        {\n          \"components\": [\n            {\n              \"internalType\": \"uint256\",\n              \"name\": \"tokenId\",\n              \"type\": \"uint256\"\n            },\n            {\n              \"internalType\": \"string\",\n              \"name\": \"uri\",\n              \"type\": \"string\"\n            },\n            {\n              \"internalType\": \"uint256\",\n              \"name\": \"supply\",\n              \"type\": \"uint256\"\n            },\n            {\n              \"components\": [\n                {\n                  \"internalType\": \"address payable\",\n                  \"name\": \"account\",\n                  \"type\": \"address\"\n                },\n                {\n                  \"internalType\": \"uint256\",\n                  \"name\": \"value\",\n                  \"type\": \"uint256\"\n                }\n              ],\n              \"internalType\": \"struct LibPart.Part[]\",\n              \"name\": \"creators\",\n              \"type\": \"tuple[]\"\n            },\n            {\n              \"components\": [\n                {\n                  \"internalType\": \"address payable\",\n                  \"name\": \"account\",\n                  \"type\": \"address\"\n                },\n                {\n                  \"internalType\": \"uint256\",\n                  \"name\": \"value\",\n                  \"type\": \"uint256\"\n                }\n              ],\n              \"internalType\": \"struct LibPart.Part[]\",\n              \"name\": \"royalties\",\n              \"type\": \"tuple[]\"\n            },\n            {\n              \"internalType\": \"bytes[]\",\n              \"name\": \"signatures\",\n              \"type\": \"bytes[]\"\n            }\n          ],\n          \"internalType\": \"struct LibERC1155LazyMint.Mint1155Data\",\n          \"name\": \"data\",\n          \"type\": \"tuple\"\n        },\n        {\n          \"internalType\": \"address\",\n          \"name\": \"to\",\n          \"type\": \"address\"\n        },\n        {\n          \"internalType\": \"uint256\",\n          \"name\": \"_amount\",\n          \"type\": \"uint256\"\n        }\n      ],\n      \"name\": \"mintAndTransfer\",\n      \"outputs\": [],\n      \"stateMutability\": \"nonpayable\",\n      \"type\": \"function\"\n    }\n</code></pre>","title":"ERC1155 Overview"},{"location":"ethereum/assets/creating-an-asset/#erc1155-lazy-minting","text":"<p>If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict.</p> <p>Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance.</p> <p>We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here, here, and here.</p>","title":"ERC1155 Lazy Minting"},{"location":"ethereum/assets/creating-an-asset/#for-1155-ropsten","text":"<p>Step 1: Generate a token ID.</p> <p>Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted.</p> <p>GET from <code>https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}</code></p> <pre><code>// Sample Call \n\nconst res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) =&gt; res.json());\n</code></pre> <p>Response</p> <pre><code>{\n    tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", \n    signature: {\n        r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\"\n        s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\"\n        v: 28\n    }\n}\n</code></pre> <p>Get the <code>tokenId</code> from the response object.</p> <p>Step 2: Create the Lazy Mint Request Body to be signed by the creator.</p> <pre><code>{\n    \"@type\": \"ERC1155\",\n    \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \",\n    \"tokenId\": tokenId,\n    \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\",\n    \"supply\": 10,\n    \"creators\": [\n        { \n            account: \"0x1234...\", \n            value: \"10000\" \n        }\n    ],\n    \"royalties\": [\n        { \n            account: \"0x1234...\", \n            value: 2000 \n        }\n    ],\n  };\n</code></pre> <p>Step 3: Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase.</p> <p>{% hint style=\"info\" %} See Signatures for more details on typed data and EIP-712 and EIP-1271.</p> <p>First, construct the typed data structure:</p> <pre><code>\"types\": {\n    \"EIP712Domain\" [\n      {\n        type: \"string\",\n        name: \"name\",\n      },\n      {\n        type: \"string\",\n        name: \"version\",\n      },\n      {\n        type: \"uint256\",\n        name: \"chainId\",\n      },\n      {\n        type: \"address\",\n        name: \"verifyingContract\",\n      }\n    ],\n    \"Mint1155\": [\n        {\"name\": \"@type\", \"type\": \"string\"},\n        {\"name\": \"contract\", \"type\": \"address\"},\n        {\"name\": \"tokenId\", \"type\": \"uint256\"},\n        {\"name\": \"tokenURI\", \"type\": \"string\"},\n        {\"name\": \"uri\", \"type\": \"string\"},\n        { name: 'supply', type: 'uint256' },\n        {\"name\": \"creators\", \"type\": \"Part[]\"},\n        {\"name\": \"royalties\", \"type\": \"Part[]\"}\n    ],\n    \"Part\": [\n        { name: \"account\", type: \"address\" },\n        { name: \"value\", type: \"uint96\" }\n    ]\n},\n\"domain\": {\n    name: \"Mint1155\",\n    version: \"1\",\n    chainId: 3,\n    verifyingContract: \"0x6a94aC200342AC823F909F142a65232E2f052183 \"\n},\n\"primaryType\": \"Mint1155\",\n\"message\": {\n    \"@type\": \"ERC1155\",\n    \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \",\n    \"tokenId\": tokenId,\n    \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\"\n    \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\",\n    \"supply\": 10,\n    \"creators\": [\n        { \n            account: \"0x1234...\", \n            value: \"10000\" \n        }\n    ],\n    \"royalties\": [\n        { \n            account: \"0x1234...\", \n            value: 2000 \n        }\n    ],\n };\n</code></pre> <p>Then provide the data structure above to the creator for signing.</p> <pre><code>// Sample code\n\nasync function signTypedData(web3Provider, from, dataStructure) {\n  const msgData = JSON.stringify(dataStructure);\n  const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]);\n  const sig0 = sig.substring(2);\n  const r = \"0x\" + sig0.substring(0, 64);\n  const s = \"0x\" + sig0.substring(64, 128);\n  const v = parseInt(sig0.substring(128, 130), 16);\n  return {\n    dataStructure,\n    signature,\n    v,\n    r,\n    s,\n  };\n}\n</code></pre> <p>Finally, get the <code>signature</code> from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2.</p> <p>E.g.</p> <pre><code>{\n    \"@type\": \"ERC1155\",\n    \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \",\n    \"tokenId\": tokenId,\n    \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\",\n    \"supply\": 10,\n    \"creators\": [\n        { \n            account: \"0x1234...\", \n            value: \"10000\" \n        }\n    ],\n    \"royalties\": [\n        { \n            account: \"0x1234...\", \n            value: 2000 \n        }\n    ],\n    \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"]\n  };\n</code></pre> <p>Step 4: Create your Lazy Minted NFT.</p> <p>POST to <code>https://ethereum-api-dev.rarible.org/v0.1/nft/mints</code></p> <pre><code>{\n    \"@type\": \"ERC721\",\n    \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\",\n    \"tokenId\": tokenId,\n    \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\",\n    \"supply\": 10\n    \"creators\": [\n        { \n            account: \"0x1234...\", \n            value: \"10000\" \n        }\n    ],\n    \"royalties\": [\n        { \n            account: \"0x1234...\", \n            value: 2000 \n        }\n    ],\n    \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"]\n  };\n</code></pre> <p>Response</p> <pre><code>{\n  \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\",\n  \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\",\n  \"tokenId\": tokenId,\n  \"creators\": [\n    {\n      \"account\": \"0x1234...\",\n      \"value\": 10000\n    }\n  ]\n  \"supply\": 1,\n  \"lazySupply\": 1,\n  \"owners\": [\n     \"0x1234...\"\n  ],\n  \"royalties\": [\n    {\n      \"account\": \"0x1234...\",\n      \"value\": 2000\n    }\n  ],\n  \"pending\": [\n    {\n      \"date\": \"2019-08-24T14:15:22Z\",\n      \"owner\": \"0x1234...\",\n      \"from\": \"0x1234...\",\n      \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\",\n      \"tokenId\": tokenId,\n      \"value\": 0,\n      \"type\": \"TRANSFER\"\n    }\n  ]\n}\n</code></pre> <p>You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\</p>","title":"For 1155 (Ropsten)"},{"location":"ethereum/assets/creating-an-asset/#erc1155-standard-minting","text":"<p>You can mint NFTs through the Rarible asset contracts using <code>mintAndTransfer</code> like you would for a standard <code>mint</code> call. You just need to provide all the expected parameters seen below.</p> <p><code>mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount)</code></p> <pre><code>struct Mint1155Data {\n uint tokenId;\n string uri;\n uint supply;\n LibPart.Part[] creators;\n LibPart.Part[] royalties;\n bytes[] signatures;\n}\n</code></pre> <p>You can do so by instantiating the contract in your app and calling the function directly using <code>ethers.js</code> or <code>web3.js</code>.</p> <p>{% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. <code>0x</code>.</p> <p>Royalties are set as basis point, so 1000 = 10%. More info</p>","title":"ERC1155 Standard Minting"},{"location":"ethereum/assets/creating-an-asset/#example_1","text":"<pre><code>async function mintNow() {\n    // Get a token id\n    const tokenId = await fetch(`https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}`);\n\n    // Instantiate the contract\n    const provider = new ethers.providers.Web3Provider(userWalletProvider);\n    const signer = provider.getSigner();\n    const contract = new ethers.Contract(contractAddress, abi, signer);\n\n    // Call the function\n    const tx = await contract.mintAndTransfer(\n        [\n          tokenId.tokenId,\n          uri,\n          totalSupply,\n          [[creator, 5000], [creator2, 5000]], // You can assign one or add multiple creators, but the value must total 10000\n          [[creator, 1000], [creator2, 1000]], // Royalties are set as basis point, so 1000 = 10%. \n          [\"0x\"]\n        ],\n        minter,\n        amount\n      );\n\n      const receipt = await tx.wait();\n      console.log('Minting Success', receipt);\n}\n</code></pre>","title":"Example"},{"location":"ethereum/assets/creating-an-asset/#uploading-the-image-to-ipfs","text":"<p>The image needs to be hosted on IPFS, at Rarible we use pinata, below is a NodeJS example of uploading an image using their API.</p> <pre><code>const axios = require(\"axios\");\nconst fs = require(\"fs\");\nconst FormData = require(\"form-data\");\n\nexport const pinFileToIPFS = (pinataApiKey, pinataSecretApiKey) =&gt; {\n  const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS`;\n  let data = new FormData();\n\n  data.append(\"file\", fs.createReadStream(\"./yourfile.png\"));\n\n  return axios.post(url, data, {\n      headers: {\n        \"Content-Type\": `multipart/form-data; boundary= ${data._boundary}`,\n        pinata_api_key: pinataApiKey,\n        pinata_secret_api_key: pinataSecretApiKey,\n      },\n    })\n    .then(function (response) {\n      console.log(repsonse.IpfsHash);\n    })\n    .catch(function (error) {\n      console.log(error)\n    });\n};\n</code></pre> <p>This will return our IPFS CID, the full response looks like this:</p> <pre><code>{\n    IpfsHash: // This is the IPFS multi-hash provided back for your content,\n    PinSize: // This is how large (in bytes) the content you just pinned is,\n    Timestamp: // This is the timestamp for your content pinning (represented in ISO 8601 format)\n}\n</code></pre>","title":"Uploading the image to IPFS"},{"location":"ethereum/assets/creating-an-asset/#creating-our-nfts-metadata","text":"<p>Now that we have our IPFS CID (Called hash here on out), we can begin constructing our NFT's Metadata file that will be linked to the NFT on-chain. Below is a Metadata file with an explanation of the key and its value.</p> <pre><code>{\n   \"name\": /* NFT Name - This must be a string */,\n   \"description\": /* Description of the NFT - This must be a string */,\n   \"image\": /*  IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */,\n   \"external_url\": /* This is the link to Rarible which we currently don't have, we can fill this in shortly */,\n   \"animation_url\": /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */,\n   // the below section is not needed.\n   \"attributes\": [\n      {\n         \"key\": /* Key name - This must be a string */,\n         \"trait_type\": /* Trait name - This must be a string */,\n         \"value\": /* Key Value - This must be a string */\n      }\n   ]\n}\n</code></pre>","title":"Creating our NFT's Metadata"},{"location":"ethereum/assets/creating-an-asset/#adding-generated-metadata-to-ipfs","text":"<p>First, we need to make sure our <code>external_url</code> is a Rarible link. We can calculate this link based on the tokenId we create (The tokenId typically is made up of two sections, the first 20 bytes in the users' address and the next 12 bytes can be any random number. We will provide an API to allow you to get the next free available ID.), for this example, our external_url must be the collection address + tokenId and it will look like this</p> <pre><code>\"external_url\": \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\"\n</code></pre> <p>Notice we use the collection address and value address from our previous call to the tokens endpoint.</p> <p>Now we need to post our NFT's Metadata to IPFS below is an example of how to do this:</p> <pre><code>var axios = require('axios');\nvar data = JSON.stringify({\"name\":\"Test NFT\",\"description\":\"Test NFT\",\"image\":\"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\",\"external_url\":\"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\",\"attributes\":[{\"key\":\"Test\",\"trait_type\":\"Test\",\"value\":\"Test\"}]});\n\nvar config = {\n  method: 'post',\n  url: 'https://api.pinata.cloud/pinning/pinFileToIPFS',\n  headers: { \n    'pinata_api_key': // KEY_HERE, \n    'pinata_secret_api_key': // SECRET_KEY_HERE, \n    'Content-Type': 'application/json'\n  },\n  data: data\n};\n\naxios(config).then(function (response) {\n  console.log(JSON.stringify(response.data));\n}).catch(function (error) {\n  console.log(error);\n});\n</code></pre> <p>Our Result will look something similar to this:</p> <pre><code>{\n    \"IpfsHash\": \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\",\n    \"PinSize\": 290,\n    \"Timestamp\": \"2021-02-10T14:06:09.255Z\"\n}\n</code></pre> <p>Make a note of your new <code>IpfsHash</code> since this is now the hash we need to attach to our NFT.</p>","title":"Adding Generated Metadata to IPFS"},{"location":"ethereum/assets/creating-an-asset/#custom-contracts","text":"<p>If you are not storing your metadata on IPFS, you will need to use your own contracts that have a <code>baseURI</code> better suited for where the metadata is stored.</p> <p>As a starting point, so long as your contract follows the ERC-721 or ERC-1155 standard it's NFTs can be bought and sold on Rarible and most other NFT marketplaces. Helpful guides on these standards can be found at OpenZeppelin.</p> <p>However, you'll need to add more to support royalties and lazy minting as these are not built into the current standards. To support royalties, your contract will need to inherit from the appropriate interfaces, which you can find here or here for an upgradeable version.</p> <p>Similarly for lazy minting support, you will need to add a <code>mintAndTransfer</code> function in your contract for the protocol to call that inherits the expected behavior. You can add this yourself or use this interface.</p> <p>In many cases, it may be easier and faster to just fork the protocol contracts you wanted to use and change the <code>baseURI</code> and any other data upon deployment.</p> <p>{% hint style=\"info\" %} You can supply your own <code>tokenId</code> instead of getting one from the API call used for Lazy Minting when rolling your own contracts, however, the token id needs to have the minter's address followed by 96 bits, which can include any number you want, in order to pass the <code>require</code> checks in the default <code>mintAndTransfer</code> function. Alternatively, you can still use the generate token id API used above to supply a tokenId for them.</p> <p>YAY! Your NFT is now minted! Visit the next section on how to create a sell order or to check if your Asset is indexed you can view this page.</p>","title":"Custom Contracts"},{"location":"ethereum/assets/token-factories/","text":"<p>You can easily create ERC721 and ERC1155 smart contracts using our Token Factories. Find addresses for token factories on Addresses page.</p> <p>Token Factories create Beacon proxies: this means Rarible Protocol can upgrade these contracts automatically (when all token contracts are upgraded).</p> <p>Currently, two token factories are available: ERC-721 and ERC-1155. These both contracts are public in terms of minting: anyone can mint tokens there.</p> <p>Invoke function <code>createToken</code> to create tokens with custom name, symbol. Set base uri to \"ipfs:/\" if you want to use ipfs for metadata storage.</p> <p>There are the parameters supported:</p> <ul> <li>name - name of the smart contract</li> <li>symbol - symbol of the smart contract</li> <li>base URI - prefix for the URI for created tokens (will be prepended to URI for every token minted). By default, use \"ipfs:/\"</li> <li>contractURI - URI holding metadata for the contract. Set https://api-mainnet.rarible.com/contractMetadata/{address} if you want to control metadata using Rarible UI</li> </ul>","title":"Token Factories"},{"location":"ethereum/exchange/accepting-a-buy-order/","text":"<p>To buy an item or accept a bid user should send transaction to Exchange contract's matchOrders function.</p> <p>Example for sending matchOrders is here.</p> <p>matchOrders function defined in ExchangeV2Core has 4 parameters:</p> <ol> <li>left order.</li> <li>left order signature</li> <li>right order</li> <li>right order signature </li> </ol> <p>More about order structure can be found here - Order Structure</p>","title":"Accepting a Buy Order"},{"location":"ethereum/exchange/accepting-a-buy-order/#pay-eth-for-erc721","text":"<p>You can only fill an ETH order if your side of the order is providing the ETH. Otherwise you would have to use WETH which has the transferFrom capability.</p> <p>Encoded order</p> <pre><code>{\n  \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\",\n  \"makeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"100000000000000000\" },\n  \"taker\": \"0x0000000000000000000000000000000000000000\",\n  \"takeAsset\": {\n    \"assetType\": {\n      \"assetClass\": \"0x73ad2146\",\n      \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000005\"\n    },\n    \"value\": \"1\"\n  },\n  \"salt\": \"0\",\n  \"start\": \"0\",\n  \"end\": \"0\",\n  \"dataType\": \"0x4c234266\",\n  \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n}\n</code></pre> <p>Example transaction that has both a signed sell order and an unsigned buy order, submitted by the buyer.</p>","title":"Pay ETH for ERC721"},{"location":"ethereum/exchange/accepting-a-buy-order/#bid-orders","text":"<p>A bid is just an unmatched buy order. The bidder submits the order to the indexer, like shown in </p> <p>Creating a sell order. The seller accepts it by creating a matched order.</p>","title":"Bid Orders"},{"location":"ethereum/exchange/contract-wallets/","text":"<p>Example implementation: https://rinkeby.etherscan.io/address/0x998Cf6fDd7FF1EB258c288762284142D28D0ee39#code</p> <p>EIP1271 allows a contract to delegate authorized signers. Usually EIP1271 expects an authorized delegate to submit a signature via the contract, and uses typical ECrecover to see if the signature is valid.</p> <p>EIP1271 returns <code>valid signature: true**</code> if the signature is valid &amp; the signer is authorized by the contract</p> <p>** not actually <code>true</code>, but instead a magic value to guard against mistaken 'true' bit</p> <p>The Rarible contract checks if the signature is valid with the following code</p> <pre><code>    require(\n        ERC1271(order.maker).isValidSignature(_hashTypedDataV4(hash), signature) == MAGICVALUE,\n        \"contract order signature verification error\"\n    );\n</code></pre>","title":"Contract Wallets"},{"location":"ethereum/exchange/creating-a-sell-order/","text":"","title":"Creating A Sell Order"},{"location":"ethereum/exchange/creating-a-sell-order/#creating-an-order","text":"<p>Step 1. Approval</p> <p>We need to call approval on the transfer proxy contract.</p> <p>{% hint style=\"danger\" %} The approval on the transfer proxy only needs to be called if a previous approval does not exist.</p> <p>Step 2. Creating signature</p>","title":"Creating an order"},{"location":"ethereum/exchange/creating-a-sell-order/#sell-erc721-for-eth","text":"<p>You can only fill an ETH order if your side of the order is providing the ETH. Otherwise you would have to use WETH which has the transferFrom capability.</p> <p>First Encode the order for signing</p> <p>POST to <code>https://ethereum-api-staging.rarible.org/v0.1/order/encoder/order</code></p> <pre><code>{\n    \"type\": \"RARIBLE_V2\",\n    \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\",\n    \"make\": {\n        \"assetType\": {\n            \"assetClass\": \"ERC721\",\n            \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\",\n            \"tokenId\": 1\n        },\n        \"value\": \"1\"\n    },\n    \"take\": {\n        \"assetType\": {\n            \"assetClass\": \"ETH\"\n        },\n        \"value\": \"1000000000000000000\"\n    },\n    \"data\": {\n        \"dataType\": \"RARIBLE_V2_DATA_V1\",\n        \"payouts\": [],\n        \"originFees\": []\n    },\n    \"salt\": \"3621\"\n}\n</code></pre> <p>Response:</p> <pre><code>{\n    \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\",\n    \"makeAsset\": {\n        \"assetType\": {\n            \"assetClass\": \"0x73ad2146\",\n            \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000001\"\n        },\n        \"value\": \"1\"\n    },\n    \"taker\": \"0x0000000000000000000000000000000000000000\",\n    \"takeAsset\": {\n        \"assetType\": {\n            \"assetClass\": \"0xaaaebeba\",\n            \"data\": \"0x\"\n        },\n        \"value\": \"1000000000000000000\"\n    },\n    \"salt\": \"3621\",\n    \"start\": \"0\",\n    \"end\": \"0\",\n    \"dataType\": \"0x4c234266\",\n    \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\"\n}\n</code></pre> <p>Then Sign the order</p> <pre><code>async function sign(provider, order, account, verifyingContract) {\n    const chainId = Number(provider._network.chainId);\n    const data = EIP712.createTypeData({\n        name: \"Exchange\",\n        version: \"2\",\n        chainId,\n        verifyingContract\n    }, 'Order', order, Types);\n  console.log({data})\n    return (await EIP712.signTypedData(provider, account, data)).sig;\n}\n</code></pre> <p>Step 3. Send order with signature to our API</p> <p>POST to <code>https://ethereum-api-staging.rarible.org/v0.1/order/orders</code></p> <p>Payload</p> <pre><code>{\n    \"type\": \"RARIBLE_V2\",\n    \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\",\n    \"make\": {\n        \"assetType\": {\n            \"assetClass\": \"ERC721\",\n            \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\",\n            \"tokenId\": 1\n        },\n        \"value\": \"1\"\n    },\n    \"take\": {\n        \"assetType\": {\n            \"assetClass\": \"ETH\"\n        },\n        \"value\": \"1000000000000000000\"\n    },\n    \"data\": {\n        \"dataType\": \"RARIBLE_V2_DATA_V1\",\n        \"payouts\": [],\n        \"originFees\": []\n    },\n    \"salt\": \"5422\",\n    \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\"\n}\n</code></pre> <p>Response</p> <pre><code>{\n    \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\",\n    \"make\": {\n        \"assetType\": {\n            \"assetClass\": \"ERC721\",\n            \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\",\n            \"tokenId\": \"1\"\n        },\n        \"value\": \"1\"\n    },\n    \"take\": {\n        \"assetType\": {\n            \"assetClass\": \"ETH\"\n        },\n        \"value\": \"1000000000000000000\"\n    },\n    \"type\": \"RARIBLE_V2\",\n    \"fill\": \"0\",\n    \"makeStock\": \"1\",\n    \"cancelled\": false,\n    \"salt\": \"0x000000000000000000000000000000000000000000000000000000000000152e\",\n    \"data\": {\n        \"dataType\": \"RARIBLE_V2_DATA_V1\",\n        \"payouts\": [],\n        \"originFees\": []\n    },\n    \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\",\n    \"createdAt\": \"2021-05-25T02:04:28.836+00:00\",\n    \"lastUpdateAt\": \"2021-05-25T02:04:28.983+00:00\",\n    \"pending\": [],\n    \"hash\": \"0xc9cb92588fc1434a417f4cacb9e1267750e6f1cbe650988a6fdc1d0be8a310a9\",\n    \"makeBalance\": \"1\",\n    \"takePriceUsd\": 2735.1365826056253000000000000000000\n}\n</code></pre> <p>{% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for createOrUpdateOrder</p>","title":"Sell ERC721 for ETH"},{"location":"ethereum/exchange/exchange-overview/","text":"","title":"Exchange Overview"},{"location":"ethereum/exchange/exchange-overview/#asset-matching","text":"<p>The purpose of this is to validate that <code>makeAsset</code> of the left order matches <code>takeAsset</code> from the right order and vice versa. New types of assets can be added without a smart contract upgrade. This is done using a custom IAssetMatcher.</p> <p>There are possible improvements to the protocol using these custom matcher contracts such as:</p> <ul> <li>Support for parametric assets. For example, the user can put an order to exchange 10ETH for any NFT from a popular collection.</li> <li>Support for NFT bundles.</li> </ul> <p>The general process for completing an order with the Rarible Exchange is as follows:</p> <ol> <li>Seller approves the Rarible exchange contract to transfer NFT on their behalf</li> <li>Seller creates and signs an order. They specify the types and amounts of assets they would like in return.</li> <li>Seller submits the order to the indexer</li> <li>Potential buyers query the indexer to get sell orders for a specific item or collection</li> <li>Buyers can create a matching buy order for a sell order from the indexer. The buyer can then submit a matching buy order to the smart contract and execute the transfer (no sig required).</li> <li>Or the buyer can create a new bid and submit it to the indexer (requires signature)</li> <li>If the buyer submits a bid, the seller can choose to accept it by creating the matching sell order and submitting it to the contract, or they can send a signed order back to the buyer which the buyer would submit to the contract.</li> </ol>","title":"Asset matching"},{"location":"ethereum/exchange/exchange-overview/#order-structure","text":"<p>Each order (both buy &amp; sell) consist of a <code>makeAsset</code> and a <code>takeAsset</code></p> <p>Make Asset is what you are sending.</p> <ul> <li>In a buy order this is what you are paying for the seller's NFT. This can be ETH, ERC20, ERC721, ERC1155, or any custom asset using their Asset Matcher interface</li> <li>In a sell order this is the NFT you are selling</li> </ul> <p>Take Asset is what you are accepting in return</p> <ul> <li>In a buy order this is the NFT you are buying</li> <li>In a sell order this is what you are willing to accept. </li> </ul>","title":"Order Structure"},{"location":"ethereum/exchange/exchange-overview/#order","text":"Field Description Required     Maker Address of entity giving up <code>makeAsset</code> Yes   makeAsset Asset the entity is giving up Yes   taker Address of counterparty no, if 0 then anyone can fill the order   takeAsset Asset the entity is receving Yes   salt nonce for signatures submitted with the order Generally signatures are only needed if msg.sender != maker   start uint - order can't be filled before this time no   end uint - order can't be filled after this time no   dataType bytes4, usually hash of a string like v1 or v2 Yes   data generic <code>bytes</code>. Can be used for protocol extensions no","title":"Order"},{"location":"ethereum/exchange/exchange-overview/#asset","text":"Field Description Required     assetType Specifies ETH, specific ERC20, ERC721, ERC1155 Yes   value uint Yes","title":"Asset"},{"location":"ethereum/exchange/exchange-overview/#assettype","text":"Field Description Required     assetClass bytes4 specifies ETH, ERC20, ERC721 Yes   data bytes - generic data depending on tp. Ex. address for ERC20, token + tokenID for ERC721 yes","title":"AssetType"},{"location":"ethereum/exchange/exchange-overview/#asset-types","text":"<p>Asset Class data field is calculated as follows</p> <pre><code>    bytes4 constant public ETH_ASSET_CLASS = bytes4(keccak256(\"ETH\"));\n    bytes4 constant public ERC20_ASSET_CLASS = bytes4(keccak256(\"ERC20\"));\n    bytes4 constant public ERC721_ASSET_CLASS = bytes4(keccak256(\"ERC721\"));\n    bytes4 constant public ERC1155_ASSET_CLASS = bytes4(keccak256(\"ERC1155\"));\n</code></pre> <p>All asset types get encoded using these helper functions https://github.com/rariblecom/protocol-contracts/blob/master/exchange-v2/test/assets.js</p>","title":"Asset Types"},{"location":"ethereum/exchange/exchange-overview/#erc721","text":"<p><code>assetClass</code>: Truncated hash of string \"ERC721\" <code>data</code>: ABI encoded parameters of <code>address</code> and <code>tokenId</code> <code>value</code>: 1</p> <p>ERC721 Input (Pre encoding)</p> <pre><code>  {\n    assetType: {\n      assetClass: \"ERC721\",\n      token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\",\n      tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\"\n    },\n    value: \"1\",\n  }\n</code></pre>","title":"ERC721"},{"location":"ethereum/exchange/exchange-overview/#erc1155","text":"<p><code>assetClass</code>: Truncated hash of string \"ERC1155\" <code>data</code>: ABI encoded parameters of <code>address</code> and <code>tokenId</code> <code>value</code>: 1-&gt;totalSupply</p> <p>ERC1155 Input (Pre encoding)</p> <pre><code>  {\n    assetType: {\n      assetClass: \"ERC1155\",\n      token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\",\n      tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\"\n    },\n    value: \"100\",\n  }\n</code></pre>","title":"ERC1155"},{"location":"ethereum/exchange/exchange-overview/#erc20","text":"<p><code>assetClass</code>: Truncated hash of string \"ERC20\" <code>data</code>: ABI encoded parameters of <code>address</code> <code>value</code>: 1-&gt;totalSupply</p> <p>ERC20 Input (Pre encoding)</p> <pre><code>  {\n    assetType: {\n      assetClass: \"ERC20\",\n      token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\",\n    },\n    value: \"10000000000000000\",\n  }\n</code></pre>","title":"ERC20"},{"location":"ethereum/exchange/exchange-overview/#eth","text":"<p><code>assetClass</code>: Truncated hash of string \"ETH\" <code>data</code>: 0x <code>value</code>: 1-&gt;1e18</p> <p>Input (pre encoding)</p> <pre><code>  {\n    assetType: {\n      assetClass: \"ETH\"\n    },\n    value: \"10000000000000000\",\n  },\n</code></pre>","title":"ETH"},{"location":"ethereum/exchange/exchange-overview/#custom-asset-matcher","text":"<p>Any asset can be added</p> <p><code>assetClass</code>: Truncated hash of any string <code>data</code>: Whatever is relevant <code>value</code>: some uint</p>","title":"Custom Asset Matcher"},{"location":"ethereum/exchange/exchange-overview/#order-validation","text":"<ul> <li>Check the start/end date of the orders.</li> <li>Check if the taker of the order is blank or taker = <code>order.taker</code></li> <li>Check if the order is signed by its maker or maker of the order is executing the transaction.</li> <li>If the maker of the order is a contract, then an ERC-1271 check is performed.</li> </ul> <p>{% hint style=\"info\" %} Currently, only off-chain orders are supported, this part of the smart contract can be easily updated to support on-chain order books.</p>","title":"Order validation"},{"location":"ethereum/exchange/exchange-overview/#order-execution","text":"<p>Order execution is done by TransferManager. There are 2 variants:</p> <ul> <li>SimpleTransferManager (it simply transfers assets from maker to taker and vice versa).</li> <li>RaribleTransferManager (sophisticated version, it takes into account protocol commissions, royalties, etc).</li> </ul> <p>{% hint style=\"success\" %} There are plans to extend RaribleTransferManager to support more royalty schemes and add new features like custom fees, multiple order beneficiaries.</p> <p>This part of the algorithm can be extended with a custom ITransferExecutor. In the future, new executors will be added to support new asset types, for example, executor for handling bundles can be added.</p> <p>{% hint style=\"info\" %} Possible improvements:</p> <ul> <li>Support bundles.</li> <li>Support random boxes.</li> </ul>","title":"Order execution"},{"location":"ethereum/exchange/exchange-overview/#fees","text":"<p>RaribleTransferManager supports these types of fees:</p> <ul> <li>Protocol fees (These fees are taken from both sides of the deal).</li> <li>Origin fees (Origin and origin fee is set for every order. it can be different for two orders involved).</li> <li>Royalties (Authors of the work will receive part of each sale).</li> </ul> <p>Fees calculation, fee side</p> <p>To take a fee we need to calculate, what side of the deal can be used as money. There is a simple algorithm to do it:</p> <ul> <li>If ETH is from any side of the deal, it's used.</li> <li>If not, then if ERC-20 is in the deal, it's used.</li> <li>If not, then if ERC-1155 is in the deal, it's used.</li> <li>Otherwise, the fee is not taken (for example, two ERC-721 are involved in the deal).</li> </ul> <p>When we established, what part of the deal can be treated as money, then we can establish, that</p> <ul> <li>The Buyer is the side of the deal who owns the money.</li> <li>The Seller is the other side of the deal.</li> </ul> <p>Then the total amount of the asset (money side) should be calculated</p> <ul> <li>Protocol fee is added on top of the filled amount.</li> <li>The origin fee of the buyer's order is added on top too.</li> </ul> <p>If the buyer is using an ERC-20 token for payment, then he must approve at least this calculated amount of tokens.</p> <p>If the buyer is using ETH, then he must send this calculated amount of ETH with the transaction.</p>","title":"Fees"},{"location":"ethereum/exchange/order-discovery/","text":"","title":"Order Discovery"},{"location":"ethereum/exchange/order-discovery/#search-orders","text":"<p>Example of how to query orders for all NFTs in a collection</p> <pre><code>curl --location --request GET 'https://ethereum-api-staging.rarible.org/v0.1/order/orders/sell/byCollection?collection=0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575&amp;sort=LAST_UPDATE'\n</code></pre> <p>Response</p> <pre><code>{\n    \"orders\": [\n        {\n            \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\",\n            \"make\": {\n                \"assetType\": {\n                    \"assetClass\": \"ERC721\",\n                    \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\",\n                    \"tokenId\": \"1\"\n                },\n                \"value\": \"1\"\n            },\n            \"take\": {\n                \"assetType\": {\n                    \"assetClass\": \"ETH\"\n                },\n                \"value\": \"1000000000000000000\"\n            },\n            \"type\": \"RARIBLE_V2\",\n            \"fill\": \"0\",\n            \"makeStock\": \"1\",\n            \"cancelled\": false,\n            \"salt\": \"0x00000000000000000000000000000000000000000000000000000000000002b3\",\n            \"data\": {\n                \"dataType\": \"RARIBLE_V2_DATA_V1\",\n                \"payouts\": [],\n                \"originFees\": []\n            },\n            \"signature\": \"0xf45a9adfb58fdd9da808b5f80302ebdb7d75f032d6aaee9700ee93f567fff3b148116a93ad2bd908a2d8e9576295650460a653d442f7c3472cb8f1275739075e1c\",\n            \"createdAt\": \"2021-05-25T01:33:43.358+00:00\",\n            \"lastUpdateAt\": \"2021-05-25T01:33:43.532+00:00\",\n            \"pending\": [],\n            \"hash\": \"0x0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\",\n            \"makeBalance\": \"1\",\n            \"takePriceUsd\": 2735.136582605625300000000000000000\n        }\n    ],\n    \"continuation\": \"1621906423532_0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\"\n}\n</code></pre> <p>For more information on the order indexer and options for discoring orders, see the API Reference</p>","title":"Search orders"},{"location":"ethereum/exchange/updating-cancelling-an-order/","text":"","title":"Updating/Canceling an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#updating-an-order","text":"<p>To update an order we need to make the changes and send a POST request to the API this can be found on the Creating A Sell Order page.</p> <p>New Orders check the Start, End, taker, make and value. If any of these are invalid you will receive a 400 response code from the API.</p> <p>{% hint style=\"danger\" %} The price can only be lowered and not increased, to increase the price you will need to cancel the order and create a new one.</p>","title":"Updating an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#canceling-an-order","text":"<p>Canceling an order needs to be done on-chain by calling the cancel method on the exchange contract.</p> <pre><code>function cancel(LibOrder.Order memory order) public {\n require(_msgSender() == order.maker, \"not a maker\");\n bytes32 orderKeyHash = LibOrder.hashKey(order);\n fills[orderKeyHash] = UINT256_MAX;\n emit Cancel(orderKeyHash);\n}\n</code></pre>","title":"Canceling an Order"},{"location":"ethereum/metadata/ethereum-metadata/","text":"<p>Providing Assets Metadata allows applications to extract data for digital assets and display them in an application.</p> <p>URIs usually represent digital assets in a smart contract. Metadata allows assets to have additional properties, such as name, description, and image.</p>","title":"Ethereum Metadata"},{"location":"ethereum/metadata/ethereum-metadata/#tokenuri","text":"<p>To get metadata for ERC-721 and ERC-1155, you need to return the URI. To do this, use the function:</p> <ul> <li><code>tokenURI</code> in ERC-721</li> <li><code>uri</code> in ERC-1155.</li> </ul> <p>ERC-721</p> <pre><code>    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length &gt; 0) {\n            return LibURI.checkPrefix(base, _tokenURI);\n        }\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\n        return string(abi.encodePacked(base, tokenId.toString()));\n    }\n</code></pre> <p>ERC-1155</p> <pre><code>    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) external view virtual override returns (string memory) {\n        return _uri;\n    }\n</code></pre> <p>The <code>tokenURI</code> or <code>uri</code> function returns an HTTP or IPFS URL. When requesting the URL, JSON with metadata for the token should be returned.</p>","title":"tokenURI"},{"location":"ethereum/metadata/ethereum-metadata/#metadata-structure","text":"<p>The Rarible Ethereum Protocol supports the Metadata structure according to the standards EIP-721 and EIP-1155.</p> <p>Example of a Metadata structure for ERC-1155 NFT:</p> <pre><code>{\n    \"name\": \"CryptoParrot#17\",\n    \"description\": \"The CryptoParrot is a collection of 10,000 unique Parrot NFTs\",\n    \"attributes\": [\n        {\n            \"key\": \"/background\",\n            \"value\": \"rust\"\n        },\n        {\n            \"key\": \"/body\",\n            \"value\": \"lavender down\"\n        },\n        {\n            \"key\": \"/color\",\n            \"value\": \"gray\"\n        },\n        {\n            \"key\": \"/eye\",\n            \"value\": \"small 1\"\n        },\n        {\n            \"key\": \"/head\",\n            \"value\": \"navy blue nightcap\"\n        },\n        {\n            \"key\": \"/mouth\",\n            \"value\": \"yellow 6\"\n        }\n    ],\n    \"image\": {\n        \"url\": {\n            \"ORIGINAL\": \"ipfs://ipfs/QmUoc2LDDnHxHsesLXtpxTLupzVuyfVkJomWWHmvKNCjrL/image.png\"\n        },\n        \"meta\": {\n            \"ORIGINAL\": {\n                \"type\": \"image/png\",\n                \"width\": 999,\n                \"height\": 999\n            }\n        }\n    }\n}\n</code></pre> <p>Description of properties:</p>    name  Name of the item     description  A human-readable description of the item   attributes key, value These are the attributes for the item   image url This is the URL to the image of the item    meta This is meta-information about media. Include type, width, and height   animation url This is the URL to the animation of the item    meta This is meta-information about media. Include type, width, and height    <p>For the Rarible Ethereum Protocol, it does not matter where the Metadata for NFT will be placed. See the example of uploading and using metadata with IPFS.</p>","title":"Metadata Structure"},{"location":"ethereum/metadata/ipfs-example/","text":"","title":"Example of uploading &amp; using Metadata with IPFS"},{"location":"ethereum/metadata/ipfs-example/#uploading-images-to-ipfs","text":"<p>To upload images to IPFS, will use the Pinata service.</p> <p>Here you can see an example using Node JS to upload an image using the Pinata API.</p> <pre><code>const axios = require(\"axios\");\nconst fs = require(\"fs\");\nconst FormData = require(\"form-data\");\n\nexport const pinFileToIPFS = (pinataApiKey, pinataSecretApiKey) =&gt; {\n  const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS`;\n  let data = new FormData();\n\n  data.append(\"file\", fs.createReadStream(\"./yourfile.png\"));\n\n  return axios.post(url, data, {\n      headers: {\n        \"Content-Type\": `multipart/form-data; boundary= ${data._boundary}`,\n        pinata_api_key: pinataApiKey,\n        pinata_secret_api_key: pinataSecretApiKey,\n      },\n    })\n    .then(function (response) {\n      console.log(repsonse.IpfsHash);\n    })\n    .catch(function (error) {\n      console.log(error)\n    });\n};\n</code></pre> <p>Response to the request:</p> <pre><code>{\n    IpfsHash: // This is the IPFS multi-hash provided back for your content,\n    PinSize: // This is how large (in bytes) the content you just pinned is,\n    Timestamp: // This is the timestamp for your content pinning (represented in ISO 8601 format)\n}\n</code></pre>","title":"Uploading images to IPFS"},{"location":"ethereum/metadata/ipfs-example/#creating-a-metadata-file-for-nft","text":"<p>With the <code>IpfsHash</code>, we can create a Metadata file. It will be connected to the NFT inside the blockchain network.</p> <pre><code>{\n   \"name\": /* NFT Name - This must be a string */,\n   \"description\": /* Description of the NFT - This must be a string */,\n   \"image\": /*  IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */,\n   \"external_url\": /* This is the link to Rarible which we currently don't have, we can fill this in shortly */,\n   \"animation_url\": /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */,\n   // the below section is not needed.\n   \"attributes\": [\n      {\n         \"key\": /* Key name - This must be a string */,\n         \"trait_type\": /* Trait name - This must be a string */,\n         \"value\": /* Key Value - This must be a string */\n      }\n   ]\n}\n</code></pre>","title":"Creating a Metadata file for NFT"},{"location":"ethereum/metadata/ipfs-example/#adding-generated-metadata-to-ipfs","text":"<ol> <li> <p>Specify <code>external_url</code> in the format <code>${contractAddress}:${tokenId}</code>, for example:</p> <pre><code>\"external_url\": \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\"\n</code></pre> </li> <li> <p>Publish Metadata to IPFS:</p> <pre><code>var axios = require('axios');\nvar data = JSON.stringify({\"name\":\"Test NFT\",\"description\":\"Test NFT\",\"image\":\"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\",\"external_url\":\"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\",\"attributes\":[{\"key\":\"Test\",\"trait_type\":\"Test\",\"value\":\"Test\"}]});\n\nvar config = {\n  method: 'post',\n  url: 'https://api.pinata.cloud/pinning/pinFileToIPFS',\n  headers: { \n    'pinata_api_key': // KEY_HERE, \n    'pinata_secret_api_key': // SECRET_KEY_HERE, \n    'Content-Type': 'application/json'\n  },\n  data: data\n};\n\naxios(config).then(function (response) {\n  console.log(JSON.stringify(response.data));\n}).catch(function (error) {\n  console.log(error);\n});\n</code></pre> <p>Response example:</p> <pre><code>{\n    \"IpfsHash\": \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\",\n    \"PinSize\": 290,\n    \"Timestamp\": \"2021-02-10T14:06:09.255Z\"\n}\n</code></pre> </li> <li> <p>Attach the new <code>IpfsHash</code> to your NFT.</p> </li> </ol>","title":"Adding generated Metadata to IPFS"},{"location":"ethereum/sdk/ethereum-sdk/","text":"<p>Rarible Protocol Ethereum SDK enables apps to easily interact with Rarible protocol.</p> <p>Take a look at this sample app with React for a quick start.</p>","title":"Ethereum SDK"},{"location":"ethereum/sdk/ethereum-sdk/#installation","text":"<pre><code>npm install -D @rarible/protocol-ethereum-sdk\n</code></pre> <p>or inject package into your web page with web3 instance</p> <pre><code>&lt;script src=\"https://unpkg.com/@rarible/web3-ethereum@0.10.0/umd/rarible-web3-ethereum.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"https://unpkg.com/@rarible/protocol-ethereum-sdk@0.10.0/umd/rarible-ethereum-sdk.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;script src=\"https://unpkg.com/web3@1.6.0/dist/web3.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n</code></pre>","title":"Installation"},{"location":"ethereum/sdk/ethereum-sdk/#usage-with-web3js","text":"","title":"Usage with web3.js"},{"location":"ethereum/sdk/ethereum-sdk/#configure-and-create-rarible-sdk-object","text":"<pre><code>import { createRaribleSdk } from \"@rarible/protocol-ethereum-sdk\"\n\nconst sdk = createRaribleSdk(web3, env, { fetchApi: fetch })\n</code></pre> <ul> <li>web3 - configured with your provider web3js client</li> <li>env - environment configuration name, it should accept one of these values <code>ropsten</code>, <code>rinkeby</code>, <code>mainnet</code> or <code>e2e</code></li> </ul>","title":"Configure and create Rarible SDK object"},{"location":"ethereum/sdk/ethereum-sdk/#configure-rarible-sdk-in-browser","text":"<pre><code>const web = new Web3(ethereum)\nconst web3Ethereum = new window.raribleWeb3Ethereum.Web3Ethereum({ web3: web })\nconst env = \"mainnet\" // \"e2e\" | \"ropsten\" | \"rinkeby\" | \"mainnet\"\nconst raribleSdk = new window.raribleEthereumSdk.createRaribleSdk(web3Ethereum, env)\n</code></pre> <ul> <li>ethereum - metamask browser instance (window.ethereum)</li> </ul> <p>For more information on using the Rarible Protocol Ethereum SDK, see the page Protocol Ethereum SDK on GitHub.</p>","title":"Configure Rarible SDK in browser"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/","text":"<p>The main function of ExchangeV2 is matchOrders. This function takes two sides of an order and attempts to match them.</p> <p>The matching order process can be divided into stages:</p> <ol> <li>Order Validation \u2014 checks if the order parameters are valid and the caller is authorized to execute the order.</li> <li>Asset Matching \u2014 checks the assets from left &amp; right order match and then extracts the matching assets.</li> <li>Calculating Fill \u2014 checks and finds out what exact values should be filled. Orders can also be matched partly. This occurs if one of the sides doesn't want to fill other orders completely.</li> <li>Order Execution, Transfers - execute the transfers of the assets, saving Order filling if necessary.</li> </ol> <p></p>","title":"ExchangeV2 Matching Orders"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#order-validation","text":"<ol> <li>Check the start/end date of the order.</li> <li>Check whether the receiver of this order is empty or the receiver is the same as order.taker.</li> <li>Check whether the order is signed by its creator or the creator of the order performs a transaction.</li> <li>If the creator of the order is a contract, then an ERC-1271 check is performed.</li> </ol> <p>Currently, only orders outside the blockchain network are supported. This part of the smart contract can be easily updated to support Order Book on-chain.</p>","title":"Order Validation"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#asset-matching","text":"<p>The main goal is to check that makeAsset (left) matches takeAsset (right) and vice versa.</p> <p>makeAsset is what you sell.</p> <ul> <li>The purchase order is what you pay for the seller's NFT. It can be ERC-20, ERC-721, ERC-1155, or any custom resource that uses the asset mapping interface.</li> <li>The sales order is the NFT that you are selling.</li> </ul> <p>takeAsset is what you accept in return.</p> <ul> <li>The purchase order is the NFT that you are buying.</li> <li>The sales order is what you are willing to accept.</li> </ul> <p>New asset types can be added without updating the smart contract. You can do it with a custom IAssetMatcher.</p> <p>Possible improvements:</p> <ul> <li>Support for parametric assets. For example, a user can place an order to exchange 10 ETH for any NFT from a popular collection.</li> <li>Support for NFT packages.</li> </ul>","title":"Asset Matching"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#calculating-fill-and-order-execution","text":"<p>The order fill is stored inside the smart contract and refers to the taking part of the order. Fill is stored inside the mapping slot, the key to which is calculated using the fields:</p> <ul> <li>maker</li> <li>make asset type</li> <li>take asset type</li> <li>salt</li> </ul> <p>Fill orders that differ only in the exchange rate are stored in one mapping slot.</p> <p>In addition, full filled orders can be expanded: users can sign new orders using the same salt. For example, they can increase make.value and take.value.</p> <p>Priority of the order rate \u2014 if the exchange rates differ, but orders can be filled (for example, the left order is 10X -&gt; 100Y, and the right one is 100Y -&gt; 5X), then the part on the left determines the exchange rate.</p> <p>Rounding errors \u2014 mathematical operations calculate the filling volumes. When rounding is performed and the error exceeds 0.1%, a rounding error will be issued, and the order will not be executed.</p>","title":"Calculating Fill and Order Execution"},{"location":"ethereum/smart-contracts/exchangev2-matching-orders/#transfer-execution","text":"<p>Transfers are made using Transfer Manager:</p> <ul> <li>SimpleTransferManager - transfers assets from maker to taker and vice versa.</li> <li>RaribleTransferManager - is a complex version. It takes into account protocol commissions, royalties, etc.</li> </ul> <p>It is planned to expand the RaribleTransferManager to support more royalty schemes and add new features. For example, user fees or multiple order recipients.</p> <p>This part of the algorithm can be extended using ITransferExecutor. It will be added new executors to support new asset types. For example, an executor may be added to process packages.</p> <p>Possible improvements:</p> <ul> <li>Package support.</li> <li>Support for random boxes.</li> </ul>","title":"Transfer Execution"},{"location":"ethereum/smart-contracts/exchangev2-overview/","text":"<p>ExchangeV2 is a smart contract for the decentralized exchange of any assets represented in the Ethereum blockchain (or EVM compatible).</p> <p>To make an exchange two orders are required:</p> <ol> <li>Sale Order \u2014 Created by the seller.</li> <li>Purchase Order \u2014 Bid made by the buyer.</li> </ol> <p>The exchange occurs if the two orders above match.</p> <p>The general process of creating and executing an order is as follows:</p> <ol> <li>The seller confirms that the exchange contract can dispose of their assets/tokens.</li> <li>The seller creates and signs an order. Specifies the types and amounts of assets they want to receive in return.</li> <li>The seller sends the order to the indexer.</li> <li>The buyer sends an indexer request to get an order for a specific item or collection.</li> <li>The buyer creates a bid.</li> <li>If the order and bid are matched, an exchange takes place.</li> <li>If the order and bid do not match, then the seller can accept the Bid or not. If it accepts, then an exchange takes place.</li> </ol> <p>The order can be signed or not. The signature may be missing if the transaction is executed by the person who created this order.</p> <p></p> <p>See more information about:</p> <ul> <li>ExchangeV2 Matching Orders</li> <li>ExchangeV2 Sell and Bid</li> <li>ExchangeV2 Update and Cancel</li> </ul>","title":"ExchangeV2 Overview"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/","text":"","title":"ExchangeV2 Sell and Bid"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#sell-order","text":"<p>To create a Sell Order, use the Ethereum SDK:</p> <ol> <li>Check that the exchange contract can dispose of assets, tokens. Call setApprovalForAll if necessary.</li> <li>Create a signature:<ol> <li>Encrypt the order for signing.</li> <li>Sign the order.</li> </ol> </li> <li>Send the signed order to the API.</li> </ol> <p>Example of creating a Sell Order in SDK.</p>","title":"Sell Order"},{"location":"ethereum/smart-contracts/exchangev2-sell-bid/#bid","text":"<p>To make a purchase or accept a Bid, send a transaction to the matchOrders function of the contract ExchangeV2.</p> <p>matchOrders function has parameters:</p> <ul> <li>left order</li> <li>left order signature</li> <li>right order</li> <li>right order signature</li> </ul> <p>Example of creating a Bid in SDK.</p>","title":"Bid"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/","text":"","title":"ExchangeV2 Update and Cancel"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#update","text":"<p>To update the order:</p> <ol> <li>Make changes.</li> <li>Send a request to the API (see Sell Order).</li> </ol> <p>New orders check the: start, end, take, make and value fields.</p> <p>The price can only be reduced. You will need to cancel the order and create a new one to increase the price. Since if the user has already signed a message with a lower price, someone could save this message and signature. You can't cancel it without contacting the contract.</p>","title":"Update"},{"location":"ethereum/smart-contracts/exchangev2-update-cancel/#cancel","text":"<p>To cancel the order, call the cancellation method in the ExchangeV2 contract.</p> <pre><code>function cancel(LibOrder.Order memory order) public {\n require(_msgSender() == order.maker, \"not a maker\");\n bytes32 orderKeyHash = LibOrder.hashKey(order);\n fills[orderKeyHash] = UINT256_MAX;\n emit Cancel(orderKeyHash);\n}\n</code></pre> <p>An error will be returned when matching such an order.</p> <p>Orders makers can only call this function. It marks orders that cannot be filled.</p>","title":"Cancel"},{"location":"ethereum/smart-contracts/fees/","text":"<p>RaribleTransferManager supports the following types of fees:</p> <ul> <li>Protocol fees \u2014 are charged on both sides of the transaction.</li> <li>Origin fees \u2014 set for each order. It may differ for two orders.</li> <li>Royalties \u2014 the author of the work will receive a part of each sale.</li> </ul>","title":"Fees"},{"location":"ethereum/smart-contracts/fees/#algorithm","text":"<p>The transfer of assets takes place inside the <code>doTransfers</code>. The following parameters are used as arguments:</p> <ul> <li><code>LibAsset.AssetType</code> <code>makeMatch</code> \u2014 <code>AssetType</code> on the make-side order</li> <li><code>LibAsset.AssetType</code> <code>takeMatch</code> \u2014 <code>AssetType</code> on the take-side order</li> <li><code>LibFill.FillResult</code> <code>fill</code> \u2014 values on both sides that will be passed by match</li> <li><code>LibOrder.Order</code> <code>leftOrder</code> \u2014 left order data</li> <li><code>LibOrder.Order</code> <code>rightOrder</code> \u2014 right order data</li> </ul> <p>In this method, the following actions are performed.</p>","title":"Algorithm"},{"location":"ethereum/smart-contracts/fees/#how-do-we-calculate-the-commission-side-of-the-transaction","text":"<ol> <li>Use <code>LibFeeSide.getFeeSide</code>. It takes as arguments <code>assetClasses</code> of both sides (for example, <code>ETH</code> and <code>ERC20</code>).</li> <li><code>LibFeeSide.getFeeSide</code> tries to determine side to pay fees:</li> </ol> <p></p> <ul> <li>If there is ETH on any side of the transaction, it is used.</li> <li>If there is no ETH, we check if there is an ERC-20 and use it.</li> <li>If there is no ERC-20, check if there is an ERC-1155 and use it.</li> <li>Otherwise, no fee will be charged. (e.g. if two ERC-721 are involved in the transaction)</li> </ul>","title":"How do we calculate the commission side of the transaction?"},{"location":"ethereum/smart-contracts/fees/#transfer","text":"<ol> <li>If the make-side pays fees:<ul> <li>calling <code>doTransfersWithFees</code> for the make-side</li> <li>calling <code>transferPayouts</code> for the take-side</li> </ul> </li> <li>If the take-side pays fees:<ul> <li>calling <code>doTransfersWithFees</code> for the take-side</li> <li>calling <code>transferPayouts</code> for the make-side</li> </ul> </li> <li>If the side for the payment of fees are not defined:<ul> <li>call <code>transferPayouts</code> for both sides</li> </ul> </li> </ol> <p>When computing the total amount of the asset:</p> <ul> <li>The protocol fee is added on top of the filled amount.</li> <li>The fee for sending the buyer's order is also added on top.</li> </ul> <p>If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens.</p> <p>If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction.</p> <p>For more information about fees, see the page RaribleTransferManager on GitHub.</p>","title":"Transfer"},{"location":"ethereum/smart-contracts/royalties/","text":"","title":"Royalties"},{"location":"ethereum/smart-contracts/royalties/#royalties-v2","text":"<p>Rarible defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts.</p> <p>It exposes <code>getRoyalties</code> method, which expects an ID as input (usually tokenId) and returns an array of accounts &amp; basis points.</p> <pre><code>function getRaribleV2Royalties(uint256 id) override external view returns (LibPart.Part[] memory) {\n        return royalties[id];\n}\n</code></pre>","title":"Royalties V2"},{"location":"ethereum/smart-contracts/royalties/#royalties-v1","text":"<p>The exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry. The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array.</p> <p>This allows for Rarible to support different royalty standards for different collections.</p> <p>Rarible Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function.</p> <p>This tuple is made up of two variables, fees.recipient and fees.value.</p> <ul> <li>fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received.</li> <li>fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here.</li> </ul> <p>Below you can find the code block from ExchangeV1, which handles the on-chain royalties.</p> <pre><code>contract HasSecondarySaleFees is ERC165 {\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\n    /*\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\n     *\n     * =&gt; 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\n     */\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\n    constructor() public {\n        _registerInterface(_INTERFACE_ID_FEES);\n    }\n    function getFeeRecipients(uint256 id) public view returns (address payable[] memory);\n    function getFeeBps(uint256 id) public view returns (uint[] memory);\n}\n</code></pre>","title":"Royalties V1"},{"location":"ethereum/smart-contracts/royalties/#examples","text":"<ul> <li>Setting Up Royalties on an External Collection</li> </ul>","title":"Examples"},{"location":"ethereum/smart-contracts/smart-contracts/","text":"<p>Rarible Smart Contracts for Ethereum consist of:</p> <ul> <li>Exchange V2 \u2014 purchase and sale of tokens</li> <li>Tokens, TokenFactories \u2014 tokens contracts and Token Factories</li> <li>RoyaltiesRegistry \u2014 embedded royalties in NFT</li> <li>RoyaltiesProviders \u2014 commissions getting from individual contracts</li> <li>TransferProxy \u2014 token exchange according of the type</li> <li>Betting \u2014 tokens deposit in exchange for raising points. That makes it possible to take an active part in solving DAO issues</li> <li>Auctions \u2014 fixed-bid auction</li> <li>OnChainOrders \u2014 will be added to ExchangeV2 soon</li> </ul> <p>Let's look closer at the following components:</p> <ul> <li>Exchange V2</li> <li>Tokens</li> <li>Fees</li> <li>Royalties</li> </ul> <p>For more information on using Rarible Smart Contracts, see the page Protocol Contracts on GitHub.</p>","title":"Smart Contracts Overview"},{"location":"ethereum/smart-contracts/tokens/","text":"<p>Rarible Protocol Ethereum supports two types of tokens:</p> <ul> <li>ERC-721 is a standard interface for non-interchangeable tokens. This type of token is unique and may have a value different from the value of another token from the same smart contract.</li> <li>ERC-1155 is a standard interface for contracts that manage multiple types of tokens. One deployed contract can include any combination of interchangeable tokens, non-interchangeable tokens, or other configurations.</li> </ul> <p>You can mint both types of tokens as follows:</p> <ul> <li>A regular minting in a blockchain network using a contract.</li> <li>Lazy minting \u2014 minting of the token occurs outside the blockchain network. Entry into the blockchain and payment for gas is made when the token is purchased or transferred.</li> </ul> <p>Users can create tokens in different smart contracts.</p> <p>Tokens also support saving information about Royalties and information about all creators.</p>","title":"Tokens"},{"location":"ethereum/smart-contracts/tokens/#token-factories","text":"<p>To create ERC-721 and ERC-1155 smart contracts, use our Token Factories. The addresses are available on the Contract Addresses page.</p> <p>Using Token Factories, you can create the following types of smart contracts:</p> <ul> <li>Public ERC-721 and ERC-1155</li> <li>Private ERC-721 and ERC-1155</li> </ul> <p>Token Factories create beacon proxy servers. Rarible Protocol can automatically update these contracts when all token contracts are updated.</p>","title":"Token Factories"},{"location":"ethereum/smart-contracts/tokens/#minting","text":"<p>Minting is using the <code>mintAndTransfer</code> function for ERC-721 and ERC-1155 contracts.</p> <p>For ERC-721, the function has the following signature:<code>mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to)</code>.</p> <pre><code>struct Mint721Data {\n        uint tokenId;\n        string tokenURI;\n        address[] creators;\n        LibPart.Part[] royalties;\n        bytes[] signatures;\n}\n</code></pre> <ul> <li>tokenId \u2014 tokenId of the ERC-721 standard</li> <li>tokenURI \u2014 suffix for the token URI. The prefix is usually <code>ipfs:/</code></li> <li>creators \u2014 an array of authors addresses</li> <li>royalties \u2014 royalty array</li> <li>signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction.</li> </ul> <p>For ERC-1155, the function has the following signature: <code>mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount)</code>.</p> <pre><code>struct Mint1155Data {\n        uint tokenId;\n        string tokenURI;\n        uint supply;\n        address[] creators;\n        LibPart.Part[] royalties;\n        bytes[] signatures;\n}\n</code></pre> <ul> <li>tokenId \u2014 tokenId of the ERC-1155 standard</li> <li>tokenURI \u2014 suffix for the token URI. The prefix is usually <code>ipfs:/</code></li> <li>supply \u2014 total number of tokens for minting</li> <li>creators \u2014 an array of authors addresses</li> <li>royalties \u2014 royalty array</li> <li>signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction.</li> </ul>","title":"Minting"},{"location":"ethereum/smart-contracts/tokens/#lazy-minting","text":"<p></p> <p>Lazy Minting is supported for ERC-721 and ERC-1155.</p> <p>To create Lazy Minting:</p> <ol> <li>Generate a token ID.</li> <li>Create a Lazy Minting request body that the creator must sign.</li> <li>The creator signs the provided data.</li> <li>Add signature to the request body</li> <li>Send the data to the API.</li> </ol> <p>See an example of creating Lazy Minting by using API.</p> <p>For more information about Lazy Minting, see SDK page. </p>","title":"Lazy Minting"},{"location":"ethereum/smart-contracts/tokens/#transfer","text":"<p>This function transfers the token from the sender to the new owner.</p> <p>Arguments:</p> <ul> <li>owner: Address \u2014 address of the asset owner</li> <li>asset: Asset \u2014 asset type</li> </ul> <p>The function checks the asset type and performs one of the following functions:</p> <ul> <li>transferErc721</li> <li>transferErc1155</li> </ul> <p>transferErc1155 arguments:</p> <pre><code>export async function transferErc1155(\n    ethereum: Ethereum,\n    send: SendFunction,\n    contract: Address,\n    from: Address,\n    to: Address,\n    tokenId: string | string[],\n    tokenAmount: string | string[]\n</code></pre> <ul> <li>contract: Address \u2014 contract address ERC-1155</li> <li>from: Address \u2014 address of the ERC-1155 token owner</li> <li>to: Address \u2014 address of the new owner</li> <li>tokenId: string | string[] \u2014 token ID or token array for transfer</li> <li>tokenAmount: string | string[] \u2014 number of ERC-1155 tokens or an array of tokens for transfer</li> </ul> <p>transferErc721 arguments:</p> <pre><code>export async function transferErc721(\n    ethereum: Ethereum,\n    send: SendFunction,\n    contract: Address,\n    from: Address,\n    to: Address,\n    tokenId: string\n</code></pre> <ul> <li>contract: Address \u2014 contract address ERC-721</li> <li>from: Address \u2014 address of the ERC-721 token owner</li> <li>to: Address \u2014 address of the new owner</li> <li>tokenId: string | string[] \u2014 token ID for transfer</li> </ul>","title":"Transfer"},{"location":"ethereum/smart-contracts/tokens/#deploy","text":"<p>TODO</p>","title":"Deploy"},{"location":"ethereum/smart-contracts/tokens/#burn","text":"<p>To Burn a token, call the function:</p> <pre><code>const hash = await sdk.nft.burn({\n    contract: contractAddress,\n    tokenId: toBigNumber(tokenId),\n})\n</code></pre> <ul> <li>contract \u2014 smart contract address</li> <li>tokenId \u2014 token identifier</li> </ul>","title":"Burn"},{"location":"flow/flow-overview/","text":"<p>Rarible is currently testing this integration, aiming to release it between 8th and the 12nd of November.</p> <p>Support for the Flow blockchain was built by the Rarible team:</p> <ul> <li>smart contracts: https://github.com/rarible/flow-contracts</li> <li>indexer: https://github.com/rarible/flow-nft-indexer</li> <li>SDK: https://github.com/rarible/flow-sdk</li> </ul>","title":"Flow overview"},{"location":"getting-started/protocol-example/","text":"<p>Start with Rarible Protocol SDK.</p> <p>Also, you can create a Protocol Example App for a quick start.</p> <p>In this example, you can:</p> <ul> <li>Configure Rarible SDK</li> <li>Create Lazy mint NFT item</li> <li>Create sell order</li> <li>Purchase (buy item) an order</li> <li>Get your NFT from your current wallet</li> </ul> <p>Also, you can try scaffold-eth Rarible Starter App.</p>","title":"Example app"},{"location":"getting-started/protocol-example/#example-of-nft-purchase-flow","text":"<ol> <li>Click buy NFT in the app.</li> <li>The frontend calls the Buy function in the Union SDK.</li> <li>Union SDK calls the Buy function in the SDK of the desired network.</li> <li>SDK prepares and sends the transaction to the underlying blockchain.</li> <li>Indexer listens to purchase, transfer events, updates NFT state internally.</li> <li>Indexer transmits the event to Union.</li> <li>Union sends the information about the event to the backend of the application.</li> </ol> <p></p>","title":"Example of NFT purchase flow"},{"location":"overview/api-reference/","text":"<p>Use these base URLs to access our API on different networks.</p> <p><code>api.rarible.org or any testnet equivalent</code> is compatible with all blockchains  supported by the Rarirble Protocol. We also use the term union to describe this compatibility case in the docs. </p> <p><code>ethereum-api.rarible.org or any testnet equivalent</code> is only compatible with the ethereum blockchain.</p>","title":"API Reference"},{"location":"overview/api-reference/#mainnet","text":"Base URL Network     https://api.rarible.org/v0.1/doc Rarible Protocol   https://ethereum-api.rarible.org/v0.1/doc Ethereum   https://rarible-api-mainnet.functori.com/v0.1 Tezos","title":"Mainnet"},{"location":"overview/api-reference/#staging","text":"Base URL Network Testnet     https://api-staging.rarible.org/v0.1/doc Rarible Protocol Rinkeby   https://ethereum-api-staging.rarible.org/v0.1/doc Ethereum Rinkeby","title":"Staging"},{"location":"overview/api-reference/#development","text":"Base URL Network Testnet     https://api-dev.rarible.org/v0.1/doc Rarible Protocol Ropsten   https://ethereum-api-dev.rarible.org/v0.1/doc Ethereum Ropsten   https://rarible-api.functori.com/v0.1 Tezos Hangzhou","title":"Development"},{"location":"overview/api-reference/#e2e","text":"Base URL Network     https://api-e2e.rarible.org/v0.1/doc Rarible Protocol   https://ethereum-api-e2e.rarible.org/v0.1/doc Ethereum","title":"e2e"},{"location":"overview/glossary/","text":"<p>This document contains a glossary with an alphabetical list, definitions, and terms related to API.</p> <p>A  |  B  |  C  |  E  |  I  |  F  |  L  |  M  |  N  |  O  |  P  |  R  |  S  |  T</p>","title":"Glossary"},{"location":"overview/glossary/#a","text":"<p>API</p> <p>Application Programming Interface enables different systems to interact with each other programmatically.</p> <p>Activity</p> <p>Event history with orders or NFT tokens.</p> <p>Asset Type</p> <p>Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.).</p> <p>Asset Class</p> <p>Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.).</p>","title":"A"},{"location":"overview/glossary/#b","text":"<p>Bid</p> <p>Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it.</p> <p>Burn</p> <p>Burning NFT effectively destroys the token and removes it entirely from the blockchain.</p>","title":"B"},{"location":"overview/glossary/#c","text":"<p>Collection</p> <p>NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted.</p> <p>Continuation</p> <p>Continuation token from the previous response.</p> <p>Contract</p> <p>Address of the Smart Contract.</p> <p>Creator</p> <p>Address of the NFT item creator.</p>","title":"C"},{"location":"overview/glossary/#e","text":"<p>ERC-20</p> <p>The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token.</p> <p>ERC-721</p> <p>The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract.</p> <p>ERC-1155</p> <p>The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations.</p>","title":"E"},{"location":"overview/glossary/#i","text":"<p>Item</p> <p>Address of the NFT item. Id of the Item has format <code>${contract}:${tokenId}</code>.</p>","title":"I"},{"location":"overview/glossary/#f","text":"<p>Fee</p> <p>Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties.</p>","title":"F"},{"location":"overview/glossary/#l","text":"<p>Lazy Mint</p> <p>The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer.</p>","title":"L"},{"location":"overview/glossary/#m","text":"<p>Make</p> <p>Make the side of the Order. Make - what maker (order creator) has.</p> <p>Maker</p> <p>Creator of the order.</p> <p>Mint, Minting</p> <p>Minting is the act of publishing a unique instance of the token on the blockchain.</p>","title":"M"},{"location":"overview/glossary/#n","text":"<p>NFT</p> <p>Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art.</p>","title":"N"},{"location":"overview/glossary/#o","text":"<p>Origin Fee</p> <p>Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize.</p> <p>Owner</p> <p>Address of the NFT item owner.</p> <p>Ownership</p> <p>Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format <code>${contract}:${tokenId}:${owner}</code>.</p>","title":"O"},{"location":"overview/glossary/#p","text":"<p>Payouts</p> <p>Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users.</p> <p>Platform</p> <p>The platform where the order was created.</p>","title":"P"},{"location":"overview/glossary/#r","text":"<p>Royalties</p> <p>Fees that are usually paid to the creator on every sale.</p>","title":"R"},{"location":"overview/glossary/#s","text":"<p>Salt</p> <p>Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash.</p> <p>Smart Contract</p> <p>The programs stored on a blockchain that run when predetermined conditions are met.</p> <p>Supply</p> <p>Total number of tokens minted or to be minted.</p>","title":"S"},{"location":"overview/glossary/#t","text":"<p>Take</p> <p>Take the side of the order, what order creator wants to get in return for <code>make</code> side.</p> <p>Token ID</p> <p>Token identifier.</p>","title":"T"},{"location":"overview/reasons/","text":"<p>Rarible pursues the goal of creating a highly liquid environment for all NFTs out there: a robust on-chain protocol designed for NFTs to exist in a connected space. A separate initiative with a dedicated team will enable direct interactions with the protocol from multiple front ends like storefronts or wallets, offering additional distribution channels and enhancing liquidity. It will also fuel the discovery of new NFT trading mechanics.</p> <p>NFT protocol designed by Rarible for all, owned and governed by the community. In this regard, a special place in the initiative is reserved for Rarible native governance token $RARI as the basic building block for the future NFT ecosystem.</p>","title":"Why build on Rarible protocol?"},{"location":"overview/reasons/#supply-and-demand-of-the-whole-rarible-ecosystem","text":"<p>Rarible is one of the biggest NFT marketplaces out there with over $64 million in total lifetime volume and 57k monthly protocol users, slick UX, and a variety of use cases across industries. You can utilize the shared order book with Rarible.</p>","title":"Supply and demand of the whole Rarible ecosystem"},{"location":"overview/reasons/#advanced-and-robust-tech-done-for-you","text":"<p>Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years with wide functionality and data on all the NFTs created.</p>","title":"Advanced and robust tech done for you"},{"location":"overview/reasons/#monetization","text":"<p>Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.</p>","title":"Monetization"},{"location":"overview/reasons/#decentralized-autonomous-organization-dao","text":"<p>Rarible is steadily moving towards becoming a fully decentralized autonomous organization. The DAO will offer multiple opportunities for creators to get funding and exposure. It will incentivize people to build on top of the protocol, and we expect the DAO to reward the early builders.</p>","title":"Decentralized autonomous organization (DAO)"},{"location":"overview/resources/","text":"","title":"Resources"},{"location":"overview/resources/#dao","text":"<p>If you're a builder or you're looking to participate to the Rarible Protocol DAO here are a few useful places you'll find support and like-minded builders.</p> <ul> <li>Discord is one of the main places where the DAO is being organised, and builders take their first steps towards building with the protocol.</li> <li>Github is where everything lives, since we are open-source, a lot of resources and help from other builders are available there.</li> <li>Notion is the platform where we hold information for DAO members and $RARI token holders.</li> <li>OpenAPI is the place where we document the current API capabilities.</li> </ul>","title":"DAO"},{"location":"overview/resources/#submitting","text":"<p>You are welcome to suggest features and report bugs found! You can do it here:</p> <ul> <li>Submit an issue</li> <li>Submit a question or suggestion</li> </ul>","title":"Submitting"},{"location":"overview/resources/#hackathon-docs","text":"<p>Rarible Hackathon Docs HackMD by Isaac for Ethereum network.</p>","title":"Hackathon docs"},{"location":"overview/union-sdk/","text":"<p>Rarible Protocol Software Development Kit enables applications to interact with Rarible protocol easily: query, issue, trade NFTs on any blockchain supported.</p> <p>Currently, these blockchains are supported:</p> <ul> <li>Ethereum (mainnet, ropsten, rinkeby)</li> <li>Flow (currently on devnet only)</li> <li>Tezos (on granada testnet)</li> </ul>","title":"SDK Overview"},{"location":"overview/union-sdk/#installation","text":"<p>Using SDK should be fast, easy and intuitive - that's for what we're aiming for. Below you can see an example of implementation.</p> <ol> <li> <p>Install required packages using npm or yarn.</p> <p>For most of the projects, apart of the Rarible SDK we'll also need web3.</p> <pre><code>npm install -D @rarible/sdk\nnpm install web3\n</code></pre> <p>or using yarn</p> <pre><code>yarn add @rarible/sdk -D\nyarn add web3\n</code></pre> </li> <li> <p>Create a project with the JS framework of your choice (we'll be using NextJS here).</p> </li> </ol> <p>In order to properly set up the Rarible SDK we need to follow some standard web3 practices.</p> <ol> <li>Grab ethereum object out of the global window object.</li> <li>Use it to create a new instance of Web3.</li> <li>Create new instance of EthereumWallet class.</li> <li>Create Rarible SDK with a new instance of ethereumWallet, created in previous step.</li> </ol> <p>In code it looks like that (using TypeScript):</p> <pre><code>// Imports\nimport Web3 from \"web3\";\nimport { createRaribleSdk } from \"@rarible/sdk\";\nimport { EthereumWallet } from \"@rarible/sdk-wallet\";\n\n// Code\nconst { ethereum } = window as any;\n\nconst web3 = new Web3(ethereum);\nconst ethWallet = new EthereumWallet(ethereum);\n\nconst raribleSdk = createRaribleSdk(ethWallet, \"staging\");\n</code></pre> <p>Boomm! \ud83d\udc4a</p> <p>RaribleSdk object is ready for use.</p> <p>Few more things:</p> <ol> <li> <p>If you're wondering what's \"staging\" in createRaribleSdk it's environment parameter. We have four options here:</p> <ul> <li>prod (mainnet)</li> <li>dev (ropsten)</li> <li>staging (rinkeby)</li> <li>e2e (you probably won't use this)</li> </ul> <p>The difference between them is the chain Id and the Rarible API endpoint.</p> </li> <li> <p>If you're creating any sort of blockchain application which will interact with users you'll still need to implement connect metamask button in order to get their wallet connected.</p> </li> </ol>","title":"Installation"},{"location":"overview/union-sdk/#metamask-integration-with-rarible","text":"<p>In the previous chapter we talked about how we can initalize Rarible SDK, but it was more theoretical. In actual development, in almost any dApp we'd like to identify users through a wallet address they are using.</p> <p>At first sight you may think that it's not really related to the Rarible Protocol, but a correct set up is required to use the SDK smoothly and easily.</p> <p>In this chapter, I will guide you through this process (it's a proposition of implementation, not the only correct way, but widely used). Once you get the idea you can work with that however you'd like.</p> <p>Below you can find a list of steps that should be taken after the \"Connect Metamask\" button is clicked.</p> <ol> <li> <p>Identify if user has a blockchain provider (i.e. if he has Metamask installed)</p> <pre><code>const getProvider = () =&gt; {\n  // 1. Getting ethereum object out of global JS object\n  if ((window as any).ethereum) {\n    const { ethereum } = window as any;\n\n    return ethereum;\n  }\n  // 2. If ethereum property does not exist it means that user needs to install Metamask\n  else {\n    alert(\"Please install Metamask\");\n  }\n};\n\nconst provider = getProvider();\n</code></pre> </li> <li> <p>Request and get metamask accounts - metamask should pop up in this step, to authorize the app</p> <pre><code>const connect = async () =&gt; {\n  if (!provider) {\n    alert(\"No provider found!\");\n  } else {\n    // 1. Making metamask request\n    await provider.request({ method: \"eth_requestAccounts\" });\n    // 2. Getting currently connected accounts\n    const accounts = await provider.request({ method: \"eth_accounts\" });\n\n    if (accounts.length &gt; 0) {\n      // First item is always currently used account\n      setAccount(accounts[0]);\n    }\n    // Setting event listener on whenever user has changed account\n    provider.on(\"accountsChanged\", (accs: any) =&gt; {\n      const [currentAccount] = accs;\n      setAccount(currentAccount);\n    });\n  }\n};\n</code></pre> </li> <li> <p>Prepare EthereumWallet for RaribleSdk</p> <pre><code>const wallet = () =&gt; {\n  // 1. Check if provider and currentAccount is successfully set\n  if (provider &amp;&amp; currentAccount) {\n    return new EthereumWallet(\n      new Web3Ethereum({ web3: new Web3(provider), from: currentAccount })\n    );\n  } else {\n    return undefined;\n  }\n};\n</code></pre> </li> <li> <p>Create RaribleSDK</p> <pre><code>// 1. \"env\" parameter is one of \"prod\" | \"dev\" | \"staging\" | \"e2e\" mentioned earlier\nconst sdk = (env: string) =&gt; {\n  if (wallet) {\n    return createRaribleSdk(wallet, env as any);\n  } else {\n    return undefined;\n  }\n};\n</code></pre> </li> </ol> <p>And voila \ud83d\ude80.</p> <p>Now we have real life working example with metamask connected and Rarible SDK configured as it should.</p> <p>Here you can find code used in example in broader picture: https://github.com/rarible/example/tree/master/src/sdk</p>","title":"Metamask integration with Rarible"},{"location":"overview/union-sdk/#erc721-nft-lazy-minting","text":"<p>In order to lazy mint an item following parameters are required:</p> <ul> <li>URI - address of data on IPFS</li> <li>supply - number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameter)</li> <li>lazyMint - boolean, if we want to mint it lazily or normally</li> <li>creators - array of creators, which allows to distribute profits from sell in accordance to defined criteria</li> <li>royalties - array of royalties, which allows to take defined amount of any consecutive sell</li> </ul> <p>Disclaimer: Whenever you see the need of Union / Contract address you can create it as follows:</p> <ol> <li>Blockchain Name</li> <li>Hex Address</li> </ol> <p>Example: BlockchainName:HexAddress ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05</p> <pre><code>// Examplary values of URI and supply\nconst [uri, setUri] = useState&lt;string&gt;(\n  \"ipfs:/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\"\n);\nconst [supply, setSupply] = useState&lt;number&gt;(1);\n\nconst currentWallet = wallet as EthereumWallet;\nconst makerAccount = await currentWallet.ethereum.getFrom();\n\n// 1. Create PrepareMintRequest\n// Collection ids are the address of Rarible Smart Contracts instance\n// You can find them here:\n// https://docs.rarible.org/ethereum/contract-addresses/\n\nconst mintRequest: PrepareMintRequest = {\n  // Using Rarible API, tokenId would also be needed, but SDK takes care for that\n  collectionId: toContractAddress(\n    \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\"\n  ),\n};\n\n// 2. Get Mint Response\n// From mintResponse you can extract additional info e.g. is supply &gt; 1 enabled\nconst mintResponse = await sdk.nft.mint(mintRequest);\n\n// If you want to divide profits here you can add more than one creator object\n// Combined value amount has to be 10000 which equals to 100 %, same with royalties\nconst creators = [\n  {\n    account: `ETHEREUM:${makerAccount}`,\n    value: 10000,\n  },\n];\n\nconst royalties = [];\n\n// 3. Submit Mint Response\nconst submitResponse = await mintResponse.submit({\n  uri,\n  supply,\n  lazyMint: true,\n  creators,\n  royalties,\n});\n\n// Example of successful response\n// itemId: \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382047\"\n//type: \"off-chain\"\n</code></pre>","title":"ERC721-NFT Lazy Minting"},{"location":"overview/union-sdk/#list-nft-on-sell","text":"<p>To list your NFT on sell, you'll need a token address, the one you get back from</p> <pre><code>await mintResponse.submit();\n</code></pre> <p>If you want to create sell order immediately after lazy minting your token, you can grab it straight from the response. Otherwise you'll have to fetch it e.g. from API, or even paste it by hand using tokenId, which you can see in Rarible URL when you're on token you want to list.</p> <p>It's pretty straightforward. All we need is:</p> <ul> <li>tokenUnionAddress: string e.g. ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052</li> <li>price: number - price in ETH for which we want to list the token (disclaimer: it's not in wei, it's in ETH, so 0.5 equals 0.5 ETH)</li> <li>amount: number - quantity of NFT we want to list. In case of ERC721 it's 1</li> <li>currency: EthEthereumAssetType - currency which we want to get in return for our token</li> </ul> <pre><code>// 1. Examplary values\nconst tokenUnionAddress: string =\n  \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382052\";\nconst ethCurrency: EthEthereumAssetType = {\n  \"@type\": \"ETH\",\n};\nconst price: number = 1;\nconst amount: number = 1;\n\n// 2. Create PreapreOrderRequest type object and pass it to sdk.order.sell\nconst orderRequest: PrepareOrderRequest = {\n  itemId: toItemId(tokenUnionAddress),\n};\n\n// You can extract info about properties from orderResponse e.g.\n// 1. Base fee\n// 2. Max Amount\n// etc.\nconst orderResponse = await sdk.order.sell(orderRequest);\n\n// 3. Submit the transaction -&gt; it will pop up the metamask asking you to sign a transaction, signing is free so there should not be any price associated\nconst response = await orderResponse.submit({\n  price,\n  amount,\n  currency: ethCurrency,\n});\n// We get order id from response, it can be useful when we want to update sell order\n</code></pre>","title":"List NFT on sell"},{"location":"overview/union-sdk/#update-listed-token-price","text":"<p>To update listed token price you need sell order id.</p> <p>Due to security circumstances you can't update token price to higher than the one created in original sell order. If you want to boost the price up, you need to cancel sell order and create a new one.</p> <pre><code>const price: number = 0.8;\nconst ethCurrency: EthEthereumAssetType = {\n  \"@type\": \"ETH\",\n};\n\nconst orderId =\n  \"ETHEREUM:0x6e794fd04bcf21ee7f347874aefdf36ec1a7b73b5694760b367a7644765a6368\";\n\nconst updateOrderRequest: PrepareOrderUpdateRequest = {\n  orderId: toOrderId(orderId),\n};\n\nconst updateResponse = await sdk.order.sellUpdate(updateOrderRequest);\n\nconst response = await updateResponse.submit({\n  price,\n});\n</code></pre> <p>See more information about usage Protocol SDK on https://github.com/rarible/sdk</p>","title":"Update listed token price"},{"location":"resources/meetings/meeting-doc-15th-of-october/","text":"<p>Meeting document for dev meeting on the 15th of October.</p>","title":"Meeting doc 15th of october"},{"location":"resources/meetings/meeting-doc-15th-of-october/#github","text":"<p>https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered</p> <p>I've recently started also looking through github discussions, and cherry picking the ones with high priority, but for this week all github discussions are either answered or more clarification is needed. </p>","title":"Github"},{"location":"resources/meetings/meeting-doc-15th-of-october/#discord","text":"<p>Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. </p> <p>All people listed below have also been invited to participate this dev call.</p> <p><code>alexon#6056</code></p> <p>Quote: \"I was just trying to do this on rinkeby but it failed for me with INCORRECT_LAZY_NFT Invalid creator and signature size. Did this ever work for you?\"</p> <p>Quote 2: \"It\u2019s about minting an 1155 with 2+ more creators. The signature part keeps failing because there\u2019s only one signature in the request, mine, and not from the other creators.  I was just wondering how we could mint an nft with 2+ creators if only one of the creators is the one doing the mint action.\"</p> <p>Answer: You should include signatures for every creator (and you can include zero-length signature for the creator who is executing transaction)</p> <p><code>inartin#9707</code></p> <p>Quote: \"Is there an API call that will return ALL types of order activities?  Not a separate one but all of them at once, MINT, TRANSFER, BURN, BID, LIST, SELL (or MATCH)?</p> <p>The getNftOrderAllActivities does not have the Sell or MATCH type (it has in the documentation but it was a typo and will be removed from docs).... So, how do I get all activities in one API call? \"</p> <p>Answer: https://ethereum-api-dev.rarible.org/v0.1/doc#operation/getNftOrderAllActivities There is a SELL type</p> <p><code>chusla#6031</code></p> <p>Quote: \"Should a minted (bought and minted not just lazy minted) nft that's been burned still be visible on rarible.com?  Etherscan shows it's been burned.  Do these also have to be manually deleted in lazy db?  https://etherscan.io/tx/0xb496e0e664c4529020ebd4ba5d2734f0d9aa1ecf2bacaeaa499d7ee1542da5e2.  Thank you! trying to come with a plan of action to clear the collection for new mints  If they do need to be manually deleted can we include in list of items to be cleared this week? Thank you!\"</p> <p>Answer: \"If it was fully burned, it should not appear on .com\" </p> <p>Quote: \"Thanks Eduard we might want to test or check this if you burn an item even in rinkeby after it's been bought or minted it just goes back to the original owner.  The original owner can then put it back in for sale and then it can get purchased again!</p> <p></p> <p>Fyi screen above shows history of an item that was put back on sale AFTER being burned.  I am have confirmed in rinkeby that this item can also be repurchased a second time by the buyer after it was burned.\"</p> <p>Andrew has also opened an issue here: https://github.com/rarible/protocol-issues/issues/135</p> <p>Answer: This looks like a serious bug. Will wix it.</p> <p><code>mynamebrody#5466</code></p> <p>Quote: \"Don't have time at the moment to write up an issue, but the production API endpoint for bidsByItem has \"valueDecimal\": null, under the make object, where in the rinkeby/ropsten version of the API return the value field as ETH instead of GWEI\"</p> <p>Answer: This is because prod version was not updated to the latest version. I think everything should be fine now.</p> <p><code>tgb2929#1533</code></p> <p>Quote: \"When creating a sell order using the SDK, if we want to sell for Ether, what do we input here: \"takeAssetType: {        assetClass: \"ERC20\",        contract: contractErc20Address    }\" https://docs.rarible.org/sdk#create-sell-order\"</p> <p>Answer: you should use assetClass: \"ETH\" for this and not \"ERC20\"</p> <p>Quote 2: \"I'm using the SDK to create Buy orders. The issue is that almost always on the first buy attempt, the estimated gas fee is several Ether, which isn't really true. If I close and try again, then usually it's more reasonable. Anyone know how to deal with handling buy orders and showing reasonable gas fees?\"</p> <p>Answer: Pls, give me tx or item example or code example, what you trying to do. What amount of gas is calculated in the wallet?</p> <p><code>lazycaramel#4474</code></p> <p>Quote: \"Hey guys, I was interested if I could use ERC1155Factory directly, or should I use SDK? Also, what's the caveat to using this vs deploying my own ERC1155? Is there some kind of lock-in with Rarible taking 2.5% on each token sale even outside of the platform?\"</p> <p>Answer: ERC1155Factory creates a proxy to our contract implementation, Rarible protocol will upgrade these tokens when new features are available. You can use your own version of the token contract. It's not related to 2.5% on each sale. 2.5% for each sale is taken by rarible.com website when order is created.</p> <p><code>Rhabdodon#4653</code></p> <p>Quote: \"We've been experiencing a tremendous amount of interest and usage of cocoNFT which is amazing! Want to first thank you all for the support along the way! \u2764\ufe0f </p> <p>I also wanted to share the 5 biggest pieces of feedback we're getting from users that are related to the protocol.</p> <ol> <li> <p>Users want to be able to burn lazy minted NFTs without paying gas fees. There is certainly confusion around this. </p> </li> <li> <p>Users also want to be able to remove lazy minted NFTs from sale without paying gas fees. </p> </li> <li> <p>Users want more sale types supported (i.e. auctions for 721 and Open for Bids for 1155s). We're on an 1155 collection so the latter would be particularly helpful. </p> </li> <li> <p>Users want to setup their Rarible profile within cocoNFT. They don't understand why they have 2 different profiles. I really think the Rarible protocol could do something cool here for the ecosystem by building a unified profile system similar to what exists on Tezos but maybe the Rarible one is cross-chain. </p> </li> <li> <p>Users want to change the price for their lazy minted NFTs (I believe this is coming soon!)\"</p> </li> </ol> <p>Answer: I think we covered this on the call. We will implement feature to burn lazy minted NFTs with 2 options: 1. by just removing from the website. 2. by calling contract to invalidate signatures</p> <p><code>agamanin#2389</code></p> <p>Quote: \"Hi. I'm new to the community, glad to be here. I have a question about the protocol smart contracts licensing. There is no LICENCE file on github. Some research indicates that it means 'forbidden for private or commercial use' (i.e. https://github.com/github/choosealicense.com/issues/196). Does it basically mean one cannot fork it, then adapt to her own needs (i.e. change the protocol fees structure, and the fee recipient address) and run her own markeplace? \ud83d\ude42 An open github issue with similar question does not make it more transparent as well Also, 77 forks (at the moment of writing) would only make sense for educational purposes in this case, right?\"</p> <p>Answer - Eduard: AFAIK, anyone is allowed to fork and use rarible-protocol code for their own projects and whatnot. It's open source.</p> <p>Quote: \"Wow, that would be just great. BTW, as far as I can understand, tools like https://one2all.io/ already do this - they let anyone set an arbitrary fee recipient and assign the fee structure. But they may have special permission of Rarible to do that, I don't know. Anyhow, having a more explicit license stating what can be done and what cannot would be beneficial for everyone.\"</p> <p>Answer - Eugene: Thanks, we will check if licenses are set everywhere. If you are talking about protocol-contracts repo, then MIT license should be set there.</p> <p><code>Unnatural Space#0655</code></p> <p>Quote: \"is the rarible protocol compatible with polygon network?\"</p> <p>Answer - Eduard: I'd have answered that it's in the plans to be implemented soon, but Eugene, it'd be best for a more accurate answer. </p> <p>Answer - Eugene: It's WIP. Will be live in the end of the year, may be soonerhttps://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28</p> <p><code>chusla#6031</code></p> <p>Quote: \"Hi all question on sdk.  My recent understanding is that the mint function automatically generates the contract token ID.  But how does this work with including token id in external URI in Json metadata?  Don't we need to generate token id before Json/ipfs upload and then mint?  Any thoughts on this much appreciated.  Seems like there may be an order of operations issue here?  I've been doing some testing and think lack of token id on external URI May cause issue with opensea rendering. Previously we were able to do in two steps. Generate token id, then get ipfs content id then mint.  Would be great to discuss on today's call thanks!\"</p> <p>Answer: We covered this on the call. Pls see https://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28</p>","title":"Discord"},{"location":"resources/meetings/meeting-doc-22nd-of-october/","text":"<p>Meeting document for dev meeting on the 22nd of October.</p>","title":"Meeting doc 22nd of october"},{"location":"resources/meetings/meeting-doc-22nd-of-october/#github","text":"<p>None. There are two \"unanswered\" questions that on which we're waiting on a reply from the question owner. </p>","title":"Github"},{"location":"resources/meetings/meeting-doc-22nd-of-october/#discord","text":"<p>Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. </p> <p>All people listed below have also been invited to participate this dev call.</p> <p><code>owenmurovec#8687</code></p> <p>Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\",     \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\",     \"status\": 400 }</p> <p>According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type.</p> <p>Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\"</p> <p><code>richexplorer.eth#8225</code></p> <p>Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset </p> <p>But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done</p> <p>data: {     }       code: 'VALIDATION',       message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address',       status: 400</p> <p>Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\"</p> <p><code>fruitybits#4442</code></p> <p>Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\"</p>","title":"Discord"},{"location":"resources/meetings/meeting-doc-29th-of-october/","text":"<p>Meeting document for dev meeting on the 29th of October.</p> <p>Github discussions: </p> <p>https://github.com/rarible/protocol/discussions/142 <code>whitespace#2877</code></p> <p>Answer: Eugene to look into it later. Meeting is too short to review there.</p> <p>https://github.com/rarible/protocol/discussions/11 - related to spam NFT's being minted to someone's collection</p> <p>Answer: </p> <p>We already have discussed about this. There is now a contract where only the owner can mint.</p> <p>We will have the possibility to deploy private contracts via the SDK, adding the feature is in our backlog. The release can be expected Monday / Tuesday next week (first week of November)</p> <p>Any collection that has already been released won't be able to benefit from this. </p> <p>Github issues: </p> <p>Most important: https://github.com/rarible/protocol/issues/148 <code>owenmurovec#8687</code></p> <p>Answer: We already fixed this in our contract. There is a PR waiting to be merged, will probably be done by Monday / Tuesday next week (first week of November)</p> <p>https://github.com/rarible/protocol/issues/147 <code>Jaacob#1962</code> and <code>Branko#7207</code></p> <p>Answer: Need a TXID / Hash  github issue was updated </p> <p>https://github.com/rarible/protocol/issues/143 <code>tgb29#1533</code></p> <p>Answer: Metamask should say that there is an exception in the transaction, but that isn't shown correctly. We have raised this issue to the metamask team. </p> <p>https://github.com/rarible/protocol-ethereum-sdk/issues/52 from <code>inartin#9707</code></p> <p>Answer: Need to check at another time / Please DM Eugene on TG</p> <p>Discord:</p> <p><code>chusla#6031</code></p> <p>Quote: \"could we get an update on latest browser compatible sdk as well that would be much appreciated if there is any way at all to include that in next week's release for tezos etc that would unblock us thanks!\"</p> <p>Answer: We've got a PR open for the browser compatible SDK, we will try to move it to review within the next week. </p> <p><code>mynamebrody#5466</code></p> <p>Quote: \"I think I'm having issues with the encodeOrder endpoint as it wants a signature but that's not required for this call yet so I haven't been including it. But adding the field with an empty value gets past this error, however, I don't think it should be there\"</p> <p>Answer: Will check.</p> <p><code>platocrat#4224</code></p> <p>Quote: \"@Matt a friend just sent me this, which comes from your documentation.  Is this correct? We should just fork Rarible Protocol, deploy the protocol to Polygon, then use those contracts to deploy our ERC1155 contracts?\" Just to clarify, i wish to use Rarible's contracts, which i assume to be on, Polygon to deploy our contracts \ud83d\ude42 </p> <p>Answer: I believe that is correct, to deploy contracts you can fork/clone the repo. What's needed to be done is to put the configuration for Polygon and deploy it to this network. But that's not everything. Rarible Protocol is not only about contracts, is about indexer and sdk as well. We have already deployed our indexer on polygon testnets but with SDK this is a bit harder because we would like to use meta transactions which means we would need to change our SDK to support these meta transactions. These are these main tasks we need to get done in order to use Polygon. We'll try it after we deploy on Tezos and Flow. Might try initial testing next week. Would be better to wait imo. </p> <p><code>idan.angel#8635</code></p> <p>Quote: \"Hi All, I'm looking for a Rarible API that would return the assetType for any NFT listed on the marketplace. In other words, I'm looking for something like:  GET ?itemId=: <p>and I expect to get an answer that would contain a field with ERC721 or ERC1155 or Lazy_mint, something of that sort, so that I can use that value to create a new buy order. I haven't found anything of that sort. For some NFTs there are open orders which hold the assetType, but I'm looking for a standard way that would work on every NFT on Rarible, not just NFTs with open or past orders.</p> <p>Any help would be appreciated.\"</p> <p>Answer: If SDK is used, that's not needed. They just need to get an order and execute field in the SDK and the inverted order will be automatically made. If any further help is needed contact</p> <p><code>owenmurovec#8687</code></p> <p>Quote: \"Trying to use the encodeOrder endpoint but getting an error response (Using the exact example request from the docs https://docs.rarible.org/exchange/creating-a-sell-order): { \"code\": \"BAD_REQUEST\",     \"message\": \"Instantiation of [simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\\n at [Source: (io.netty.buffer.ByteBufInputStream); line: 24, column: 1] (through reference chain: com.rarible.protocol.dto.RaribleV2OrderFormDto[\\\"signature\\\"])\",     \"status\": 400 }</p> <p>According to the API reference (https://api-reference.rarible.com/#operation/encodeOrder), the signature field should be optional but seems like that's what's causing the error? Tried adding the signature field as an empty string \"\" or as \"0x\" and it seems to work however it gives an EIP712 type signMessage when I need an EIP1271 type.</p> <p>Anyone know what could be going wrong? or if there's a specific value I can set signature to for an EIP1271 type instead?\"</p> <p>Answer: creating-a-sell-order in the docs is a bit outdated, we'll fix that. Also. encodeOrder is deprecated, it's better to use SDK. Rarible docs now have a blockchain agnostic structure that isn't tied to Ethereum, there is information on how to use the SDK there.</p> <p><code>richexplorer.eth#8225</code></p> <p>Quote: \"Hi, I am trying to lazy mint NFT using this asset creation article https://docs.rarible.org/asset/creating-an-asset </p> <p>But I am getting below 400 with invalid token, its missing creator address. I checked a lot of times and not sure what needs to be done</p> <p>data: {     }       code: 'VALIDATION',       message: 'TokenId Token(id=0x6ede7f3c26975aad32a475e1021d8f6f39c89d82, owner=null, name=Rarible, symbol=RARI, status=CONFIRMED, features=[MINT_AND_TRANSFER, APPROVE_FOR_ALL], standard=ERC721, version=1) must start with first creator address',       status: 400</p> <p>Did anyone face this? Can anyone help me out in this or if there is a way to see more logs?\"</p> <p>Answer: Same as the answer above, please use SDK. </p> <p><code>fruitybits#4442</code></p> <p>Quote: \"another royalties question \ud83d\ude42 I'm implementing some ERC721 contracts on Polygon. I want them to be ready to use Rarible Royalties when Rarible supports Polygon/Matic. Is there anything I can implement now (e.g. Royalties V1 from the docs) or do I need to sit tight?\"</p> <p>Answer: Royalties V1 or V2 will do. Any version will be working on Polygon without a problem once we deploy there.</p>","title":"Meeting doc 29th of october"},{"location":"resources/meetings/meeting-doc-5th-of-november/","text":"<p>Meeting document for dev meeting on the 5th of November.</p> <ol> <li>Update on the 12k$ contract upgrade.</li> </ol> <p>When are we going to deploy that fix now that the gas fees seem to have lowered down?</p> <ol> <li>Update on Flow. </li> </ol> <p>Are we still on track to deploy between 8th and the 12nd of November?</p> <ol> <li>Update on the bidding function. </li> </ol> <p>The bid function doesn't seem to be fully supported by the SDK. What is the situation with that? (Question is related to <code>alexon#6056</code>'s question below)</p>","title":"Meeting doc 5th of november"},{"location":"resources/meetings/meeting-doc-5th-of-november/#github","text":"<p>https://github.com/rarible/protocol/issues/140 - &gt; When will the error message / html status be changed?</p> <p>https://github.com/rarible/protocol/issues/133 - &gt; Has this been fixed? If not, what is an ETA for a fix. </p> <p>https://github.com/rarible/protocol/issues/120 - &gt; Have we found a way to implement this?</p> <p>https://github.com/rarible/protocol/issues/152 - &gt; </p> <p>https://github.com/rarible/protocol/issues/151 - &gt; </p> <p>https://github.com/rarible/protocol-ethereum-sdk/issues/52 - &gt;</p>","title":"Github"},{"location":"resources/meetings/meeting-doc-5th-of-november/#discord","text":"<p><code>Nick - Ownerfy#8137</code></p> <p>Quote: \"simple type, class com.rarible.protocol.dto.RaribleV2OrderFormDto] value failed for JSON property signature due to missing (therefore NULL) value for creator parameter signature which is a non-nullable type\"</p> <p>Answer: </p> <p><code>Zoomer#5825</code></p> <p>Quote: \"Hi frens. I'm trying to parse Rarible trades on Ethereum. I see here in the exchange contract's events that the events with topic0 as 0x268820db288a211986b26a8fda86b1e0046281b21206936bb0e61c67b5c79ef4 have all useful info in the arguments  But the event with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e does not seem to contain the address of the traded NFT What is the difference between these two events? And is there any simple way for me to get the contract address of the NFT being traded in the transaction with topic0 as 0xcae9d16f553e92058883de29cb3135dbc0c1e31fd7eace79fef1d80577fe482e? (Here's a link of what I'm looking at https://etherscan.io/address/0x9757F2d2b135150BBeb65308D4a91804107cd8D6#events)\"</p> <p>Answer:</p> <p><code>alexon#6056</code></p> <p>Quote: \"are you guys migrating to a new sdk? Just saw the docs link to a new repo. I ask because I just created a bid with the procotol-ethereum-sdk and I used ETH as the make asset. The issue I'm seeing is that it's not coming back in the bids api from https://api-staging.rarible.com/protocol/v0.1/ethereum/order/bids/byItem. I made a bit through rarible and that one does show up. Actually, I noticed it's just because it's marked as INACTIVE. Is there a reason why it's that way? I know rarible makes you convert eth to weth first to place a bid. But there is no exaplanation on how to do that in the docs. \" </p> <p>Answer:</p> <p><code>rimb05#3257</code></p> <p>Quote: \"When will the 721 lazy minting minimal version be deployed?\"</p> <p>Answer:</p>","title":"Discord"},{"location":"resources/meetings/meeting-doc-8th-of-october/","text":"<p>Meeting document for dev meeting on the 8th of October. </p>","title":"Meeting doc 8th of october"},{"location":"resources/meetings/meeting-doc-8th-of-october/#addresing-the-httpsapi-stagingrariblecom-to-httpsethereum-apiraribleorg-replacement-in-the-docs","text":"<p>There are 4 instances where api-staging is used in the docs.  1. https://docs.rarible.org/example-projects/picnic#api-calls 2. https://docs.rarible.org/exchange/order-discovery#search-orders 3. https://docs.rarible.org/exchange/creating-a-sell-order#creating-an-order 4. https://docs.rarible.org/asset/creating-an-asset#erc1155-lazy-minting</p>","title":"Addresing the https://api-staging.rarible.com/ to https://ethereum-api.rarible.org/ replacement in the docs."},{"location":"resources/meetings/meeting-doc-8th-of-october/#github","text":"<p>https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered</p> <p>I've realised that discussions that are not in the Q&amp;A section won't get indexed in the link above so I've changed the section for a few of them, that's the reason there might be some older questions in there. </p>","title":"Github"},{"location":"resources/meetings/meeting-doc-8th-of-october/#discord","text":"<ul> <li>All members who have a question listed below have been invited to participate in this call</li> <li>All members will be notified about the answer to their question privately or in #dev-general (discord)</li> <li>Only the past 7 days of unanswered questions are indexed here. </li> </ul> <p><code>Konstantin#3916</code></p> <p>Quote: \"The question for lazy mint. Can I mint nft myself from order? For example, I will hit any sales order with a lazy mint, and I just do mint nft. Will the excenge method be able to make a new duplicate nft since the order remains?\"</p> <p>Answer: No, if it was minted, then no more NFT's will be minted. It's controlled by the smart contract. So if we're talking about ERC721 of course not because they're unique. If we're talking about ERC1155 no, the total supply of the token is controlled by the smart contract so if there's a message saying only 5 will be minted, no more will be minted.</p> <p><code>Rhabdodon#4653</code></p> <p>Quote: \"Thanks! Would love an update on how we're addressing this on the protocol. I believe @Eugene Nacu | Rarible has an idea for how we can address this but needs someone to work on it.\"</p> <p>\"this\" meant: \"Regarding the opensea bug it's caused by the function in the lazy minting contract that does the minting transfer as it was originally calling the function doing the minting at the Blackhole address and then doing the transfer to the OpenSea address. The fix requires  minting, sending to the creator of the lazy minter address and then to the buyer vs minting and sending from the blackHole address.\"</p> <p>\"@Eugene Nacu | Rarible do you think a fix to the OpenSea issue would be completed and shipped by the end of the week?\"</p> <p>Answer: Skipped -- </p> <p><code>alexon#6056</code></p> <p>Quote: \"Is there a way to use the protocol-ethereum-sdk in node without having to pass a web3 instance (since I don't need it)\" \"I just tried it by configuring a web3 instance in node, but I'm getting FormData is not defined. So I'm guessing the sdk is not meant to be used in node then?\"</p> <p>Answer: It can be used in node, look in tests, here's a walkaround. Link with example: https://github.com/rarible/protocol-ethereum-sdk/blob/master/packages/protocol-ethereum-sdk/jest.setup.js</p> <p><code>Laviniao#9840</code></p> <p>Quote: \"Hi, does anyone in this chat know when L2 will be available on rarible?\"</p> <p>\"Also, will generative art projects be able to be minted on platforms built on the protocol, in reglf to the smart contract element?\"</p> <p>Answer: If you consider polygon to be L2, the exact implementation date is not known, but we'll start looking into it in the first week of November. </p> <p><code>Peter Watts#5307</code></p> <p>Quote: \"Hi. Is there a delay when adding Royalties to existing external contract? I followed the steps here (https://docs.rarible.org/asset/royalties-on-a-external-collection) and tx is here (https://etherscan.io/tx/0xb5f625595fed64d629818401b61342d1f0443867fa866fe588d442f36804f834) but it doesn't show up when selling on Rarible, nor when querying the API (https://api.rarible.com/protocol/v0.1/ethereum/nft/items/0x819327e005a3ed85f7b634e195b8f25d4a2a45f8:35739319466029867409935893104794648465119721019613204601875682368845852747852?includeMeta=true)\"</p> <p>Answer: Add to github issues. </p> <p><code>AzFlin#5259</code></p> <p>Quote: \"hey, can we not post a fixed price auction on rarible UI with an expiration date?\"</p> <p>Answer: Not yet. It will be available soon (almost implemented). When you create a sell/bid order you will be able to set an end date for the order. It almost works, soon will be on rarible.com as well. Will prioritise this task.</p> <p><code>Alexandr Devyatkin#4906</code></p> <p>Quote: \"Hi! Having trouble with local publishing scala-rpc. While using sbt publishM2 i receive this error: unable to locate a valid GitHub token from GitConfig(token). Which token could be used in that case? Thanks in advance. Link to repo: https://github.com/rarible/scala-rpc\"</p> <p>Answer: This matter was already discussed between Eugene and Alexandr.</p> <p><code>bold#5220</code></p> <p>Quote: \"Hey devs, many of these NFT projects (BAYC, Cool Cats, Pudgy Penguins, etc.) don't have the Rarible Royalties contracts built in. So do they just not receive royalties if traded on Rarible Marketplace, or does Rarible set up some kind of proxy contracts to account for royalties for them?\"</p> <p>\"@Eugene Nacu | Rarible just want to confirm that going forward with a custom contract, I'd only have to include the EIP-2981 standard and not the overall RaribleRoyalties contracts found on Rarible's github, right?\"</p> <p>Answer: Rarible exchange contract uses royalty registry. For some time there is a feature on rarible.com to update royalties for a specific collection, so creators of the collection can override and set custom royalties for their collections. Also if for example artblocks doesn't implement rarible royalties, but we implement this proxy contract to convert the royalties to our format and registered it, it works. Anyone from these contracts can register and override royalties on rarible. </p> <p>Answer for the EIP-2981 question: Currently it's not the case so exchange contract doesn't follow this standard but it will. This issue will be solved after we finish the auction contract. </p> <p><code>nullren#4914</code></p> <p>Quote: \"for properties on an nft detail page, does rarible use the same metadata attributes as opensea? or does it use the enjin properties? ie following or does rarible have it's own version of this https://docs.opensea.io/docs/metadata-standards\"</p> <p>Answer: It's the same as opensea, so not like our own standard, we pretty much follow what opensea does. </p> <p><code>NiFTiChristian#7535</code></p> <p>Quote: \"I'm using the ethereum sdk to create an order, but I get a 404: https://ethereum-api-staging.rarible.org/v0.1/nft/items/0x03c592e5f277C37A3e8dEE74f743a7972e5BF51B%3A1/lazy 404 has anyone experienced this while using the SDK?\"</p> <p>Answer: Add to github issues. </p>","title":"Discord"},{"location":"tezos/tezos-contract-addresses/","text":"<p>Here you can find Rarible Smart Contracts deployed instances across Tezos Mainnet and Hangzhou Net.</p>","title":"Contract Addresses"},{"location":"tezos/tezos-contract-addresses/#mainnet","text":"Name Address     Rarible public collection KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS   royalties KT1HNNrmCk1fpqveRDz8Fvww2GM4gPzmA7fo   transfer_proxy KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD   transfer_manager KT1HTmwHGvxYgACDr1oJhMNZGzxHCAnNHaHi   fill KT1D2fZiUNo6RPj3zKofH8DqDDgoV7KoyEbb   exchange KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC","title":"Mainnet"},{"location":"tezos/tezos-contract-addresses/#hangzhou","text":"Name Address     royalties KT1WKRXswxEpTbVg2pGgofzwZCNKjAVcuMgh   transfer_proxy KT1Qypf9A7DHoAeesu5hj8v6iKwHsJb1RUR2   transfer_manager KT1DyDkW16XBuFzpLkXKraD46SAxQDrha5gm   fill KT1FAndThSQsVqYQVPHGSG5sQPk1XZycNBvL   exchange KT1ULGjK8FtaJ9QqCgJVN14B6tY76Ykaz6M8","title":"Hangzhou"},{"location":"tezos/tezos-overview/","text":"","title":"Rarible Protocol Tezos"},{"location":"tezos/tezos-overview/#overview","text":"<p>Tezos has low fees, high performance, and a smaller carbon footprint than proof-of-work blockchains as a proof-of-stake blockchain.</p> <p>Main features:</p> <ul> <li>Creating NFTs on the Tezos blockchain</li> <li>API server similar to the one already available for Ethereum</li> <li>SDK in the same model as Ethereum</li> <li>Using Crawlori to crawl the Tezos blockchain</li> </ul> <p>Support for the Tezos was built by Tezos team:</p> <ul> <li>Backend and SDK was built by Functori</li> <li>Edukera and Nomadic Labs managed the smart contracts</li> </ul> <p>Source code is available here.</p> <p>Tezos API and SDK documentation can be found here.</p>","title":"Overview"},{"location":"tezos/tezos-overview/#smart-contracts","text":"<p>Tezos Exchange smart contracts it's a port of the Rarible ExchangeV2 contract.</p> <p>The diagram below presents the process flow between contracts:</p> <p></p> <p>To see more details about the smart contracts as well as their code, check the Exchange Contracts and NFT Contracts on the GitLab repo.</p>","title":"Smart Contracts"},{"location":"tezos/tezos-overview/#api-reference","text":"<p>Use these base URL to access API on the Tezos network:</p>    Base URL Network Net     https://rarible-api-mainnet.functori.com/v0.1 Tezos Mainnet   https://rarible-api.functori.com/v0.1 Tezos Hangzhou    <p>Tezos API documentation can be found here.</p>","title":"API Reference"},{"location":"tezos/tezos-overview/#sdk","text":"<p>SDK in the same model as Ethereum. It will allow interacting \"programmatically\" with the smart contract and the API server.</p> <p>Tezos SDK documentation can be found here.</p> <p>For more information on using the Rarible Protocol Tezos SDK, see the Tezos repo on GitLab.</p>","title":"SDK"},{"location":"union-sdk/api/","text":"<p>api file</p>","title":"Api"},{"location":"union-sdk/nft/","text":"<p>nft file</p>","title":"Nft"},{"location":"union-sdk/order/","text":"<p>order file</p>","title":"Order"},{"location":"union-sdk/union-overview/","text":"<p>Test - overview</p>","title":"Union overview"},{"location":"use-cases/bubblesdk/","text":"<p>This plugin has been developed by EzCode.</p> <p>You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io</p> <p>You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io.</p> <p>Link to the plugin</p> <p>Link to documentation</p> <p>Examples on using the plugin</p> <p><code>All examples are open source, you can see how it works from the inside.</code></p>","title":"Rarible SDK No-Code plugin"},{"location":"use-cases/bubblesdk/#api-supported-features","text":"<ul> <li>Get Item Metadata</li> <li>Get Item Data</li> <li>Get Orders By Wallet</li> <li>Get Order By Hash</li> <li>Get NFT Ownership</li> <li>Get NFT Order Activities</li> <li>Get Order Activities By Item</li> <li>Get All NFT Items By Owner, Creator, Collection</li> </ul>","title":"API supported features:"},{"location":"use-cases/bubblesdk/#sdk-supported-features","text":"<ul> <li>ERC721 and ERC1155 supported</li> <li>Mint</li> <li>Lazy Mint (Buyer pays the fee)</li> <li>Custom Royalties</li> <li>Custom Origin Fees</li> <li>Create Order (Sell, Bid)</li> <li>Buy item</li> <li>Accept Bid</li> <li>Transfer an NFT to other wallet</li> <li>Cancel Order</li> <li>Burn</li> </ul> <p>For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here. </p>","title":"SDK supported features:"},{"location":"use-cases/bubblesdk/#how-to-use","text":"<p>Instructions</p> <ol> <li> <p>Place the element Rarible SDK on the page</p> </li> <li> <p>Make sure it is visible (not in a popup or a hidden group)</p> </li> <li> <p>Select the network in the plugin element field \"Environment\"</p> </li> </ol> <p>Ready to go?</p> <p>We are working on documentation and more demo pages.</p> <p>NFT Marketplaces being built with this plugin:  - one2all</p>","title":"How to use:"},{"location":"use-cases/coconft/","text":"<p>TLDR:</p> <p>cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins.</p> <p>cocoNFT uses the following Smart Contract functionalities:  lazy minting, exchange, and indexer.</p> <p>cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs.</p> <p>How cocoNFT would have changed things knowing what they know now:</p>  <p>On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process.</p>  <p>In regards to the database side cocoNFT advises understanding how you structure your database.</p> <p>Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs.</p> <ol> <li>Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar)</li> <li>Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens</li> <li>Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations</li> </ol> <p>Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both.</p> <ol> <li>Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address.</li> <li>Test some functions like <code>name()</code> or <code>symbol()</code> in your terminal to ensure it's working</li> <li>Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder</li> </ol> <p>API and/or SDK is in the works for cocoNFT.</p>","title":"cocoNFT"},{"location":"use-cases/mintgate/","text":"<p>TLDR: </p> <p>MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers.</p> <p>The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer</p>  <p>We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs.</p>  <p>How MintGate would have changed things knowing what they know now:</p> <p>One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. </p> <p>Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable.  </p> <p>Step by step instructions for how MintGate started building on Rarible protocol:</p> <p>Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs.</p> <ol> <li>Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar)</li> <li>Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens</li> <li> <p>Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations</p> <p>Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both</p> </li> <li> <p>Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. </p> </li> <li>Test some functions like <code>name()</code> or <code>symbol()</code> in your terminal to ensure it's working</li> <li>Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder</li> </ol> <p>APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs</p>","title":"MintGate"},{"location":"use-cases/picnic/","text":"<p>We use Rarible to help us identify NFTs from creators and collectors in the [Picnic] showcase. The [Rarible API] provides a few great endpoints for fetching the necessary data.</p>","title":"Picnic"},{"location":"use-cases/picnic/#api-calls","text":"<p>The following endpoints can be used:</p> <ul> <li>Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org</li> <li>Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org</li> <li>Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org</li> </ul>","title":"API Calls"},{"location":"use-cases/picnic/#getting-tokens-by-owner","text":"<p>Paginate through owned tokens</p> <p>import axios from 'axios';</p> <p>/*  * Get collector's owned tokens.  * @param {string} owner - owner address (0x...)  * @param {object} opts - options  * @param {string} opts.continuation - Rariable continuation ID  * @param {integer} opts.size - size of tokens to get (default: 100).  * @return   / const fetchOwnedTokens = async (owner, opts = {}) =&gt; {   const { continuation, size = 100 } = opts;</p> <p>try {     const result = await axios.get('https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner', {       params: { owner, continuation },     });     const { data } = result;</p> <pre><code>// Paginate results\nlet hist = [];\nif (data.continuation &amp;&amp; data.items.length === size) {\n  hist = await getOwnedTokens(owner, { ...opts, continuation: data.continuation });\n}\n\n// Return full history\nreturn [...data.items, ...hist];\n</code></pre> <p>} catch (err) {     console.error(err);     return [];   } };</p> <p>The <code>byOwner</code> endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information.</p> <p>You can use the <code>getItemMetaById</code> Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token.</p> <p>import axios from 'axios';</p> <p>/*  * Get token metadata from token id.  * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001)  * @return {object}  / const fetchTokenMetadata = async id =&gt; {   const { data } = await axios.get(<code>https://api.rarible.com/protocol/v0.1/ethereum/nft/items/${id}/meta</code>);   if (!data?.name) {     throw new Error('Invalid NFT data', { id, data });   }   return data; };</p> <p>If you have question, please reach out. greg@picnic.show / [@gleuch]</p>","title":"Getting Tokens by Owner"},{"location":"use-cases/royalties-on-a-external-collection/","text":"<ol> <li>Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract</li> <li>Active Contract tab. Make sure Write as Proxy is selected near the top.</li> <li> <p>Click Connect to Web3.</p> <p></p> </li> <li> <p>Expand the setRoyaltiesByToken function to set the royalties for the entire collection.</p> <p>You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below.</p> <p>The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties.</p> <p>Below is an example of a tuple which gives the user (0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126) 1% royalties on items in the collection.</p> <p>The maximum royalties value is 10000 (100%).</p> <pre><code>[[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]]\n</code></pre> <p>In the screenshot below you can see that on the collection (0x4008c2482357632b06526b492c143f4e73ff1b0d) the user (0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126) receives 2.5% (250) Royalties.</p> <p></p> </li> <li> <p>Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction.</p> <p></p> </li> </ol> <p>Now that Royalties have been set up, royalties will be paid out on every sale in that collection.</p> <p>Below is an example of a purchase transaction with annotations on what each fee is for:</p> <p></p>","title":"Setting Up Royalties on an External Collection"}]}