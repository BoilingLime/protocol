{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rarible Protocol Overview Rarible Protocol is a tool to query, issue and trade NFTs on these blockchains: Ethereum Flow (WIP, currently on devnet) Tezos (WIP, currently on granada testnet) Polygon (WIP, coming soon) Other blockchains ( tell us what blockchain you want) Getting Started Install and start to use Protocol SDK Use Protocol API Look at Example App for a quick start. Protocol Features query information about NFTs mint (issue, create) NFTs trade NFTs ( sell , bid, auction) transfer burn Architecture The architecture of the Protocol: Suggestions You are welcome to suggest features and report bugs found ! License Rarible Protocol is available under the GPL v3 .","title":"Rarible Protocol Overview"},{"location":"#rarible-protocol-overview","text":"Rarible Protocol is a tool to query, issue and trade NFTs on these blockchains: Ethereum Flow (WIP, currently on devnet) Tezos (WIP, currently on granada testnet) Polygon (WIP, coming soon) Other blockchains ( tell us what blockchain you want)","title":"Rarible Protocol Overview"},{"location":"#getting-started","text":"Install and start to use Protocol SDK Use Protocol API Look at Example App for a quick start.","title":"Getting Started"},{"location":"#protocol-features","text":"query information about NFTs mint (issue, create) NFTs trade NFTs ( sell , bid, auction) transfer burn","title":"Protocol Features"},{"location":"#architecture","text":"The architecture of the Protocol:","title":"Architecture"},{"location":"#suggestions","text":"You are welcome to suggest features and report bugs found !","title":"Suggestions"},{"location":"#license","text":"Rarible Protocol is available under the GPL v3 .","title":"License"},{"location":"SDK/bid/","text":"","title":"Bid"},{"location":"SDK/burn/","text":"","title":"Burn"},{"location":"SDK/fill/","text":"","title":"Fill"},{"location":"SDK/mint/","text":"Minting Invoke the Mint function. The result of the PrepareMintResponse is returned. It has everything you need to display the form. Collect information from the user (show the form etc). Form confirmation. Sending data using submit . For example, minting ERC-1155: const sender = await ethereum . getFrom () const action = await sdk . nft . mint ({ collection : { features : [ \"MINT_AND_TRANSFER\" ], id : erc1155Address , name : \"Test-collection\" , type : \"ERC1155\" , }, }) const result = await action . submit . start ({ uri : \"uri\" , creators : [{ account : toUnionAddress ( sender ), value : toBigNumber ( \"10000\" ) }], royalties : [], lazyMint : false , supply : 1 , }). runAll () if ( result . type === MintType . ON_CHAIN ) { await result . transaction . wait () } For more information, see mint.ts . Parameters URI - string, required This is the suffix for the tokenURI . The prefix for Rarible protocol contracts is ipfs:// supply - number, required The number of tokens to be minted. lazyMint - boolean, required Does the network supports lazyMint or not. creators - array Should contain all the addresses of the token creators with their respective ownership or contribution to the creation. royalties - array Royalties from the NFT contract.","title":"Mint"},{"location":"SDK/mint/#minting","text":"Invoke the Mint function. The result of the PrepareMintResponse is returned. It has everything you need to display the form. Collect information from the user (show the form etc). Form confirmation. Sending data using submit . For example, minting ERC-1155: const sender = await ethereum . getFrom () const action = await sdk . nft . mint ({ collection : { features : [ \"MINT_AND_TRANSFER\" ], id : erc1155Address , name : \"Test-collection\" , type : \"ERC1155\" , }, }) const result = await action . submit . start ({ uri : \"uri\" , creators : [{ account : toUnionAddress ( sender ), value : toBigNumber ( \"10000\" ) }], royalties : [], lazyMint : false , supply : 1 , }). runAll () if ( result . type === MintType . ON_CHAIN ) { await result . transaction . wait () } For more information, see mint.ts .","title":"Minting"},{"location":"SDK/mint/#parameters","text":"URI - string, required This is the suffix for the tokenURI . The prefix for Rarible protocol contracts is ipfs:// supply - number, required The number of tokens to be minted. lazyMint - boolean, required Does the network supports lazyMint or not. creators - array Should contain all the addresses of the token creators with their respective ownership or contribution to the creation. royalties - array Royalties from the NFT contract.","title":"Parameters"},{"location":"SDK/sell/","text":"Sell // Putting Item on sale // First, invoke sell function. It will return an object with some useful information const { supportedCurrencies , // List of currencies supported by specific blockchain (ETH, ERC20 etc.) maxAmount , // Max amount of the NFT that can be put on sale; you can validate the input from use using this value baseFee , // Present it to a user, it's a base protocol fee that is taken on the trade submit , // Use this Action to submit information after user input } = await sdk . order . sell ({ itemId }) // Collect information from the user (show the form etc.) // Then use submit Action to execute this action submit ({ amount , // Amount of NFTs to put on sale: must be <= maxAmount }) For example, sell ERC-721 by using ERC-20: const wallet1Address = wallet1 . getAddressString () const wallet2Address = wallet2 . getAddressString () await conf . testErc721 . methods . mint ( wallet1Address , 1 , \"\" ). send ({ from : wallet1Address , gas : 200000 }) await conf . testErc20 . methods . mint ( wallet2Address , 100 ). send ({ from : wallet1Address , gas : 200000 }) const itemId = toItemId ( ` ${ conf . testErc721 . options . address } :1` ) await awaitItem ( raribleSdk , itemId ) const sellAction = await sdk1 . order . sell ({ itemId : toItemId ( `ETHEREUM: ${ itemId } ` ) }) const hash = await sellAction . submit ({ amount : toBigNumber ( \"1\" ), price : toBigNumber ( \"1\" ), currency : { \"@type\" : \"ERC20\" , contract : toUnionAddress ( conf . testErc20 . options . address ) }, }) const [, realHash ] = hash . split ( \":\" ) await awaitStockToBe ( raribleSdk , realHash , 1 ) const fillAction = await sdk2 . order . fill ({ orderId : toOrderId ( hash ) }) const tx = await fillAction . submit . start ({ amount : 1 }) . runAll () await tx . wait () await awaitStockToBe ( raribleSdk , realHash , 0 )","title":"Sell"},{"location":"SDK/sell/#sell","text":"// Putting Item on sale // First, invoke sell function. It will return an object with some useful information const { supportedCurrencies , // List of currencies supported by specific blockchain (ETH, ERC20 etc.) maxAmount , // Max amount of the NFT that can be put on sale; you can validate the input from use using this value baseFee , // Present it to a user, it's a base protocol fee that is taken on the trade submit , // Use this Action to submit information after user input } = await sdk . order . sell ({ itemId }) // Collect information from the user (show the form etc.) // Then use submit Action to execute this action submit ({ amount , // Amount of NFTs to put on sale: must be <= maxAmount }) For example, sell ERC-721 by using ERC-20: const wallet1Address = wallet1 . getAddressString () const wallet2Address = wallet2 . getAddressString () await conf . testErc721 . methods . mint ( wallet1Address , 1 , \"\" ). send ({ from : wallet1Address , gas : 200000 }) await conf . testErc20 . methods . mint ( wallet2Address , 100 ). send ({ from : wallet1Address , gas : 200000 }) const itemId = toItemId ( ` ${ conf . testErc721 . options . address } :1` ) await awaitItem ( raribleSdk , itemId ) const sellAction = await sdk1 . order . sell ({ itemId : toItemId ( `ETHEREUM: ${ itemId } ` ) }) const hash = await sellAction . submit ({ amount : toBigNumber ( \"1\" ), price : toBigNumber ( \"1\" ), currency : { \"@type\" : \"ERC20\" , contract : toUnionAddress ( conf . testErc20 . options . address ) }, }) const [, realHash ] = hash . split ( \":\" ) await awaitStockToBe ( raribleSdk , realHash , 1 ) const fillAction = await sdk2 . order . fill ({ orderId : toOrderId ( hash ) }) const tx = await fillAction . submit . start ({ amount : 1 }) . runAll () await tx . wait () await awaitStockToBe ( raribleSdk , realHash , 0 )","title":"Sell"},{"location":"SDK/transfer/","text":"Transfer For example, transfer ERC-1155: const sender = await senderEthereum . getFrom () const receipent = await receipentEthereum . getFrom () const tokenId = \"1\" const itemId = toItemId ( ` ${ it . testErc1155 . options . address } : ${ tokenId } ` ) await it . testErc1155 . methods . mint ( sender , tokenId , 100 , \"123\" ). send ({ from : sender , gas : 200000 }) await awaitItem ( raribleSdk , itemId ) const transfer = await senderSdk . nft . transfer ({ itemId }) const tx = await transfer . submit . start ({ to : toUnionAddress ( receipent ), amount : 10 , }). runAll () await tx . wait () const balanceRecipient = await it . testErc1155 . methods . balanceOf ( receipent , tokenId ). call () expect ( balanceRecipient ). toBe ( \"10\" )","title":"Transfer"},{"location":"SDK/transfer/#transfer","text":"For example, transfer ERC-1155: const sender = await senderEthereum . getFrom () const receipent = await receipentEthereum . getFrom () const tokenId = \"1\" const itemId = toItemId ( ` ${ it . testErc1155 . options . address } : ${ tokenId } ` ) await it . testErc1155 . methods . mint ( sender , tokenId , 100 , \"123\" ). send ({ from : sender , gas : 200000 }) await awaitItem ( raribleSdk , itemId ) const transfer = await senderSdk . nft . transfer ({ itemId }) const tx = await transfer . submit . start ({ to : toUnionAddress ( receipent ), amount : 10 , }). runAll () await tx . wait () const balanceRecipient = await it . testErc1155 . methods . balanceOf ( receipent , tokenId ). call () expect ( balanceRecipient ). toBe ( \"10\" )","title":"Transfer"},{"location":"SDK/union-sdk/","text":"SDK Overview Rarible Protocol Software Development Kit enables applications to interact with Rarible protocol easily: query, issue, trade NFTs on any blockchain supported. Currently, these blockchains are supported: Ethereum (rinkeby, mainnet) Flow (currently on devnet only) Tezos (on granada testnet) Protocol SDK is available on GitHub: https://github.com/rarible/sdk Installation npm install -D @rarible/sdk or yarn add @rarible/sdk Usage SDK is written in typescript. You can use typings to explore SDK possibilities. To use SDK, first you have to create a Wallet - abstraction to communicate with real blockchain wallets: // Initialize ethereum wallet import { EthereumWallet } from \"@rarible/sdk-wallet\" const ethereum = new Web3Ethereum ({ web3 , from }) const ethereumWallet = new EthereumWallet ( ethereum , from ) // WIP: how to initialize Tezos and Flow wallets // Initialize SDK import { createRaribleSdk } from \"@rarible/sdk\" // Wallet - created before // Second parameter - is environment: \"prod\" | \"staging\" | \"e2e\" | \"dev\" const sdk = createRaribleSdk ( wallet , \"prod\" ) Basic scenario There are several main functions in Rarible protocol. Mint Transfer Sell Bid Burn Fill The order is the same for all functions: Call the function (mint, sell, bid, etc.). The result of the PrepareResponse is returned. It has everything you need to display the form. For example, for Sell, there will be a description of which currencies can be used for sale. Form display. For example, for Sell, you need to fill in the fields: how much you want to sell, price. Form confirmation. Sending data using submit from PrepareResponse . Querying Here are some basic examples of how to use APIs to query data. You can find much more methods in the doc: http://api-dev.rarible.org/v0.1/doc or right in the typescript typings. // Fetch items by creator sdk . apis . item . getItemsByCreator ({ creator : someAddress }) // Fetch activity (events) by the Item sdk . apis . activity . getActivitiesByItem ({ type : [ \"TRANSFER\" ], contract , tokenId }) //etc... pls explore SDK apis and openapi docs","title":"SDK Overview"},{"location":"SDK/union-sdk/#sdk-overview","text":"Rarible Protocol Software Development Kit enables applications to interact with Rarible protocol easily: query, issue, trade NFTs on any blockchain supported. Currently, these blockchains are supported: Ethereum (rinkeby, mainnet) Flow (currently on devnet only) Tezos (on granada testnet) Protocol SDK is available on GitHub: https://github.com/rarible/sdk","title":"SDK Overview"},{"location":"SDK/union-sdk/#installation","text":"npm install -D @rarible/sdk or yarn add @rarible/sdk","title":"Installation"},{"location":"SDK/union-sdk/#usage","text":"SDK is written in typescript. You can use typings to explore SDK possibilities. To use SDK, first you have to create a Wallet - abstraction to communicate with real blockchain wallets: // Initialize ethereum wallet import { EthereumWallet } from \"@rarible/sdk-wallet\" const ethereum = new Web3Ethereum ({ web3 , from }) const ethereumWallet = new EthereumWallet ( ethereum , from ) // WIP: how to initialize Tezos and Flow wallets // Initialize SDK import { createRaribleSdk } from \"@rarible/sdk\" // Wallet - created before // Second parameter - is environment: \"prod\" | \"staging\" | \"e2e\" | \"dev\" const sdk = createRaribleSdk ( wallet , \"prod\" )","title":"Usage"},{"location":"SDK/union-sdk/#basic-scenario","text":"There are several main functions in Rarible protocol. Mint Transfer Sell Bid Burn Fill The order is the same for all functions: Call the function (mint, sell, bid, etc.). The result of the PrepareResponse is returned. It has everything you need to display the form. For example, for Sell, there will be a description of which currencies can be used for sale. Form display. For example, for Sell, you need to fill in the fields: how much you want to sell, price. Form confirmation. Sending data using submit from PrepareResponse .","title":"Basic scenario"},{"location":"SDK/union-sdk/#querying","text":"Here are some basic examples of how to use APIs to query data. You can find much more methods in the doc: http://api-dev.rarible.org/v0.1/doc or right in the typescript typings. // Fetch items by creator sdk . apis . item . getItemsByCreator ({ creator : someAddress }) // Fetch activity (events) by the Item sdk . apis . activity . getActivitiesByItem ({ type : [ \"TRANSFER\" ], contract , tokenId }) //etc... pls explore SDK apis and openapi docs","title":"Querying"},{"location":"ethereum/ethereum-overview/","text":"Ethereum overview Protocol Flow Creating ERC721/1155 Asset Metadata and Calling the Mint function In this step, we build asset metadata, upload this metadata to IPFS and finally create our NFT on-chain. It is also very important to read up about our Royalties Schema . Asset Discovery In our Asset Discovery section, you will learn how to query items and their metadata, using filters and paging, this includes items created outside of Rarible. Creating a sell order In this section you will learn about approving assets through the transfer proxy, generating the order structure, calculating origin and protocol fees as well as signing your order and submitting it to the Rarible Indexer. Accepting a buyer/bid order In this section we will demonstrate the conversion of ETH to WETH (For placing a bid), approvals via the ERC20 Proxy Contract, generating the buy/bid order structure, Calculating Protocol and Origin fees as well as Submitting your order to the Rarible Indexer. Order Discovery Order Discovery explorers finding active orders (Buy/Sell) for items via an API query. Matching Order Matching Orders is a very important section as it deals with the Rarible Protocols Matching system, as well as custom matching contracts which can be created externally and utilized. Updating/Canceling An Order As the name suggests, this deals with the on-chain calls required to cancel an order (Buy/Sell/Bid) as well as how to update an order. API Reference. Rarible Protocol Ethereum SDK The Rarible Protocol Ethereum SDK enables applications to interact with Rarible protocol easily. With the Rarible Protocol Ethereum SDK, you can: Create sell orders Create/accept bid for auctions Buy tokens for regular sell orders Create Lazy Mint NFT ERC721 and ERC1155 tokens Make regular mint Transfer tokens Burn tokens Check it out here . Smart Contracts Smart contracts consist of: Exchange v2: responsible for sales, auctions etc. Tokens: for storing information about NFTs Specifications for on-chain royalties supported by Rarible You can read more about smart contracts here .","title":"Ethereum Overview"},{"location":"ethereum/ethereum-overview/#ethereum-overview","text":"","title":"Ethereum overview"},{"location":"ethereum/ethereum-overview/#protocol-flow","text":"Creating ERC721/1155 Asset Metadata and Calling the Mint function In this step, we build asset metadata, upload this metadata to IPFS and finally create our NFT on-chain. It is also very important to read up about our Royalties Schema . Asset Discovery In our Asset Discovery section, you will learn how to query items and their metadata, using filters and paging, this includes items created outside of Rarible. Creating a sell order In this section you will learn about approving assets through the transfer proxy, generating the order structure, calculating origin and protocol fees as well as signing your order and submitting it to the Rarible Indexer. Accepting a buyer/bid order In this section we will demonstrate the conversion of ETH to WETH (For placing a bid), approvals via the ERC20 Proxy Contract, generating the buy/bid order structure, Calculating Protocol and Origin fees as well as Submitting your order to the Rarible Indexer. Order Discovery Order Discovery explorers finding active orders (Buy/Sell) for items via an API query. Matching Order Matching Orders is a very important section as it deals with the Rarible Protocols Matching system, as well as custom matching contracts which can be created externally and utilized. Updating/Canceling An Order As the name suggests, this deals with the on-chain calls required to cancel an order (Buy/Sell/Bid) as well as how to update an order. API Reference.","title":"Protocol Flow"},{"location":"ethereum/ethereum-overview/#rarible-protocol-ethereum-sdk","text":"The Rarible Protocol Ethereum SDK enables applications to interact with Rarible protocol easily. With the Rarible Protocol Ethereum SDK, you can: Create sell orders Create/accept bid for auctions Buy tokens for regular sell orders Create Lazy Mint NFT ERC721 and ERC1155 tokens Make regular mint Transfer tokens Burn tokens Check it out here .","title":"Rarible Protocol Ethereum SDK"},{"location":"ethereum/ethereum-overview/#smart-contracts","text":"Smart contracts consist of: Exchange v2: responsible for sales, auctions etc. Tokens: for storing information about NFTs Specifications for on-chain royalties supported by Rarible You can read more about smart contracts here .","title":"Smart Contracts"},{"location":"ethereum/assets/asset-discovery/","text":"Asset Discovery Search Items {% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for item-controller part {% endhint %} There are some controllers to query items: get all items get items by owner get items by collection other controllers in item-controller section of the api-reference These controllers have common parameters: size - how many items you want to get continuation - send this parameter to fetch next portion of data (you can find continuation value in the server response) also they have different query parameters for each. Please, see api-reference {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId/meta\" method=\"get\" summary=\"Item Metadata\" %} {% swagger-description %} Displays all item Metadata (Stored on IPFS) {% endswagger-description %} {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% endswagger-parameter %} {% swagger-response status=\"200\" description=\"\" %} { \"name\": \"string\", \"description\": \"string\", \"image\": \"string\", \"external_url\": \"string\", \"animation_url\": \"string\", \"attributes\": {} } {% endswagger-response %} {% endswagger %} {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId\" method=\"get\" summary=\"Item Data\" %} {% swagger-description %} Displays Item data such as Royalties, Unlockable content, etc. {% endswagger-description %} {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% endswagger-parameter %} {% swagger-response status=\"200\" description=\"\" %} { \"id\": \"string\", \"token\": \"string\", \"tokenId\": 0, \"unlockable\": true, \"creator\": \"string\", \"supply\": 0, \"owners\": [ \"string\" ], \"royalties\": [ { \"recipient\": \"string\", \"value\": 0 } ] } {% endswagger-response %} {% endswagger %} {% hint style=\"danger\" %} If you wish to build an order for an ERC1155, it is important you also record the amount returned by the query. {% endhint %} Visit the next section on how to create a sell order !","title":"Asset Discovery"},{"location":"ethereum/assets/asset-discovery/#asset-discovery","text":"","title":"Asset Discovery"},{"location":"ethereum/assets/asset-discovery/#search-items","text":"{% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for item-controller part {% endhint %} There are some controllers to query items: get all items get items by owner get items by collection other controllers in item-controller section of the api-reference These controllers have common parameters: size - how many items you want to get continuation - send this parameter to fetch next portion of data (you can find continuation value in the server response) also they have different query parameters for each. Please, see api-reference {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId/meta\" method=\"get\" summary=\"Item Metadata\" %} {% swagger-description %} Displays all item Metadata (Stored on IPFS) {% endswagger-description %} {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% endswagger-parameter %} {% swagger-response status=\"200\" description=\"\" %} { \"name\": \"string\", \"description\": \"string\", \"image\": \"string\", \"external_url\": \"string\", \"animation_url\": \"string\", \"attributes\": {} } {% endswagger-response %} {% endswagger %} {% swagger baseUrl=\"http://api.rarible.com/protocol/v0.1/ethereum/nft/items/\" path=\":itemId\" method=\"get\" summary=\"Item Data\" %} {% swagger-description %} Displays Item data such as Royalties, Unlockable content, etc. {% endswagger-description %} {% swagger-parameter in=\"path\" name=\"itemId\" type=\"string\" %} The itemId is built by using collectionAddress:tokenId - An example is 0x60f80121c31a0d46b5279700f9df786054aa5ee5:21 {% endswagger-parameter %} {% swagger-response status=\"200\" description=\"\" %} { \"id\": \"string\", \"token\": \"string\", \"tokenId\": 0, \"unlockable\": true, \"creator\": \"string\", \"supply\": 0, \"owners\": [ \"string\" ], \"royalties\": [ { \"recipient\": \"string\", \"value\": 0 } ] } {% endswagger-response %} {% endswagger %} {% hint style=\"danger\" %} If you wish to build an order for an ERC1155, it is important you also record the amount returned by the query. {% endhint %} Visit the next section on how to create a sell order !","title":"Search Items"},{"location":"ethereum/assets/creating-an-asset/","text":"Asset Creation Asset Introduction Rarible protocol has two asset types, ERC721, and ERC1155, the main difference between them is that ERC721 creates unique 1 of 1 item, whereas ERC1155, allows the user to create an item with multiple editions (The maximum amount of editions is 2**256 - 1). You can find the protocol smart contracts here. Ropsten Asset Contract ERC721 Etherscan link \u2197 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Asset Contract ERC1155 Etherscan link \u2197 0x6a94aC200342AC823F909F142a65232E2f052183 Rinkeby Asset Contract ERC721 Etherscan link \u2197 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 Asset Contract ERC1155 Etherscan link \u2197 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 Asset Types Explained ERC721 & ERC1155 With the new ERC721 & ERC1155 Asset contracts we no longer call the mint function directly, instead, we implement lazy minting via the mintAndTransfer function. Lazy minting allows the item to be created and store off-chain until someone purchases/transfers this item, only at this point does the item get created on-chain. Direct calls to mint() should be avoided and replaced with mintAndTransfer() . However, standard minting is still possible with this function. See ERC721 Standard Minting or ERC1155 Standard Minting for details. Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. {% endhint %} creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC721 Standard Minting . ERC721 mintAndTransfer ABI // ABI for ERC-721 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC721LazyMint.Mint721Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ERC721 Lazy Minting If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here . For 721 (Ropsten) Step 1 : Generate a token ID. GET from https://ethereum-api-dev.rarible.com/protocol/v0.1/ethereum/nft/collections/{ContractAddress}/generate_token_id?minter=${account} Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See EIP1271 for information on how smart contracts can interact with this order book. {% endhint %} First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint721\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint721\", version: \"1\", chainId: 3, verifyingContract: \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\" }, \"primaryType\": \"Mint721\", \"message\": { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\ ERC721 Standard Minting You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) struct Mint721Data { uint tokenId; string uri; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info {% endhint %} Example async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); } ERC1155 Overview mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) Mint1155Data Parameter Structure struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. {% endhint %} supply supply should be a uint256, this is the number of copies (or Editions) of this token that will ever exist. (Maximum value is 2**256 - 1). creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC1155 Standard Minting . ERC1155 mintAndTransfer ABI // ABI for ERC-1155 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"internalType\": \"uint256\", \"name\": \"supply\", \"type\": \"uint256\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC1155LazyMint.Mint1155Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"_amount\", \"type\": \"uint256\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ERC1155 Lazy Minting If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here . For 1155 (Ropsten) Step 1 : Generate a token ID. Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} // Sample Call const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator . { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See Signatures for more details on typed data and EIP-712 and EIP-1271. {% endhint %} First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint1155\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, { name: 'supply', type: 'uint256' }, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint1155\", version: \"1\", chainId: 3, verifyingContract: \"0x6a94aC200342AC823F909F142a65232E2f052183 \" }, \"primaryType\": \"Mint1155\", \"message\": { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10 \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\ ERC1155 Standard Minting You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info {% endhint %} Example async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , totalSupply , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , amount ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); } Uploading the image to IPFS The image needs to be hosted on IPFS, at Rarible we use pinata, below is a NodeJS example of uploading an image using their API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; This will return our IPFS CID, the full response looks like this: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) } Creating our NFT's Metadata Now that we have our IPFS CID (Called hash here on out), we can begin constructing our NFT's Metadata file that will be linked to the NFT on-chain. Below is a Metadata file with an explanation of the key and its value. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] } Adding Generated Metadata to IPFS First, we need to make sure our external_url is a Rarible link. We can calculate this link based on the tokenId we create (The tokenId typically is made up of two sections, the first 20 bytes in the users' address and the next 12 bytes can be any random number. We will provide an API to allow you to get the next free available ID.), for this example, our external_url must be the collection address + tokenId and it will look like this \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Notice we use the collection address and value address from our previous call to the tokens endpoint. Now we need to post our NFT's Metadata to IPFS below is an example of how to do this: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Our Result will look something similar to this: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Make a note of your new IpfsHash since this is now the hash we need to attach to our NFT. Custom Contracts If you are not storing your metadata on IPFS, you will need to use your own contracts that have a baseURI better suited for where the metadata is stored. As a starting point, so long as your contract follows the ERC-721 or ERC-1155 standard it's NFTs can be bought and sold on Rarible and most other NFT marketplaces. Helpful guides on these standards can be found at OpenZeppelin . However, you'll need to add more to support royalties and lazy minting as these are not built into the current standards. To support royalties, your contract will need to inherit from the appropriate interfaces, which you can find here or here for an upgradeable version. Similarly for lazy minting support, you will need to add a mintAndTransfer function in your contract for the protocol to call that inherits the expected behavior. You can add this yourself or use this interface . In many cases, it may be easier and faster to just fork the protocol contracts you wanted to use and change the baseURI and any other data upon deployment. {% hint style=\"info\" %} You can supply your own tokenId instead of getting one from the API call used for Lazy Minting when rolling your own contracts, however, the token id needs to have the minter's address followed by 96 bits, which can include any number you want, in order to pass the require checks in the default mintAndTransfer function. Alternatively, you can still use the generate token id API used above to supply a tokenId for them. {% endhint %} YAY! Your NFT is now minted! Visit the next section on how to create a sell order or to check if your Asset is indexed you can view this page .","title":"Creating"},{"location":"ethereum/assets/creating-an-asset/#asset-creation","text":"","title":"Asset Creation"},{"location":"ethereum/assets/creating-an-asset/#asset-introduction","text":"Rarible protocol has two asset types, ERC721, and ERC1155, the main difference between them is that ERC721 creates unique 1 of 1 item, whereas ERC1155, allows the user to create an item with multiple editions (The maximum amount of editions is 2**256 - 1). You can find the protocol smart contracts here.","title":"Asset Introduction"},{"location":"ethereum/assets/creating-an-asset/#ropsten","text":"","title":"Ropsten"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc721-etherscan-link","text":"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05","title":"Asset Contract ERC721 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc1155-etherscan-link","text":"0x6a94aC200342AC823F909F142a65232E2f052183","title":"Asset Contract ERC1155 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#rinkeby","text":"","title":"Rinkeby"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc721-etherscan-link_1","text":"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82","title":"Asset Contract ERC721 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-contract-erc1155-etherscan-link_1","text":"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7","title":"Asset Contract ERC1155 Etherscan link \u2197"},{"location":"ethereum/assets/creating-an-asset/#asset-types-explained","text":"","title":"Asset Types Explained"},{"location":"ethereum/assets/creating-an-asset/#erc721-erc1155","text":"With the new ERC721 & ERC1155 Asset contracts we no longer call the mint function directly, instead, we implement lazy minting via the mintAndTransfer function. Lazy minting allows the item to be created and store off-chain until someone purchases/transfers this item, only at this point does the item get created on-chain. Direct calls to mint() should be avoided and replaced with mintAndTransfer() . However, standard minting is still possible with this function. See ERC721 Standard Minting or ERC1155 Standard Minting for details. Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. {% endhint %} creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC721 Standard Minting . ERC721 mintAndTransfer ABI // ABI for ERC-721 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC721LazyMint.Mint721Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }","title":"ERC721 &amp; ERC1155"},{"location":"ethereum/assets/creating-an-asset/#erc721-lazy-minting","text":"If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here .","title":"ERC721 Lazy Minting"},{"location":"ethereum/assets/creating-an-asset/#for-721-ropsten","text":"Step 1 : Generate a token ID. GET from https://ethereum-api-dev.rarible.com/protocol/v0.1/ethereum/nft/collections/{ContractAddress}/generate_token_id?minter=${account} Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See EIP1271 for information on how smart contracts can interact with this order book. {% endhint %} First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint721\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint721\", version: \"1\", chainId: 3, verifyingContract: \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\" }, \"primaryType\": \"Mint721\", \"message\": { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\","title":"For 721 (Ropsten)"},{"location":"ethereum/assets/creating-an-asset/#erc721-standard-minting","text":"You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) struct Mint721Data { uint tokenId; string uri; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info {% endhint %}","title":"ERC721 Standard Minting"},{"location":"ethereum/assets/creating-an-asset/#example","text":"async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); }","title":"Example"},{"location":"ethereum/assets/creating-an-asset/#erc1155-overview","text":"mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) Mint1155Data Parameter Structure struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } Parameters tokenId The tokenId must be supplied as a uint256, which is a unique identifying number for the token. The tokenId is made up of two sections, the first 20 bytes is the user's address and the next 12 bytes can be any random number. This API will allow you to get the next available ID. uri This is the suffix for the tokenURI. The prefix for Rarible protocol contracts is ipfs:// Sample IPFS uri: /ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp Gets concatenated into the following upon minting: ipfs://ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp {% hint style=\"info\" %} If you are not storing your metadata on IPFS, you will need to create your own custom collection contract instead of using the protocol's asset contracts. See Implementation for details. {% endhint %} supply supply should be a uint256, this is the number of copies (or Editions) of this token that will ever exist. (Maximum value is 2**256 - 1). creators creators is an array of addresses and values. The LibPart.Part struct it derives from is provided below. struct Part { address payable account; uint96 value; } This array should contain all the addresses of the creators of this token with their respective ownership or contribution to the creation - in basis points. The address array is public and can be queried by anyone. Sum of the fields value in this array should be 10000 (100% in basis points). Can be divided in any number of ways. I.e. The following array, [[0x12345..., 5000], [0x6789..., 5000]] , associates the creation of the given NFT to 2 creators at an equal 50% distribution. royalties royalties is an array of addresses and values. Like creators , it's also derived from the LibPart.Part struct provided below. struct Part { address payable account; uint96 value; } The fees array is public and can be queried by anyone. Values are specified in basis points. For example, 2000 means 20%. I.e. One address recieves 20% royalties with the following array, [[0x12345..., 2000]] . But more than one address can be provided to recieve royalties at specified percentages. signatures signatures is an array of wallet signatures for this transaction from every creator. However, an empty signature, [[0x]] , can be passed if the creator is minting immediately instead of creating a Lazy Mint. The steps for standard minting are provided in ERC1155 Standard Minting . ERC1155 mintAndTransfer ABI // ABI for ERC-1155 mintAndTransfer { \"inputs\": [ { \"components\": [ { \"internalType\": \"uint256\", \"name\": \"tokenId\", \"type\": \"uint256\" }, { \"internalType\": \"string\", \"name\": \"uri\", \"type\": \"string\" }, { \"internalType\": \"uint256\", \"name\": \"supply\", \"type\": \"uint256\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"creators\", \"type\": \"tuple[]\" }, { \"components\": [ { \"internalType\": \"address payable\", \"name\": \"account\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"internalType\": \"struct LibPart.Part[]\", \"name\": \"royalties\", \"type\": \"tuple[]\" }, { \"internalType\": \"bytes[]\", \"name\": \"signatures\", \"type\": \"bytes[]\" } ], \"internalType\": \"struct LibERC1155LazyMint.Mint1155Data\", \"name\": \"data\", \"type\": \"tuple\" }, { \"internalType\": \"address\", \"name\": \"to\", \"type\": \"address\" }, { \"internalType\": \"uint256\", \"name\": \"_amount\", \"type\": \"uint256\" } ], \"name\": \"mintAndTransfer\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" }","title":"ERC1155 Overview"},{"location":"ethereum/assets/creating-an-asset/#erc1155-lazy-minting","text":"If you're storing your metadata on IPFS, you can mint through the Rarible Protocol asset contracts without conflict. Lazy minting requires the creator's signature in order to allow minting of their NFT when someone else purchases it and to retain its provenance. We'll go through the steps of getting the creator's signature and creating a lazy mint below. You can also find various code implementations for lazy minting here , here , and here .","title":"ERC1155 Lazy Minting"},{"location":"ethereum/assets/creating-an-asset/#for-1155-ropsten","text":"Step 1 : Generate a token ID. Since a lazy mint is stored off-chain, it's necessary to generate a token ID through this API to ensure you get the next available token ID since there's no certainty about when the NFT will actually be minted. GET from https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account} // Sample Call const res = await fetch('https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter=${account}').then((res) => res.json()); Response { tokenId: \"10269532675691974816893214588076010230265315839066808147818573374451427049545\", signature: { r: \"0x9f73810b77cee6ce00f3924091b22030ba707823bde53635d5ef2a3a1a605e8e\" s: \"0x00803ec40e179172973347ba9f1a8c8dd094e5b2e2e19504a09017f4358f2b1e\" v: 28 } } Get the tokenId from the response object. Step 2 : Create the Lazy Mint Request Body to be signed by the creator . { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Step 3 : Creator signs the provided typed data, thereby granting permission to mint their NFT upon purchase. {% hint style=\"info\" %} See Signatures for more details on typed data and EIP-712 and EIP-1271. {% endhint %} First , construct the typed data structure: \"types\": { \"EIP712Domain\" [ { type: \"string\", name: \"name\", }, { type: \"string\", name: \"version\", }, { type: \"uint256\", name: \"chainId\", }, { type: \"address\", name: \"verifyingContract\", } ], \"Mint1155\": [ {\"name\": \"@type\", \"type\": \"string\"}, {\"name\": \"contract\", \"type\": \"address\"}, {\"name\": \"tokenId\", \"type\": \"uint256\"}, {\"name\": \"tokenURI\", \"type\": \"string\"}, {\"name\": \"uri\", \"type\": \"string\"}, { name: 'supply', type: 'uint256' }, {\"name\": \"creators\", \"type\": \"Part[]\"}, {\"name\": \"royalties\", \"type\": \"Part[]\"} ], \"Part\": [ { name: \"account\", type: \"address\" }, { name: \"value\", type: \"uint96\" } ] }, \"domain\": { name: \"Mint1155\", version: \"1\", chainId: 3, verifyingContract: \"0x6a94aC200342AC823F909F142a65232E2f052183 \" }, \"primaryType\": \"Mint1155\", \"message\": { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"tokenURI\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\" \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], }; Then provide the data structure above to the creator for signing. // Sample code async function signTypedData(web3Provider, from, dataStructure) { const msgData = JSON.stringify(dataStructure); const signature = await web3Provider.send(\"eth_signTypedData_v4\", [from, msgData]); const sig0 = sig.substring(2); const r = \"0x\" + sig0.substring(0, 64); const s = \"0x\" + sig0.substring(64, 128); const v = parseInt(sig0.substring(128, 130), 16); return { dataStructure, signature, v, r, s, }; } Finally , get the signature from the object that the function above returns and add it as the final field of the Lazy Mint Request Body you created in Step 2. E.g. { \"@type\": \"ERC1155\", \"contract\": \"0x6a94aC200342AC823F909F142a65232E2f052183 \", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10, \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Step 4 : Create your Lazy Minted NFT. POST to https://ethereum-api-dev.rarible.org/v0.1/nft/mints { \"@type\": \"ERC721\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"uri\": \"/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp\", \"supply\": 10 \"creators\": [ { account: \"0x1234...\", value: \"10000\" } ], \"royalties\": [ { account: \"0x1234...\", value: 2000 } ], \"signatures\": [\"0x2f1e8dd2838930f0230a9fcbb2977779838eb8dd44391af1\u2026a6cb767fa157d5fb54c084e8ffb41be1c1bc5b6f067fd681b\"] }; Response { \"id\": \"\"0x3437df037bbbeb1aa3e417b32154bc2bb5da1c04:10269532675691974816893214588076010230265315839066808147818573374451427049549\"\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"creators\": [ { \"account\": \"0x1234...\", \"value\": 10000 } ] \"supply\": 1, \"lazySupply\": 1, \"owners\": [ \"0x1234...\" ], \"royalties\": [ { \"account\": \"0x1234...\", \"value\": 2000 } ], \"pending\": [ { \"date\": \"2019-08-24T14:15:22Z\", \"owner\": \"0x1234...\", \"from\": \"0x1234...\", \"contract\": \"0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05\", \"tokenId\": tokenId, \"value\": 0, \"type\": \"TRANSFER\" } ] } You've successfully created a Lazy Minted NFT with the Rarible Protocol! \ud83c\udf89 \\","title":"For 1155 (Ropsten)"},{"location":"ethereum/assets/creating-an-asset/#erc1155-standard-minting","text":"You can mint NFTs through the Rarible asset contracts using mintAndTransfer like you would for a standard mint call. You just need to provide all the expected parameters seen below. mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) struct Mint1155Data { uint tokenId; string uri; uint supply; LibPart.Part[] creators; LibPart.Part[] royalties; bytes[] signatures; } You can do so by instantiating the contract in your app and calling the function directly using ethers.js or web3.js . {% hint style=\"info\" %} For the signature, since you are minting an NFT as a direct call and not a lazy mint, you simply pass an empty signature. E.g. 0x . Royalties are set as basis point, so 1000 = 10%. More info {% endhint %}","title":"ERC1155 Standard Minting"},{"location":"ethereum/assets/creating-an-asset/#example_1","text":"async function mintNow () { // Get a token id const tokenId = await fetch ( `https://ethereum-api-dev.rarible.org/v0.1/nft/collections/{collection}/generate_token_id?minter= ${ account } ` ); // Instantiate the contract const provider = new ethers . providers . Web3Provider ( userWalletProvider ); const signer = provider . getSigner (); const contract = new ethers . Contract ( contractAddress , abi , signer ); // Call the function const tx = await contract . mintAndTransfer ( [ tokenId . tokenId , uri , totalSupply , [[ creator , 5000 ], [ creator2 , 5000 ]], // You can assign one or add multiple creators, but the value must total 10000 [[ creator , 1000 ], [ creator2 , 1000 ]], // Royalties are set as basis point, so 1000 = 10%. [ \"0x\" ] ], minter , amount ); const receipt = await tx . wait (); console . log ( 'Minting Success' , receipt ); }","title":"Example"},{"location":"ethereum/assets/creating-an-asset/#uploading-the-image-to-ipfs","text":"The image needs to be hosted on IPFS, at Rarible we use pinata, below is a NodeJS example of uploading an image using their API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; This will return our IPFS CID, the full response looks like this: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) }","title":"Uploading the image to IPFS"},{"location":"ethereum/assets/creating-an-asset/#creating-our-nfts-metadata","text":"Now that we have our IPFS CID (Called hash here on out), we can begin constructing our NFT's Metadata file that will be linked to the NFT on-chain. Below is a Metadata file with an explanation of the key and its value. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] }","title":"Creating our NFT's Metadata"},{"location":"ethereum/assets/creating-an-asset/#adding-generated-metadata-to-ipfs","text":"First, we need to make sure our external_url is a Rarible link. We can calculate this link based on the tokenId we create (The tokenId typically is made up of two sections, the first 20 bytes in the users' address and the next 12 bytes can be any random number. We will provide an API to allow you to get the next free available ID.), for this example, our external_url must be the collection address + tokenId and it will look like this \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Notice we use the collection address and value address from our previous call to the tokens endpoint. Now we need to post our NFT's Metadata to IPFS below is an example of how to do this: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Our Result will look something similar to this: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Make a note of your new IpfsHash since this is now the hash we need to attach to our NFT.","title":"Adding Generated Metadata to IPFS"},{"location":"ethereum/assets/creating-an-asset/#custom-contracts","text":"If you are not storing your metadata on IPFS, you will need to use your own contracts that have a baseURI better suited for where the metadata is stored. As a starting point, so long as your contract follows the ERC-721 or ERC-1155 standard it's NFTs can be bought and sold on Rarible and most other NFT marketplaces. Helpful guides on these standards can be found at OpenZeppelin . However, you'll need to add more to support royalties and lazy minting as these are not built into the current standards. To support royalties, your contract will need to inherit from the appropriate interfaces, which you can find here or here for an upgradeable version. Similarly for lazy minting support, you will need to add a mintAndTransfer function in your contract for the protocol to call that inherits the expected behavior. You can add this yourself or use this interface . In many cases, it may be easier and faster to just fork the protocol contracts you wanted to use and change the baseURI and any other data upon deployment. {% hint style=\"info\" %} You can supply your own tokenId instead of getting one from the API call used for Lazy Minting when rolling your own contracts, however, the token id needs to have the minter's address followed by 96 bits, which can include any number you want, in order to pass the require checks in the default mintAndTransfer function. Alternatively, you can still use the generate token id API used above to supply a tokenId for them. {% endhint %} YAY! Your NFT is now minted! Visit the next section on how to create a sell order or to check if your Asset is indexed you can view this page .","title":"Custom Contracts"},{"location":"ethereum/assets/royalties-on-a-external-collection/","text":"Setting Up Royalties on an External Collection Step 1: Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract Step 2: Make sure the active tab is Contract. Next, make sure Write as Proxy is selected near the top, and then click Connect to Web3 . Step 3: To set the royalties for the entire collection, expand the setRoyaltiesByToken function.\\ \\ You will now need to enter the collection address in the Token (Address) Field followed by the tuple (An example of a tuple is below) for royalties. \\ *\\ *The first part of the tuple must be the address where you'd like to receive the royalties, the second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. \\ \\ Please note the maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection (0x4008c2482357632b06526b492c143f4e73ff1b0d) the user (0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126) receives 2.5% (250) Royalties. Now we can go ahead and click on write which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection!\\ \\ Below is an example of a purchase transaction with annotations on what each fee is for: You now have royalties across Rarible Protocol Platforms, Congratulations!","title":"Setting Up Royalties on an External Collection"},{"location":"ethereum/assets/royalties-on-a-external-collection/#setting-up-royalties-on-an-external-collection","text":"","title":"Setting Up Royalties on an External Collection"},{"location":"ethereum/assets/royalties-on-a-external-collection/#step-1","text":"Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract","title":"Step 1:"},{"location":"ethereum/assets/royalties-on-a-external-collection/#step-2","text":"Make sure the active tab is Contract. Next, make sure Write as Proxy is selected near the top, and then click Connect to Web3 .","title":"Step 2:"},{"location":"ethereum/assets/royalties-on-a-external-collection/#step-3","text":"To set the royalties for the entire collection, expand the setRoyaltiesByToken function.\\ \\ You will now need to enter the collection address in the Token (Address) Field followed by the tuple (An example of a tuple is below) for royalties. \\ *\\ *The first part of the tuple must be the address where you'd like to receive the royalties, the second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. \\ \\ Please note the maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection (0x4008c2482357632b06526b492c143f4e73ff1b0d) the user (0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126) receives 2.5% (250) Royalties. Now we can go ahead and click on write which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection!\\ \\ Below is an example of a purchase transaction with annotations on what each fee is for: You now have royalties across Rarible Protocol Platforms, Congratulations!","title":"Step 3:&#x20;"},{"location":"ethereum/assets/royalties-schema/","text":"Royalties Schema Royalties V2 Rarible defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts . It exposes a method called getRoyalties which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. function getRaribleV2Royalties(uint256 id) override external view returns (LibPart.Part[] memory) { return royalties[id]; } Royalties V1 The exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry . The registry checks if the NFT contract supports the expected interface, and if so queries for the Rarible royalties array. This allows for Rarible to support different royalty standards for different collections. Rarible Protocol Supports on-chain Royalties, these are handled in the ExchangeV1 contract by the royalties array which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient & fees.value. fees.recipient refers to either the item owner (By default) or an address where the Royalties will be received. fees.value is the royalties percentage, by default this value is 1000 on Rarible which is a 10% royalties fee. This is done using basis points, more information regarding basis point can be found here . Below you can find the code block from ExchangeV1 which handles the on-chain Royalties. contract HasSecondarySaleFees is ERC165 { event SecondarySaleFees ( uint256 tokenId , address [] recipients , uint [] bps ); /* * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb * * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584 */ bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584 ; constructor () public { _registerInterface ( _INTERFACE_ID_FEES ); } function getFeeRecipients ( uint256 id ) public view returns ( address payable [] memory ); function getFeeBps ( uint256 id ) public view returns ( uint [] memory ); }","title":"Royalties Schema"},{"location":"ethereum/assets/royalties-schema/#royalties-schema","text":"","title":"Royalties Schema"},{"location":"ethereum/assets/royalties-schema/#royalties-v2","text":"Rarible defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts . It exposes a method called getRoyalties which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. function getRaribleV2Royalties(uint256 id) override external view returns (LibPart.Part[] memory) { return royalties[id]; }","title":"Royalties V2"},{"location":"ethereum/assets/royalties-schema/#royalties-v1","text":"The exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry . The registry checks if the NFT contract supports the expected interface, and if so queries for the Rarible royalties array. This allows for Rarible to support different royalty standards for different collections. Rarible Protocol Supports on-chain Royalties, these are handled in the ExchangeV1 contract by the royalties array which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient & fees.value. fees.recipient refers to either the item owner (By default) or an address where the Royalties will be received. fees.value is the royalties percentage, by default this value is 1000 on Rarible which is a 10% royalties fee. This is done using basis points, more information regarding basis point can be found here . Below you can find the code block from ExchangeV1 which handles the on-chain Royalties. contract HasSecondarySaleFees is ERC165 { event SecondarySaleFees ( uint256 tokenId , address [] recipients , uint [] bps ); /* * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb * * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584 */ bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584 ; constructor () public { _registerInterface ( _INTERFACE_ID_FEES ); } function getFeeRecipients ( uint256 id ) public view returns ( address payable [] memory ); function getFeeBps ( uint256 id ) public view returns ( uint [] memory ); }","title":"Royalties V1"},{"location":"ethereum/assets/token-factories/","text":"Token Factories You can easily create ERC721 and ERC1155 smart contracts using our Token Factories. Find addresses for token factories on Addresses page. Token Factories create Beacon proxies : this means Rarible Protocol can upgrade these contracts automatically (when all token contracts are upgraded). Currently, two token factories are available: ERC-721 and ERC-1155. These both contracts are public in terms of minting: anyone can mint tokens there. Invoke function createToken to create tokens with custom name, symbol. Set base uri to \"ipfs:/\" if you want to use ipfs for metadata storage. There are the parameters supported: name - name of the smart contract symbol - symbol of the smart contract base URI - prefix for the URI for created tokens (will be prepended to URI for every token minted). By default, use \"ipfs:/\" contractURI - URI holding metadata for the contract. Set https://api-mainnet.rarible.com/contractMetadata/{address} if you want to control metadata using Rarible UI","title":"Token Factories"},{"location":"ethereum/assets/token-factories/#token-factories","text":"You can easily create ERC721 and ERC1155 smart contracts using our Token Factories. Find addresses for token factories on Addresses page. Token Factories create Beacon proxies : this means Rarible Protocol can upgrade these contracts automatically (when all token contracts are upgraded). Currently, two token factories are available: ERC-721 and ERC-1155. These both contracts are public in terms of minting: anyone can mint tokens there. Invoke function createToken to create tokens with custom name, symbol. Set base uri to \"ipfs:/\" if you want to use ipfs for metadata storage. There are the parameters supported: name - name of the smart contract symbol - symbol of the smart contract base URI - prefix for the URI for created tokens (will be prepended to URI for every token minted). By default, use \"ipfs:/\" contractURI - URI holding metadata for the contract. Set https://api-mainnet.rarible.com/contractMetadata/{address} if you want to control metadata using Rarible UI","title":"Token Factories"},{"location":"ethereum/exchange/accepting-a-buy-order/","text":"Accepting a Buy Order To buy an item or accept a bid user should send transaction to Exchange contract's matchOrders function. {% hint style=\"info\" %} Example for sending matchOrders is here: https://github.com/evgenynacu/sign-typed-data/blob/ropsten/src/order/script.ts#L82 {% endhint %} matchOrders function defined in ExchangeV2Core has 4 parameters: left order. left order signature right order right order signature {% hint style=\"info\" %} more about order structure can be found here {% endhint %} Pay ETH for ERC721 You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. Encoded order { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"100000000000000000\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000005\" }, \"value\": \"1\" }, \"salt\": \"0\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Example transaction that has both a signed sell order and an unsigned buy order, submitted by the buyer. https://rinkeby.etherscan.io/tx/0x2d01b1869b556629acf7304b53d2f77fd927a2c3c9daea02aa093ba8ba41b4c6 Bid Orders A bid is just an unmatched buy order. The bidder submits the order to the indexer, like shown in Creating a sell order . The seller accepts it by creating a matched order.","title":"Accepting a Buy Order"},{"location":"ethereum/exchange/accepting-a-buy-order/#accepting-a-buy-order","text":"To buy an item or accept a bid user should send transaction to Exchange contract's matchOrders function. {% hint style=\"info\" %} Example for sending matchOrders is here: https://github.com/evgenynacu/sign-typed-data/blob/ropsten/src/order/script.ts#L82 {% endhint %} matchOrders function defined in ExchangeV2Core has 4 parameters: left order. left order signature right order right order signature {% hint style=\"info\" %} more about order structure can be found here {% endhint %}","title":"Accepting a Buy Order"},{"location":"ethereum/exchange/accepting-a-buy-order/#pay-eth-for-erc721","text":"You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. Encoded order { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"100000000000000000\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000005\" }, \"value\": \"1\" }, \"salt\": \"0\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Example transaction that has both a signed sell order and an unsigned buy order, submitted by the buyer. https://rinkeby.etherscan.io/tx/0x2d01b1869b556629acf7304b53d2f77fd927a2c3c9daea02aa093ba8ba41b4c6","title":"Pay ETH for ERC721"},{"location":"ethereum/exchange/accepting-a-buy-order/#bid-orders","text":"A bid is just an unmatched buy order. The bidder submits the order to the indexer, like shown in Creating a sell order . The seller accepts it by creating a matched order.","title":"Bid Orders"},{"location":"ethereum/exchange/contract-wallets/","text":"Contract Wallets Example implementation: https://rinkeby.etherscan.io/address/0x998Cf6fDd7FF1EB258c288762284142D28D0ee39#code EIP1271 allows a contract to delegate authorized signers. Usually EIP1271 expects an authorized delegate to submit a signature via the contract, and uses typical ECrecover to see if the signature is valid. EIP1271 returns valid signature: true** if the signature is valid & the signer is authorized by the contract ** not actually true , but instead a magic value to guard against mistaken 'true' bit The Rarible contract checks if the signature is valid with the following code require( ERC1271(order.maker).isValidSignature(_hashTypedDataV4(hash), signature) == MAGICVALUE, \"contract order signature verification error\" );","title":"Contract Wallets"},{"location":"ethereum/exchange/contract-wallets/#contract-wallets","text":"Example implementation: https://rinkeby.etherscan.io/address/0x998Cf6fDd7FF1EB258c288762284142D28D0ee39#code EIP1271 allows a contract to delegate authorized signers. Usually EIP1271 expects an authorized delegate to submit a signature via the contract, and uses typical ECrecover to see if the signature is valid. EIP1271 returns valid signature: true** if the signature is valid & the signer is authorized by the contract ** not actually true , but instead a magic value to guard against mistaken 'true' bit The Rarible contract checks if the signature is valid with the following code require( ERC1271(order.maker).isValidSignature(_hashTypedDataV4(hash), signature) == MAGICVALUE, \"contract order signature verification error\" );","title":"Contract Wallets"},{"location":"ethereum/exchange/creating-a-sell-order/","text":"Creating A Sell Order Creating an order Step 1. Approval We need to call approval on the transfer proxy contract. {% hint style=\"danger\" %} The approval on the transfer proxy only needs to be called if a previous approval does not exist. {% endhint %} Step 2. Creating signature Sell ERC721 for ETH You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. First Encode the order for signing POST to https://ethereum-api-staging.rarible.org/v0.1/order/encoder/order { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"3621\" } Response: { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000001\" }, \"value\": \"1\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"1000000000000000000\" }, \"salt\": \"3621\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Then Sign the order async function sign(provider, order, account, verifyingContract) { const chainId = Number(provider._network.chainId); const data = EIP712.createTypeData({ name: \"Exchange\", version: \"2\", chainId, verifyingContract }, 'Order', order, Types); console.log({data}) return (await EIP712.signTypedData(provider, account, data)).sig; } Step 3. Send order with signature to our API POST to https://ethereum-api-staging.rarible.org/v0.1/order/orders Payload { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"5422\", \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\" } Response { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x000000000000000000000000000000000000000000000000000000000000152e\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\", \"createdAt\": \"2021-05-25T02:04:28.836+00:00\", \"lastUpdateAt\": \"2021-05-25T02:04:28.983+00:00\", \"pending\": [], \"hash\": \"0xc9cb92588fc1434a417f4cacb9e1267750e6f1cbe650988a6fdc1d0be8a310a9\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.1365826056253000000000000000000 } {% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for createOrUpdateOrder {% endhint %}","title":"Creating A Sell Order"},{"location":"ethereum/exchange/creating-a-sell-order/#creating-a-sell-order","text":"","title":"Creating A Sell Order"},{"location":"ethereum/exchange/creating-a-sell-order/#creating-an-order","text":"Step 1. Approval We need to call approval on the transfer proxy contract. {% hint style=\"danger\" %} The approval on the transfer proxy only needs to be called if a previous approval does not exist. {% endhint %} Step 2. Creating signature","title":"Creating an order"},{"location":"ethereum/exchange/creating-a-sell-order/#sell-erc721-for-eth","text":"You can only fill an ETH order if your side of the order is providing the ETH . Otherwise you would have to use WETH which has the transferFrom capability. First Encode the order for signing POST to https://ethereum-api-staging.rarible.org/v0.1/order/encoder/order { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"3621\" } Response: { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"makeAsset\": { \"assetType\": { \"assetClass\": \"0x73ad2146\", \"data\": \"0x000000000000000000000000cfa14f6dc737b8f9e0fc39f05bf3d903ac5d45750000000000000000000000000000000000000000000000000000000000000001\" }, \"value\": \"1\" }, \"taker\": \"0x0000000000000000000000000000000000000000\", \"takeAsset\": { \"assetType\": { \"assetClass\": \"0xaaaebeba\", \"data\": \"0x\" }, \"value\": \"1000000000000000000\" }, \"salt\": \"3621\", \"start\": \"0\", \"end\": \"0\", \"dataType\": \"0x4c234266\", \"data\": \"0x0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" } Then Sign the order async function sign(provider, order, account, verifyingContract) { const chainId = Number(provider._network.chainId); const data = EIP712.createTypeData({ name: \"Exchange\", version: \"2\", chainId, verifyingContract }, 'Order', order, Types); console.log({data}) return (await EIP712.signTypedData(provider, account, data)).sig; } Step 3. Send order with signature to our API POST to https://ethereum-api-staging.rarible.org/v0.1/order/orders Payload { \"type\": \"RARIBLE_V2\", \"maker\": \"0x744222844bFeCC77156297a6427B5876A6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575\", \"tokenId\": 1 }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"salt\": \"5422\", \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\" } Response { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x000000000000000000000000000000000000000000000000000000000000152e\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0x45461654b86e856686e7a2e9a9213b29f8dc32a731046e0c2f1aa01e4eaa991e41ebc67535fac14c333ad5b0d0d821ef518edc9ed08ad7efc0af572620c045ce1c\", \"createdAt\": \"2021-05-25T02:04:28.836+00:00\", \"lastUpdateAt\": \"2021-05-25T02:04:28.983+00:00\", \"pending\": [], \"hash\": \"0xc9cb92588fc1434a417f4cacb9e1267750e6f1cbe650988a6fdc1d0be8a310a9\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.1365826056253000000000000000000 } {% hint style=\"info\" %} In order to get latest information about API, please follow OpenAPI doc for createOrUpdateOrder {% endhint %}","title":"Sell ERC721 for ETH"},{"location":"ethereum/exchange/exchangev2/","text":"Exchange Overview Asset matching The purpose of this is to validate that makeAsset of the left order matches takeAsset from the right order and vice versa. New types of assets can be added without a smart contract upgrade. This is done using a custom IAssetMatcher. There are possible improvements to the protocol using these custom matcher contracts such as: Support for parametric assets. For example, the user can put an order to exchange 10ETH for any NFT from a popular collection. Support for NFT bundles. The general process for completing an order with the Rarible Exchange is as follows: Seller approves the Rarible exchange contract to transfer NFT on their behalf Seller creates and signs an order. They specify the types and amounts of assets they would like in return. Seller submits the order to the indexer Potential buyers query the indexer to get sell orders for a specific item or collection Buyers can create a matching buy order for a sell order from the indexer. The buyer can then submit a matching buy order to the smart contract and execute the transfer (no sig required). Or the buyer can create a new bid and submit it to the indexer (requires signature) If the buyer submits a bid, the seller can choose to accept it by creating the matching sell order and submitting it to the contract, or they can send a signed order back to the buyer which the buyer would submit to the contract. Order Structure Each order (both buy & sell) consist of a makeAsset and a takeAsset Make Asset is what you are sending. In a buy order this is what you are paying for the seller's NFT. This can be ETH, ERC20, ERC721, ERC1155, or any custom asset using their Asset Matcher interface In a sell order this is the NFT you are selling Take Asset is what you are accepting in return In a buy order this is the NFT you are buying In a sell order this is what you are willing to accept. Order Field Description Required Maker Address of entity giving up makeAsset Yes makeAsset Asset the entity is giving up Yes taker Address of counterparty no, if 0 then anyone can fill the order takeAsset Asset the entity is receving Yes salt nonce for signatures submitted with the order Generally signatures are only needed if msg.sender != maker start uint - order can't be filled before this time no end uint - order can't be filled after this time no dataType bytes4, usually hash of a string like v1 or v2 Yes data generic bytes . Can be used for protocol extensions no Asset Field Description Required assetType Specifies ETH, specific ERC20, ERC721, ERC1155 Yes value uint Yes AssetType Field Description Required assetClass bytes4 specifies ETH, ERC20, ERC721 Yes data bytes - generic data depending on tp. Ex. address for ERC20, token + tokenID for ERC721 yes Asset Types Asset Class data field is calculated as follows bytes4 constant public ETH_ASSET_CLASS = bytes4(keccak256(\"ETH\")); bytes4 constant public ERC20_ASSET_CLASS = bytes4(keccak256(\"ERC20\")); bytes4 constant public ERC721_ASSET_CLASS = bytes4(keccak256(\"ERC721\")); bytes4 constant public ERC1155_ASSET_CLASS = bytes4(keccak256(\"ERC1155\")); All asset types get encoded using these helper functions https://github.com/rariblecom/protocol-contracts/blob/master/exchange-v2/test/assets.js ERC721 assetClass : Truncated hash of string \"ERC721\" data : ABI encoded parameters of address and tokenId value : 1 ERC721 Input (Pre encoding) { assetType: { assetClass: \"ERC721\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"1\", } ERC1155 assetClass : Truncated hash of string \"ERC1155\" data : ABI encoded parameters of address and tokenId value : 1->totalSupply ERC1155 Input (Pre encoding) { assetType: { assetClass: \"ERC1155\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"100\", } ERC20 assetClass : Truncated hash of string \"ERC20\" data : ABI encoded parameters of address value : 1->totalSupply ERC20 Input (Pre encoding) { assetType: { assetClass: \"ERC20\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", }, value: \"10000000000000000\", } ETH assetClass : Truncated hash of string \"ETH\" data : 0x value : 1->1e18 Input (pre encoding) { assetType: { assetClass: \"ETH\" }, value: \"10000000000000000\", }, Custom Asset Matcher Any asset can be added assetClass : Truncated hash of any string data : Whatever is relevant value : some uint Order validation Check the start/end date of the orders. Check if the taker of the order is blank or taker = order.taker Check if the order is signed by its maker or maker of the order is executing the transaction. If the maker of the order is a contract, then an ERC-1271 check is performed. {% hint style=\"info\" %} Currently, only off-chain orders are supported, this part of the smart contract can be easily updated to support on-chain order books. {% endhint %} Order execution Order execution is done by TransferManager. There are 2 variants: SimpleTransferManager (it simply transfers assets from maker to taker and vice versa). RaribleTransferManager (sophisticated version, it takes into account protocol commissions, royalties, etc). {% hint style=\"success\" %} There are plans to extend RaribleTransferManager to support more royalty schemes and add new features like custom fees, multiple order beneficiaries. {% endhint %} This part of the algorithm can be extended with a custom ITransferExecutor. In the future, new executors will be added to support new asset types, for example, executor for handling bundles can be added. {% hint style=\"info\" %} Possible improvements: Support bundles. Support random boxes. {% endhint %} Fees RaribleTransferManager supports these types of fees: Protocol fees (These fees are taken from both sides of the deal). Origin fees (Origin and origin fee is set for every order. it can be different for two orders involved). Royalties (Authors of the work will receive part of each sale). Fees calculation, fee side To take a fee we need to calculate, what side of the deal can be used as money. There is a simple algorithm to do it: If ETH is from any side of the deal, it's used. If not, then if ERC-20 is in the deal, it's used. If not, then if ERC-1155 is in the deal, it's used. Otherwise, the fee is not taken (for example, two ERC-721 are involved in the deal). When we established, what part of the deal can be treated as money, then we can establish, that The Buyer is the side of the deal who owns the money. The Seller is the other side of the deal. Then the total amount of the asset (money side) should be calculated Protocol fee is added on top of the filled amount. The origin fee of the buyer's order is added on top too. If the buyer is using an ERC-20 token for payment, then he must approve at least this calculated amount of tokens. If the buyer is using ETH, then he must send this calculated amount of ETH with the transaction.","title":"Exchange v2"},{"location":"ethereum/exchange/exchangev2/#exchange-overview","text":"","title":"Exchange Overview"},{"location":"ethereum/exchange/exchangev2/#asset-matching","text":"The purpose of this is to validate that makeAsset of the left order matches takeAsset from the right order and vice versa. New types of assets can be added without a smart contract upgrade. This is done using a custom IAssetMatcher. There are possible improvements to the protocol using these custom matcher contracts such as: Support for parametric assets. For example, the user can put an order to exchange 10ETH for any NFT from a popular collection. Support for NFT bundles. The general process for completing an order with the Rarible Exchange is as follows: Seller approves the Rarible exchange contract to transfer NFT on their behalf Seller creates and signs an order. They specify the types and amounts of assets they would like in return. Seller submits the order to the indexer Potential buyers query the indexer to get sell orders for a specific item or collection Buyers can create a matching buy order for a sell order from the indexer. The buyer can then submit a matching buy order to the smart contract and execute the transfer (no sig required). Or the buyer can create a new bid and submit it to the indexer (requires signature) If the buyer submits a bid, the seller can choose to accept it by creating the matching sell order and submitting it to the contract, or they can send a signed order back to the buyer which the buyer would submit to the contract.","title":"Asset matching"},{"location":"ethereum/exchange/exchangev2/#order-structure","text":"Each order (both buy & sell) consist of a makeAsset and a takeAsset Make Asset is what you are sending. In a buy order this is what you are paying for the seller's NFT. This can be ETH, ERC20, ERC721, ERC1155, or any custom asset using their Asset Matcher interface In a sell order this is the NFT you are selling Take Asset is what you are accepting in return In a buy order this is the NFT you are buying In a sell order this is what you are willing to accept.","title":"Order Structure"},{"location":"ethereum/exchange/exchangev2/#order","text":"Field Description Required Maker Address of entity giving up makeAsset Yes makeAsset Asset the entity is giving up Yes taker Address of counterparty no, if 0 then anyone can fill the order takeAsset Asset the entity is receving Yes salt nonce for signatures submitted with the order Generally signatures are only needed if msg.sender != maker start uint - order can't be filled before this time no end uint - order can't be filled after this time no dataType bytes4, usually hash of a string like v1 or v2 Yes data generic bytes . Can be used for protocol extensions no","title":"Order"},{"location":"ethereum/exchange/exchangev2/#asset","text":"Field Description Required assetType Specifies ETH, specific ERC20, ERC721, ERC1155 Yes value uint Yes","title":"Asset"},{"location":"ethereum/exchange/exchangev2/#assettype","text":"Field Description Required assetClass bytes4 specifies ETH, ERC20, ERC721 Yes data bytes - generic data depending on tp. Ex. address for ERC20, token + tokenID for ERC721 yes","title":"AssetType"},{"location":"ethereum/exchange/exchangev2/#asset-types","text":"Asset Class data field is calculated as follows bytes4 constant public ETH_ASSET_CLASS = bytes4(keccak256(\"ETH\")); bytes4 constant public ERC20_ASSET_CLASS = bytes4(keccak256(\"ERC20\")); bytes4 constant public ERC721_ASSET_CLASS = bytes4(keccak256(\"ERC721\")); bytes4 constant public ERC1155_ASSET_CLASS = bytes4(keccak256(\"ERC1155\")); All asset types get encoded using these helper functions https://github.com/rariblecom/protocol-contracts/blob/master/exchange-v2/test/assets.js","title":"Asset Types"},{"location":"ethereum/exchange/exchangev2/#erc721","text":"assetClass : Truncated hash of string \"ERC721\" data : ABI encoded parameters of address and tokenId value : 1 ERC721 Input (Pre encoding) { assetType: { assetClass: \"ERC721\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"1\", }","title":"ERC721"},{"location":"ethereum/exchange/exchangev2/#erc1155","text":"assetClass : Truncated hash of string \"ERC1155\" data : ABI encoded parameters of address and tokenId value : 1->totalSupply ERC1155 Input (Pre encoding) { assetType: { assetClass: \"ERC1155\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", tokenId: \"0xc66d094ed928f7840a6b0d373c1cd825c97e3c7c00000000000000000000000a\" }, value: \"100\", }","title":"ERC1155"},{"location":"ethereum/exchange/exchangev2/#erc20","text":"assetClass : Truncated hash of string \"ERC20\" data : ABI encoded parameters of address value : 1->totalSupply ERC20 Input (Pre encoding) { assetType: { assetClass: \"ERC20\", token: \"0x25646b08d9796ceda5fb8ce0105a51820740c049\", }, value: \"10000000000000000\", }","title":"ERC20"},{"location":"ethereum/exchange/exchangev2/#eth","text":"assetClass : Truncated hash of string \"ETH\" data : 0x value : 1->1e18 Input (pre encoding) { assetType: { assetClass: \"ETH\" }, value: \"10000000000000000\", },","title":"ETH"},{"location":"ethereum/exchange/exchangev2/#custom-asset-matcher","text":"Any asset can be added assetClass : Truncated hash of any string data : Whatever is relevant value : some uint","title":"Custom Asset Matcher"},{"location":"ethereum/exchange/exchangev2/#order-validation","text":"Check the start/end date of the orders. Check if the taker of the order is blank or taker = order.taker Check if the order is signed by its maker or maker of the order is executing the transaction. If the maker of the order is a contract, then an ERC-1271 check is performed. {% hint style=\"info\" %} Currently, only off-chain orders are supported, this part of the smart contract can be easily updated to support on-chain order books. {% endhint %}","title":"Order validation"},{"location":"ethereum/exchange/exchangev2/#order-execution","text":"Order execution is done by TransferManager. There are 2 variants: SimpleTransferManager (it simply transfers assets from maker to taker and vice versa). RaribleTransferManager (sophisticated version, it takes into account protocol commissions, royalties, etc). {% hint style=\"success\" %} There are plans to extend RaribleTransferManager to support more royalty schemes and add new features like custom fees, multiple order beneficiaries. {% endhint %} This part of the algorithm can be extended with a custom ITransferExecutor. In the future, new executors will be added to support new asset types, for example, executor for handling bundles can be added. {% hint style=\"info\" %} Possible improvements: Support bundles. Support random boxes. {% endhint %}","title":"Order execution"},{"location":"ethereum/exchange/exchangev2/#fees","text":"RaribleTransferManager supports these types of fees: Protocol fees (These fees are taken from both sides of the deal). Origin fees (Origin and origin fee is set for every order. it can be different for two orders involved). Royalties (Authors of the work will receive part of each sale). Fees calculation, fee side To take a fee we need to calculate, what side of the deal can be used as money. There is a simple algorithm to do it: If ETH is from any side of the deal, it's used. If not, then if ERC-20 is in the deal, it's used. If not, then if ERC-1155 is in the deal, it's used. Otherwise, the fee is not taken (for example, two ERC-721 are involved in the deal). When we established, what part of the deal can be treated as money, then we can establish, that The Buyer is the side of the deal who owns the money. The Seller is the other side of the deal. Then the total amount of the asset (money side) should be calculated Protocol fee is added on top of the filled amount. The origin fee of the buyer's order is added on top too. If the buyer is using an ERC-20 token for payment, then he must approve at least this calculated amount of tokens. If the buyer is using ETH, then he must send this calculated amount of ETH with the transaction.","title":"Fees"},{"location":"ethereum/exchange/order-discovery/","text":"Order Discovery Search orders Example of how to query orders for all NFTs in a collection curl --location --request GET 'https://ethereum-api-staging.rarible.org/v0.1/order/orders/sell/byCollection?collection=0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575&sort=LAST_UPDATE' Response { \"orders\": [ { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x00000000000000000000000000000000000000000000000000000000000002b3\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0xf45a9adfb58fdd9da808b5f80302ebdb7d75f032d6aaee9700ee93f567fff3b148116a93ad2bd908a2d8e9576295650460a653d442f7c3472cb8f1275739075e1c\", \"createdAt\": \"2021-05-25T01:33:43.358+00:00\", \"lastUpdateAt\": \"2021-05-25T01:33:43.532+00:00\", \"pending\": [], \"hash\": \"0x0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.136582605625300000000000000000 } ], \"continuation\": \"1621906423532_0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\" } For more information on the order indexer and options for discoring orders, see the API Reference","title":"Order Discovery"},{"location":"ethereum/exchange/order-discovery/#order-discovery","text":"","title":"Order Discovery"},{"location":"ethereum/exchange/order-discovery/#search-orders","text":"Example of how to query orders for all NFTs in a collection curl --location --request GET 'https://ethereum-api-staging.rarible.org/v0.1/order/orders/sell/byCollection?collection=0xcfa14f6DC737b8f9e0fC39f05Bf3d903aC5D4575&sort=LAST_UPDATE' Response { \"orders\": [ { \"maker\": \"0x744222844bfecc77156297a6427b5876a6769e19\", \"make\": { \"assetType\": { \"assetClass\": \"ERC721\", \"contract\": \"0xcfa14f6dc737b8f9e0fc39f05bf3d903ac5d4575\", \"tokenId\": \"1\" }, \"value\": \"1\" }, \"take\": { \"assetType\": { \"assetClass\": \"ETH\" }, \"value\": \"1000000000000000000\" }, \"type\": \"RARIBLE_V2\", \"fill\": \"0\", \"makeStock\": \"1\", \"cancelled\": false, \"salt\": \"0x00000000000000000000000000000000000000000000000000000000000002b3\", \"data\": { \"dataType\": \"RARIBLE_V2_DATA_V1\", \"payouts\": [], \"originFees\": [] }, \"signature\": \"0xf45a9adfb58fdd9da808b5f80302ebdb7d75f032d6aaee9700ee93f567fff3b148116a93ad2bd908a2d8e9576295650460a653d442f7c3472cb8f1275739075e1c\", \"createdAt\": \"2021-05-25T01:33:43.358+00:00\", \"lastUpdateAt\": \"2021-05-25T01:33:43.532+00:00\", \"pending\": [], \"hash\": \"0x0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\", \"makeBalance\": \"1\", \"takePriceUsd\": 2735.136582605625300000000000000000 } ], \"continuation\": \"1621906423532_0b3007a2a4cd8701f98b8fd02f2a9bc09320d11d5e4fa8134f884904d8bfdf3b\" } For more information on the order indexer and options for discoring orders, see the API Reference","title":"Search orders"},{"location":"ethereum/exchange/updating-cancelling-an-order/","text":"Updating/Canceling an Order Updating an Order To update an order we need to make the changes and send a POST request to the API this can be found on the Creating A Sell Order page . New Orders check the Start, End, taker, make and value. If any of these are invalid you will receive a 400 response code from the API. {% hint style=\"danger\" %} The price can only be lowered and not increased, to increase the price you will need to cancel the order and create a new one. {% endhint %} Canceling an Order Canceling an order needs to be done on-chain by calling the cancel method on the exchange contract . function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); }","title":"Updating/Canceling an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#updatingcanceling-an-order","text":"","title":"Updating/Canceling an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#updating-an-order","text":"To update an order we need to make the changes and send a POST request to the API this can be found on the Creating A Sell Order page . New Orders check the Start, End, taker, make and value. If any of these are invalid you will receive a 400 response code from the API. {% hint style=\"danger\" %} The price can only be lowered and not increased, to increase the price you will need to cancel the order and create a new one. {% endhint %}","title":"Updating an Order"},{"location":"ethereum/exchange/updating-cancelling-an-order/#canceling-an-order","text":"Canceling an order needs to be done on-chain by calling the cancel method on the exchange contract . function cancel(LibOrder.Order memory order) public { require(_msgSender() == order.maker, \"not a maker\"); bytes32 orderKeyHash = LibOrder.hashKey(order); fills[orderKeyHash] = UINT256_MAX; emit Cancel(orderKeyHash); }","title":"Canceling an Order"},{"location":"ethereum/sdk/ethereum-sdk/","text":"Ethereum SDK The Rarible Protocol Ethereum SDK enables applications to easily interact with Rarible protocol. Installation npm install -D @rarible/protocol-ethereum-sdk With the Rarible Protocol Ethereum SDK, you can: Create sell orders \ud83d\udcb0 Create/accept bid for auctions Buy tokens for regular sell orders Create Lazy Mint NFT ERC721 and ERC1155 tokens Make regular mint Transfer tokens Burn tokens Usage The examples below can show how you can implement supported functions in you app. Configure and create Rarible SDK object import { createRaribleSdk } from \"@rarible/protocol-ethereum-sdk\" const sdk = createRaribleSdk(web3, env, { fetchApi: fetch }) web3 - configured with your provider web3js client env - environment configuration name, it should accept one of these values 'ropsten' | 'rinkeby' | 'mainnet' | 'e2e' Create sell order const order: Order = await sdk.order.sell(request).then(a => a.runAll()) // Sell request example: const contractErc20Address: Address = '0x0' // your ERC20 contract address const contractErc721Address: Address = '0x0' // your ERC721 contract address const tokenId: BigNumber = '0x0' // the ERC721 Id of the token on which we want to place a bid const sellerAddress: Address = '0x0' // Owner of ERC721 token const nftAmount: number = 1 // For ERC721 always be 1 const sellPrice: number = 10 // price per unit of ERC721 or ERC1155 token(s) const request = { makeAssetType: { assetClass: \"ERC1155\", contract: contractErc721Address, tokenId: tokenId, }, maker: sellerAddress, amount: nftAmount, originFees: [], payouts: [], price: sellPrice, takeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address }, } Returns an object of created order. Sell e2e test Create bid const order: Order = await sdk.order.bid(request).then(a => a.runAll()) // Bid request example: const contractErc20Address: Address = '0x0' // your ERC20 contract address const contractErc721Address: Address = '0x0' // your ERC721 contract address const tokenId: BigNumber = '0x0' // the ERC721 Id of the token on which we want to place a bid const sellerAddress: Address = '0x0' // Owner of ERC721 token const buyerAddress: Address = '0x0' // Who make a bid const nftAmount: number = 1 // For ERC721 always be 1 const bidPrice: number = 10 // price per unit of ERC721 or ERC1155 token(s) const request = { makeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address, }, maker: buyerAddress, takeAssetType: { assetClass: \"ERC721\", contract: contractErc721Address, tokenId: tokenId, }, taker: sellerAddress, amount: nftAmount, originFees: [], payouts: [], price: bidPrice, } Returns an object of created bid order. Bid e2e test Purchase order or accept bid (fill order) const order: SimpleOrder sdk.order.fill( order, { payouts: [], originFees: [], amount: 1, infinite: true } ).then(a => a.runAll()) For example, you can get the order object using our sdk api methods sdk.apis.order.getSellOrders({}) and pass it to fill function. You can get more information in the test repository sell e2e test Mint NFT Tokens There are support two ways of minting ERC721 and ERC1155 tokens: Regular \"on chain\" minting using contract. Off chain minting (the transaction itself and payment for gas occurs at the time of purchase or transfer) Mint request object const mintRequest = { collection: { id: toAddress(contractAddress), // contract address type: \"ERC1155\", // type of asset to mint, \"ERC721\" || \"ERC1155\" supportsLazyMint: true, // true if contract supports lazy minting }, uri: 'uri', // token uri supply: toBigNumber('100'), // supply - used only for ERC1155 tokens creators: [{ account: toAddress(minter), value: 10000 }], // creators of token royalties: [], // royalties lazy: true, // true if mint lazy or false when mint onchain } Mint examples Mint function always return tokenId as string ERC721 Lazy const tokenId = await mint({ collection: { id: toAddress(contractAddress), type: \"ERC721\", supportsLazyMint: true, }, uri: 'uri', creators: [{ account: toAddress(minter), value: 10000 }], royalties: [], lazy: true, }) ERC1155 Lazy const tokenId = await mint({ collection: { id: toAddress(contractAddress), type: \"ERC1155\", supportsLazyMint: true, }, uri: 'uri', supply: toBigNumber('100'), creators: [{ account: toAddress(minter), value: 10000 }], royalties: [], lazy: true, }) ERC721 await mint({ collection: { id: toAddress(contractAddress), type: \"ERC721\", supportsLazyMint: true, }, uri: 'uri', creators: [{ account: toAddress(minter), value: 10000 }], royalties: [], }) ERC1155 const tokenId = await mint({ collection: { id: toAddress(contractAddress), type: \"ERC1155\", supportsLazyMint: true, }, uri: 'uri', supply: toBigNumber('100'), creators: [{ account: toAddress(minter), value: 10000 }], royalties: [], }) Mint e2e test Transfer transfer(asset, to[, amount]) Transfer request params: asset: { tokenId: BigNumber, // - id of token to transfer contract: Address, // - address of token contract assetClass?: \"ERC721\" | \"ERC1155\" // - not required, type of asset } to: Address, // - ethereum address of receiver of token amount: BigNumber // - amount of asset to transfer, used only for ERC1155 assets Example const hash = await sdk.nft.transfer( { assetClass: \"ERC1155\", contract: toAddress(contractAddress), tokenId: toBigNumber(tokenId), }, receiverAddress, toAddress('10') ) Burn const hash = await sdk.nft.burn({ contract: contractAddress, tokenId: toBigNumber(tokenId), })","title":"Ethereum SDK"},{"location":"ethereum/sdk/ethereum-sdk/#ethereum-sdk","text":"The Rarible Protocol Ethereum SDK enables applications to easily interact with Rarible protocol.","title":"Ethereum SDK"},{"location":"ethereum/sdk/ethereum-sdk/#installation","text":"npm install -D @rarible/protocol-ethereum-sdk","title":"Installation"},{"location":"ethereum/sdk/ethereum-sdk/#with-the-rarible-protocol-ethereum-sdk-you-can","text":"Create sell orders \ud83d\udcb0 Create/accept bid for auctions Buy tokens for regular sell orders Create Lazy Mint NFT ERC721 and ERC1155 tokens Make regular mint Transfer tokens Burn tokens","title":"With the Rarible Protocol Ethereum SDK, you can:"},{"location":"ethereum/sdk/ethereum-sdk/#usage","text":"The examples below can show how you can implement supported functions in you app.","title":"Usage"},{"location":"ethereum/sdk/ethereum-sdk/#configure-and-create-rarible-sdk-object","text":"import { createRaribleSdk } from \"@rarible/protocol-ethereum-sdk\" const sdk = createRaribleSdk(web3, env, { fetchApi: fetch }) web3 - configured with your provider web3js client env - environment configuration name, it should accept one of these values 'ropsten' | 'rinkeby' | 'mainnet' | 'e2e'","title":"Configure and create Rarible SDK object"},{"location":"ethereum/sdk/ethereum-sdk/#create-sell-order","text":"const order: Order = await sdk.order.sell(request).then(a => a.runAll()) // Sell request example: const contractErc20Address: Address = '0x0' // your ERC20 contract address const contractErc721Address: Address = '0x0' // your ERC721 contract address const tokenId: BigNumber = '0x0' // the ERC721 Id of the token on which we want to place a bid const sellerAddress: Address = '0x0' // Owner of ERC721 token const nftAmount: number = 1 // For ERC721 always be 1 const sellPrice: number = 10 // price per unit of ERC721 or ERC1155 token(s) const request = { makeAssetType: { assetClass: \"ERC1155\", contract: contractErc721Address, tokenId: tokenId, }, maker: sellerAddress, amount: nftAmount, originFees: [], payouts: [], price: sellPrice, takeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address }, } Returns an object of created order. Sell e2e test","title":"Create sell order"},{"location":"ethereum/sdk/ethereum-sdk/#create-bid","text":"const order: Order = await sdk.order.bid(request).then(a => a.runAll()) // Bid request example: const contractErc20Address: Address = '0x0' // your ERC20 contract address const contractErc721Address: Address = '0x0' // your ERC721 contract address const tokenId: BigNumber = '0x0' // the ERC721 Id of the token on which we want to place a bid const sellerAddress: Address = '0x0' // Owner of ERC721 token const buyerAddress: Address = '0x0' // Who make a bid const nftAmount: number = 1 // For ERC721 always be 1 const bidPrice: number = 10 // price per unit of ERC721 or ERC1155 token(s) const request = { makeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address, }, maker: buyerAddress, takeAssetType: { assetClass: \"ERC721\", contract: contractErc721Address, tokenId: tokenId, }, taker: sellerAddress, amount: nftAmount, originFees: [], payouts: [], price: bidPrice, } Returns an object of created bid order. Bid e2e test","title":"Create bid"},{"location":"ethereum/sdk/ethereum-sdk/#purchase-order-or-accept-bid-fill-order","text":"const order: SimpleOrder sdk.order.fill( order, { payouts: [], originFees: [], amount: 1, infinite: true } ).then(a => a.runAll()) For example, you can get the order object using our sdk api methods sdk.apis.order.getSellOrders({}) and pass it to fill function. You can get more information in the test repository sell e2e test Mint NFT Tokens There are support two ways of minting ERC721 and ERC1155 tokens: Regular \"on chain\" minting using contract. Off chain minting (the transaction itself and payment for gas occurs at the time of purchase or transfer)","title":"Purchase order or accept bid (fill order)"},{"location":"ethereum/sdk/ethereum-sdk/#mint-request-object","text":"const mintRequest = { collection: { id: toAddress(contractAddress), // contract address type: \"ERC1155\", // type of asset to mint, \"ERC721\" || \"ERC1155\" supportsLazyMint: true, // true if contract supports lazy minting }, uri: 'uri', // token uri supply: toBigNumber('100'), // supply - used only for ERC1155 tokens creators: [{ account: toAddress(minter), value: 10000 }], // creators of token royalties: [], // royalties lazy: true, // true if mint lazy or false when mint onchain } Mint examples Mint function always return tokenId as string","title":"Mint request object"},{"location":"ethereum/sdk/ethereum-sdk/#erc721-lazy","text":"const tokenId = await mint({ collection: { id: toAddress(contractAddress), type: \"ERC721\", supportsLazyMint: true, }, uri: 'uri', creators: [{ account: toAddress(minter), value: 10000 }], royalties: [], lazy: true, })","title":"ERC721 Lazy"},{"location":"ethereum/sdk/ethereum-sdk/#erc1155-lazy","text":"const tokenId = await mint({ collection: { id: toAddress(contractAddress), type: \"ERC1155\", supportsLazyMint: true, }, uri: 'uri', supply: toBigNumber('100'), creators: [{ account: toAddress(minter), value: 10000 }], royalties: [], lazy: true, })","title":"ERC1155 Lazy"},{"location":"ethereum/sdk/ethereum-sdk/#erc721","text":"await mint({ collection: { id: toAddress(contractAddress), type: \"ERC721\", supportsLazyMint: true, }, uri: 'uri', creators: [{ account: toAddress(minter), value: 10000 }], royalties: [], })","title":"ERC721"},{"location":"ethereum/sdk/ethereum-sdk/#erc1155","text":"const tokenId = await mint({ collection: { id: toAddress(contractAddress), type: \"ERC1155\", supportsLazyMint: true, }, uri: 'uri', supply: toBigNumber('100'), creators: [{ account: toAddress(minter), value: 10000 }], royalties: [], }) Mint e2e test","title":"ERC1155"},{"location":"ethereum/sdk/ethereum-sdk/#transfer","text":"transfer(asset, to[, amount]) Transfer request params: asset: { tokenId: BigNumber, // - id of token to transfer contract: Address, // - address of token contract assetClass?: \"ERC721\" | \"ERC1155\" // - not required, type of asset } to: Address, // - ethereum address of receiver of token amount: BigNumber // - amount of asset to transfer, used only for ERC1155 assets Example const hash = await sdk.nft.transfer( { assetClass: \"ERC1155\", contract: toAddress(contractAddress), tokenId: toBigNumber(tokenId), }, receiverAddress, toAddress('10') )","title":"Transfer"},{"location":"ethereum/sdk/ethereum-sdk/#burn","text":"const hash = await sdk.nft.burn({ contract: contractAddress, tokenId: toBigNumber(tokenId), })","title":"Burn"},{"location":"ethereum/smart-contracts/architecture/","text":"Smart Contract Architecture Rarible exchange smart contracts are built using OpenZeppelin's upgradeable smart contracts library. So the smart contract code can be updated to support new features, fix bugs, etc. Smart contracts are heavily tested, tests are provided in the test folder. Functionality is divided into parts (each responsible for the part of the algorithm). Essentially, ExchangeV2 is a smart contract for the decentralized exchange of any assets presented on Ethereum (or EVM compatible) blockchain.","title":"Smart Contract Architecture"},{"location":"ethereum/smart-contracts/architecture/#smart-contract-architecture","text":"Rarible exchange smart contracts are built using OpenZeppelin's upgradeable smart contracts library. So the smart contract code can be updated to support new features, fix bugs, etc. Smart contracts are heavily tested, tests are provided in the test folder. Functionality is divided into parts (each responsible for the part of the algorithm). Essentially, ExchangeV2 is a smart contract for the decentralized exchange of any assets presented on Ethereum (or EVM compatible) blockchain.","title":"Smart Contract Architecture"},{"location":"ethereum/smart-contracts/auction/","text":"Auction This contract implements English auction with fixed step. ...","title":"Auction"},{"location":"ethereum/smart-contracts/auction/#auction","text":"This contract implements English auction with fixed step. ...","title":"Auction"},{"location":"ethereum/smart-contracts/matching-orders/","text":"Matching Orders Overview In the Exchange Contract , there is the matchOrders function. This function takes two sides of order (The Seller Order & Buy order) and attempts to match them. The Matching Algorithm can be extended by using a custom IAssetMatcher. The Matching Algorithm can be divided into several steps listed below: Order Validation - This is checks the order parameters are valid and the caller is authorized to execute the order. Asset Matching - This checks that the assets from left and right order match and then extracts the matching assets. Calculating The Fill - This checks and finds out what exact values should be filled. Orders can also be matched partly, this occurs if one of the sides doesn't want to fill other orders completely. Order Execution - This executes the transfers (Swap) of the assets and will save the fill of the order if needed. Order Validation If the msg.sender matches the address which placed the order we do not check for validation. Verifying the signatures, if the request is submitted via a contract we validate the signature via EIP-1271 If verification is not successful, then we need to validate the order in an external contract, this is done on-chain via an external contract (Possibly a custom IAssetMatcher). Asset Matching The opposite sides of the order must match at least one side of the order, this is done within the contract for simple assets. Complex asset swaps are done via our registry within which custom matching contracts are registered and controlled. Next, we emit stating the order was successfully matched. Calculating The Fill This is how long the order takes to be executed, we save this for orders that are not sent by the msg.sender to prevent wasting gas. Order Execution This is where we determine which assets need to be transferred from each party. Our external contract considers the transfer list. Below is the structure of the transfer list Asset - Assets to be Swapped. Amount - Amount of Ether/ERC20/ERC721/ERC1155 token to be swapped. From - Address the Buy Order is sending assets from. To - Address the Sell Order is sending assets from. Type - Type can be one of several items like \"protocol\" | \"fee\" | \"royalty\" | \"maker\" | \"taker\" - can be expanded. This will be done in bytes32. Translations & Event Emits The transfer events are emitted through the proxy register, this makes it so custom transfers are possible.","title":"Matching Orders"},{"location":"ethereum/smart-contracts/matching-orders/#matching-orders","text":"","title":"Matching Orders"},{"location":"ethereum/smart-contracts/matching-orders/#overview","text":"In the Exchange Contract , there is the matchOrders function. This function takes two sides of order (The Seller Order & Buy order) and attempts to match them. The Matching Algorithm can be extended by using a custom IAssetMatcher. The Matching Algorithm can be divided into several steps listed below: Order Validation - This is checks the order parameters are valid and the caller is authorized to execute the order. Asset Matching - This checks that the assets from left and right order match and then extracts the matching assets. Calculating The Fill - This checks and finds out what exact values should be filled. Orders can also be matched partly, this occurs if one of the sides doesn't want to fill other orders completely. Order Execution - This executes the transfers (Swap) of the assets and will save the fill of the order if needed.","title":"Overview"},{"location":"ethereum/smart-contracts/matching-orders/#order-validation","text":"If the msg.sender matches the address which placed the order we do not check for validation. Verifying the signatures, if the request is submitted via a contract we validate the signature via EIP-1271 If verification is not successful, then we need to validate the order in an external contract, this is done on-chain via an external contract (Possibly a custom IAssetMatcher).","title":"Order Validation"},{"location":"ethereum/smart-contracts/matching-orders/#asset-matching","text":"The opposite sides of the order must match at least one side of the order, this is done within the contract for simple assets. Complex asset swaps are done via our registry within which custom matching contracts are registered and controlled. Next, we emit stating the order was successfully matched.","title":"Asset Matching"},{"location":"ethereum/smart-contracts/matching-orders/#calculating-the-fill","text":"This is how long the order takes to be executed, we save this for orders that are not sent by the msg.sender to prevent wasting gas.","title":"Calculating The Fill"},{"location":"ethereum/smart-contracts/matching-orders/#order-execution","text":"This is where we determine which assets need to be transferred from each party. Our external contract considers the transfer list. Below is the structure of the transfer list Asset - Assets to be Swapped. Amount - Amount of Ether/ERC20/ERC721/ERC1155 token to be swapped. From - Address the Buy Order is sending assets from. To - Address the Sell Order is sending assets from. Type - Type can be one of several items like \"protocol\" | \"fee\" | \"royalty\" | \"maker\" | \"taker\" - can be expanded. This will be done in bytes32.","title":"Order Execution"},{"location":"ethereum/smart-contracts/matching-orders/#translations-event-emits","text":"The transfer events are emitted through the proxy register, this makes it so custom transfers are possible.","title":"Translations &amp; Event Emits"},{"location":"flow/flow-overview/","text":"Flow overview Flow is a fast, decentralized, and developer-friendly blockchain, designed as the foundation for a new generation of games, apps, and the digital assets that power them. Protocol Flow ... SDK ... Smart Contracts ...","title":"Flow overview"},{"location":"flow/flow-overview/#flow-overview","text":"Flow is a fast, decentralized, and developer-friendly blockchain, designed as the foundation for a new generation of games, apps, and the digital assets that power them.","title":"Flow overview"},{"location":"flow/flow-overview/#protocol-flow","text":"...","title":"Protocol Flow"},{"location":"flow/flow-overview/#sdk","text":"...","title":"SDK"},{"location":"flow/flow-overview/#smart-contracts","text":"...","title":"Smart Contracts"},{"location":"getting-started/protocol-example/","text":"Example app You can create a Protocol Example App for a quick start. In this example you can: Configure Rarible SDK Create Lazy mint NFT item Create sell order Purchase (buy item) an order Get your own NFT from your current wallet Also, you can try scaffold-eth Rarible Starter App . Example of NFT purchase flow Click buy NFT in the app. The frontend calls the Buy function in the Union SDK. Union SDK calls the Buy function in the SDK of the desired network. SDK prepares and sends the transaction to the underlying blockchain. Indexer listens to purchase, transfer events, updates NFT state internally. Indexer transmits the event to Union. Union sends the information about the event to the backend of the application.","title":"Protocol Example"},{"location":"getting-started/protocol-example/#example-app","text":"You can create a Protocol Example App for a quick start. In this example you can: Configure Rarible SDK Create Lazy mint NFT item Create sell order Purchase (buy item) an order Get your own NFT from your current wallet Also, you can try scaffold-eth Rarible Starter App .","title":"Example app"},{"location":"getting-started/protocol-example/#example-of-nft-purchase-flow","text":"Click buy NFT in the app. The frontend calls the Buy function in the Union SDK. Union SDK calls the Buy function in the SDK of the desired network. SDK prepares and sends the transaction to the underlying blockchain. Indexer listens to purchase, transfer events, updates NFT state internally. Indexer transmits the event to Union. Union sends the information about the event to the backend of the application.","title":"Example of NFT purchase flow"},{"location":"getting-started/use-cases/coconft/","text":"CoCoNFT TLDR: CoCo NFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. CoCoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. CoCoNFT uses lazy minting so that the creators dont have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How CocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found alot of frameworks we would have used something like starter app to jumpstart our development process. In regards to the database side CocoNFT advises to understand how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for CocoNFT.","title":"CoCo NFT"},{"location":"getting-started/use-cases/coconft/#coconft","text":"TLDR: CoCo NFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. CoCoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. CoCoNFT uses lazy minting so that the creators dont have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How CocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found alot of frameworks we would have used something like starter app to jumpstart our development process. In regards to the database side CocoNFT advises to understand how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for CocoNFT.","title":"CoCoNFT"},{"location":"getting-started/use-cases/mintgate/","text":"MintGate TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"getting-started/use-cases/mintgate/#mintgate","text":"TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note: Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"getting-started/use-cases/picnic/","text":"Picnic We use Rarible to help us identify NFTs from creators and collectors in the [Picnic] showcase. The [Rarible API] provides a few great endpoints for fetching the necessary data. API Calls The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org Getting Tokens by Owner Paginate through owned tokens import axios from 'axios'; /* * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return / const fetchOwnedTokens = async (owner, opts = {}) => { const { continuation, size = 100 } = opts; try { const result = await axios.get('https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner', { params: { owner, continuation }, }); const { data } = result; // Paginate results let hist = []; if (data.continuation && data.items.length === size) { hist = await getOwnedTokens(owner, { ...opts, continuation: data.continuation }); } // Return full history return [...data.items, ...hist]; } catch (err) { console.error(err); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios'; /* * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} / const fetchTokenMetadata = async id => { const { data } = await axios.get( https://api.rarible.com/protocol/v0.1/ethereum/nft/items/${id}/meta ); if (!data?.name) { throw new Error('Invalid NFT data', { id, data }); } return data; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Picnic"},{"location":"getting-started/use-cases/picnic/#picnic","text":"We use Rarible to help us identify NFTs from creators and collectors in the [Picnic] showcase. The [Rarible API] provides a few great endpoints for fetching the necessary data.","title":"Picnic"},{"location":"getting-started/use-cases/picnic/#api-calls","text":"The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org","title":"API Calls"},{"location":"getting-started/use-cases/picnic/#getting-tokens-by-owner","text":"Paginate through owned tokens import axios from 'axios'; /* * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return / const fetchOwnedTokens = async (owner, opts = {}) => { const { continuation, size = 100 } = opts; try { const result = await axios.get('https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner', { params: { owner, continuation }, }); const { data } = result; // Paginate results let hist = []; if (data.continuation && data.items.length === size) { hist = await getOwnedTokens(owner, { ...opts, continuation: data.continuation }); } // Return full history return [...data.items, ...hist]; } catch (err) { console.error(err); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios'; /* * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} / const fetchTokenMetadata = async id => { const { data } = await axios.get( https://api.rarible.com/protocol/v0.1/ethereum/nft/items/${id}/meta ); if (!data?.name) { throw new Error('Invalid NFT data', { id, data }); } return data; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Getting Tokens by Owner"},{"location":"overview/api-reference/","text":"API Reference API in development: https://api-dev.rarible.org/v0.1/doc Ethereum https://ethereum-api.rarible.org/v0.1/doc Use these base URLs to access our API on different Ethereum networks: Base URL Network Chain ID https://ethereum-api.rarible.org/ Mainnet 1 https://ethereum-api-staging.rarible.org/ Rinkeby 4 https://ethereum-api-dev.rarible.org/ Ropsten 3 Source code for the ERC721, ERC1155, Rarible Exchange are available on github: https://github.com/rarible/protocol-contracts","title":"API Reference"},{"location":"overview/api-reference/#api-reference","text":"API in development: https://api-dev.rarible.org/v0.1/doc","title":"API Reference"},{"location":"overview/api-reference/#ethereum","text":"https://ethereum-api.rarible.org/v0.1/doc Use these base URLs to access our API on different Ethereum networks: Base URL Network Chain ID https://ethereum-api.rarible.org/ Mainnet 1 https://ethereum-api-staging.rarible.org/ Rinkeby 4 https://ethereum-api-dev.rarible.org/ Ropsten 3 Source code for the ERC721, ERC1155, Rarible Exchange are available on github: https://github.com/rarible/protocol-contracts","title":"Ethereum"},{"location":"overview/glossary/","text":"Glossary A | B | C | E | I | F | L | M | N | O | P | R | S | T | U A API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type NFT contract type and over information about the contract. Asset Class NFT contract types like ERC-721 or CryptoPunks. B Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain. C Collection Address of the NFT collection. Continuation Continuation token to paginate items search result. Contract Address of the NFT contract. Creator Address of the NFT item creator. E ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations. I Item ID Item identifier has format contract:tokenId . F Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties. L Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer. M Make Making the order, bid, or NFT token. Maker The maker of the order, bid, or NFT token. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain. Minter Minter address. N NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art. O Origin Address of the consumer to receive the commission for order. Owner Address of the NFT item owner. Ownership ID Address of the NFT ownership. P Payouts Value of the payouts for the order. Platform The platform where the order was created. R Royalties Royalties from the NFT contract for the creator. S Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. SDK The software development kit helps developers implement the API using a specific language, TypeScript or Kotlin. Size The number of orders to return. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Sort Sorting by the last update. Supply The number of tokens to be minted. T Take Take the order, bid, or NFT token. Token ID Token identifier. Transaction Hash A unique character identifier that is generated is whenever a transaction is executed. U URI Uniform Resource Identifier of the token.","title":"Glossary"},{"location":"overview/glossary/#glossary","text":"A | B | C | E | I | F | L | M | N | O | P | R | S | T | U","title":"Glossary"},{"location":"overview/glossary/#a","text":"API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type NFT contract type and over information about the contract. Asset Class NFT contract types like ERC-721 or CryptoPunks.","title":"A"},{"location":"overview/glossary/#b","text":"Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain.","title":"B"},{"location":"overview/glossary/#c","text":"Collection Address of the NFT collection. Continuation Continuation token to paginate items search result. Contract Address of the NFT contract. Creator Address of the NFT item creator.","title":"C"},{"location":"overview/glossary/#e","text":"ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations.","title":"E"},{"location":"overview/glossary/#i","text":"Item ID Item identifier has format contract:tokenId .","title":"I"},{"location":"overview/glossary/#f","text":"Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties.","title":"F"},{"location":"overview/glossary/#l","text":"Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer.","title":"L"},{"location":"overview/glossary/#m","text":"Make Making the order, bid, or NFT token. Maker The maker of the order, bid, or NFT token. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain. Minter Minter address.","title":"M"},{"location":"overview/glossary/#n","text":"NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art.","title":"N"},{"location":"overview/glossary/#o","text":"Origin Address of the consumer to receive the commission for order. Owner Address of the NFT item owner. Ownership ID Address of the NFT ownership.","title":"O"},{"location":"overview/glossary/#p","text":"Payouts Value of the payouts for the order. Platform The platform where the order was created.","title":"P"},{"location":"overview/glossary/#r","text":"Royalties Royalties from the NFT contract for the creator.","title":"R"},{"location":"overview/glossary/#s","text":"Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. SDK The software development kit helps developers implement the API using a specific language, TypeScript or Kotlin. Size The number of orders to return. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Sort Sorting by the last update. Supply The number of tokens to be minted.","title":"S"},{"location":"overview/glossary/#t","text":"Take Take the order, bid, or NFT token. Token ID Token identifier. Transaction Hash A unique character identifier that is generated is whenever a transaction is executed.","title":"T"},{"location":"overview/glossary/#u","text":"URI Uniform Resource Identifier of the token.","title":"U"},{"location":"overview/reasons/","text":"Why build on Rarible protocol? Rarible pursues the goal of creating a highly liquid environment for all NFTs out there: a robust on-chain protocol designed for NFTs to exist in a connected space. A separate initiative with a dedicated team will enable direct interactions with the protocol from multiple front ends like storefronts or wallets, offering additional distribution channels and enhancing liquidity. It will also fuel the discovery of new NFT trading mechanics. NFT protocol designed by Rarible for all, owned and governed by the community. In this regard, a special place in the initiative is reserved for Rarible native governance token $RARI as the basic building block for the future NFT ecosystem. Supply and demand of the whole Rarible ecosystem Rarible is one of the biggest NFT marketplaces out there with over $64 million in total lifetime volume and 57k monthly protocol users, slick UX, and a variety of use cases across industries. You can utilize the shared order book with Rarible. Advanced and robust tech done for you Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years with wide functionality and data on all the NFTs created. Monetization Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations. Decentralized autonomous organization (DAO) Rarible is steadily moving towards becoming a fully decentralized autonomous organization. The DAO will offer multiple opportunities for creators to get funding and exposure. It will incentivize people to build on top of the protocol, and we expect the DAO to reward the early builders.","title":"Reasons for using protocol"},{"location":"overview/reasons/#why-build-on-rarible-protocol","text":"Rarible pursues the goal of creating a highly liquid environment for all NFTs out there: a robust on-chain protocol designed for NFTs to exist in a connected space. A separate initiative with a dedicated team will enable direct interactions with the protocol from multiple front ends like storefronts or wallets, offering additional distribution channels and enhancing liquidity. It will also fuel the discovery of new NFT trading mechanics. NFT protocol designed by Rarible for all, owned and governed by the community. In this regard, a special place in the initiative is reserved for Rarible native governance token $RARI as the basic building block for the future NFT ecosystem.","title":"Why build on Rarible protocol?"},{"location":"overview/reasons/#supply-and-demand-of-the-whole-rarible-ecosystem","text":"Rarible is one of the biggest NFT marketplaces out there with over $64 million in total lifetime volume and 57k monthly protocol users, slick UX, and a variety of use cases across industries. You can utilize the shared order book with Rarible.","title":"Supply and demand of the whole Rarible ecosystem"},{"location":"overview/reasons/#advanced-and-robust-tech-done-for-you","text":"Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years with wide functionality and data on all the NFTs created.","title":"Advanced and robust tech done for you"},{"location":"overview/reasons/#monetization","text":"Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.","title":"Monetization"},{"location":"overview/reasons/#decentralized-autonomous-organization-dao","text":"Rarible is steadily moving towards becoming a fully decentralized autonomous organization. The DAO will offer multiple opportunities for creators to get funding and exposure. It will incentivize people to build on top of the protocol, and we expect the DAO to reward the early builders.","title":"Decentralized autonomous organization (DAO)"},{"location":"overview/resources/","text":"Resources DAO If you're a builder or you're looking to participate to the Rarible Protocol DAO here are a few useful places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organised, and builders take their first steps towards building with the protocol. Github is where everything lives, since we are open-source, a lot of resources and help from other builders are available there. Notion is the platform where we hold information for DAO members and $RARI token holders. OpenAPI is the place where we document the current API capabilities. Submitting You are welcome to suggest features and report bugs found! You can do it here: Submit a feature request Submit a question Hackathon docs Rarible Hackathon Docs HackMD by Isaac","title":"Resources"},{"location":"overview/resources/#resources","text":"","title":"Resources"},{"location":"overview/resources/#dao","text":"If you're a builder or you're looking to participate to the Rarible Protocol DAO here are a few useful places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organised, and builders take their first steps towards building with the protocol. Github is where everything lives, since we are open-source, a lot of resources and help from other builders are available there. Notion is the platform where we hold information for DAO members and $RARI token holders. OpenAPI is the place where we document the current API capabilities.","title":"DAO"},{"location":"overview/resources/#submitting","text":"You are welcome to suggest features and report bugs found! You can do it here: Submit a feature request Submit a question","title":"Submitting"},{"location":"overview/resources/#hackathon-docs","text":"Rarible Hackathon Docs HackMD by Isaac","title":"Hackathon docs"},{"location":"resources/meetings/meeting-doc-15th-of-october/","text":"Meeting document for dev meeting on the 15th of October. Github https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've recently started also looking through github discussions, and cherry picking the ones with high priority, but for this week all github discussions are either answered or more clarification is needed. Discord Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. alexon#6056 Quote: \"I was just trying to do this on rinkeby but it failed for me with INCORRECT_LAZY_NFT Invalid creator and signature size. Did this ever work for you?\" Quote 2: \"It\u2019s about minting an 1155 with 2+ more creators. The signature part keeps failing because there\u2019s only one signature in the request, mine, and not from the other creators. I was just wondering how we could mint an nft with 2+ creators if only one of the creators is the one doing the mint action.\" Answer: You should include signatures for every creator (and you can include zero-length signature for the creator who is executing transaction) inartin#9707 Quote: \"Is there an API call that will return ALL types of order activities? Not a separate one but all of them at once, MINT, TRANSFER, BURN, BID, LIST, SELL (or MATCH)? The getNftOrderAllActivities does not have the Sell or MATCH type (it has in the documentation but it was a typo and will be removed from docs).... So, how do I get all activities in one API call? \" Answer: https://ethereum-api-dev.rarible.org/v0.1/doc#operation/getNftOrderAllActivities There is a SELL type chusla#6031 Quote: \"Should a minted (bought and minted not just lazy minted) nft that's been burned still be visible on rarible.com? Etherscan shows it's been burned. Do these also have to be manually deleted in lazy db? https://etherscan.io/tx/0xb496e0e664c4529020ebd4ba5d2734f0d9aa1ecf2bacaeaa499d7ee1542da5e2. Thank you! trying to come with a plan of action to clear the collection for new mints If they do need to be manually deleted can we include in list of items to be cleared this week? Thank you!\" Answer: \"If it was fully burned, it should not appear on .com\" Quote: \"Thanks Eduard we might want to test or check this if you burn an item even in rinkeby after it's been bought or minted it just goes back to the original owner. The original owner can then put it back in for sale and then it can get purchased again! Fyi screen above shows history of an item that was put back on sale AFTER being burned. I am have confirmed in rinkeby that this item can also be repurchased a second time by the buyer after it was burned.\" Andrew has also opened an issue here: https://github.com/rarible/protocol-issues/issues/135 Answer: This looks like a serious bug. Will wix it. mynamebrody#5466 Quote: \"Don't have time at the moment to write up an issue, but the production API endpoint for bidsByItem has \"valueDecimal\": null, under the make object, where in the rinkeby/ropsten version of the API return the value field as ETH instead of GWEI\" Answer: This is because prod version was not updated to the latest version. I think everything should be fine now. tgb2929#1533 Quote: \"When creating a sell order using the SDK, if we want to sell for Ether, what do we input here: \"takeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address }\" https://docs.rarible.org/sdk#create-sell-order\" Answer: you should use assetClass: \"ETH\" for this and not \"ERC20\" Quote 2: \"I'm using the SDK to create Buy orders. The issue is that almost always on the first buy attempt, the estimated gas fee is several Ether, which isn't really true. If I close and try again, then usually it's more reasonable. Anyone know how to deal with handling buy orders and showing reasonable gas fees?\" Answer: Pls, give me tx or item example or code example, what you trying to do. What amount of gas is calculated in the wallet? lazycaramel#4474 Quote: \"Hey guys, I was interested if I could use ERC1155Factory directly, or should I use SDK? Also, what's the caveat to using this vs deploying my own ERC1155? Is there some kind of lock-in with Rarible taking 2.5% on each token sale even outside of the platform?\" Answer: ERC1155Factory creates a proxy to our contract implementation, Rarible protocol will upgrade these tokens when new features are available. You can use your own version of the token contract. It's not related to 2.5% on each sale. 2.5% for each sale is taken by rarible.com website when order is created. Rhabdodon#4653 Quote: \"We've been experiencing a tremendous amount of interest and usage of cocoNFT which is amazing! Want to first thank you all for the support along the way! \u2764\ufe0f I also wanted to share the 5 biggest pieces of feedback we're getting from users that are related to the protocol. Users want to be able to burn lazy minted NFTs without paying gas fees. There is certainly confusion around this. Users also want to be able to remove lazy minted NFTs from sale without paying gas fees. Users want more sale types supported (i.e. auctions for 721 and Open for Bids for 1155s). We're on an 1155 collection so the latter would be particularly helpful. Users want to setup their Rarible profile within cocoNFT. They don't understand why they have 2 different profiles. I really think the Rarible protocol could do something cool here for the ecosystem by building a unified profile system similar to what exists on Tezos but maybe the Rarible one is cross-chain. Users want to change the price for their lazy minted NFTs (I believe this is coming soon!)\" Answer: I think we covered this on the call. We will implement feature to burn lazy minted NFTs with 2 options: 1. by just removing from the website. 2. by calling contract to invalidate signatures agamanin#2389 Quote: \"Hi. I'm new to the community, glad to be here. I have a question about the protocol smart contracts licensing. There is no LICENCE file on github. Some research indicates that it means 'forbidden for private or commercial use' (i.e. https://github.com/github/choosealicense.com/issues/196). Does it basically mean one cannot fork it, then adapt to her own needs (i.e. change the protocol fees structure, and the fee recipient address) and run her own markeplace? \ud83d\ude42 An open github issue with similar question does not make it more transparent as well Also, 77 forks (at the moment of writing) would only make sense for educational purposes in this case, right?\" Answer - Eduard: AFAIK, anyone is allowed to fork and use rarible-protocol code for their own projects and whatnot. It's open source. Quote: \"Wow, that would be just great. BTW, as far as I can understand, tools like https://one2all.io/ already do this - they let anyone set an arbitrary fee recipient and assign the fee structure. But they may have special permission of Rarible to do that, I don't know. Anyhow, having a more explicit license stating what can be done and what cannot would be beneficial for everyone.\" Answer - Eugene: Thanks, we will check if licenses are set everywhere. If you are talking about protocol-contracts repo, then MIT license should be set there. Unnatural Space#0655 Quote: \"is the rarible protocol compatible with polygon network?\" Answer - Eduard: I'd have answered that it's in the plans to be implemented soon, but Eugene, it'd be best for a more accurate answer. Answer - Eugene: It's WIP. Will be live in the end of the year, may be soonerhttps://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28 chusla#6031 Quote: \"Hi all question on sdk. My recent understanding is that the mint function automatically generates the contract token ID. But how does this work with including token id in external URI in Json metadata? Don't we need to generate token id before Json/ipfs upload and then mint? Any thoughts on this much appreciated. Seems like there may be an order of operations issue here? I've been doing some testing and think lack of token id on external URI May cause issue with opensea rendering. Previously we were able to do in two steps. Generate token id, then get ipfs content id then mint. Would be great to discuss on today's call thanks!\" Answer: We covered this on the call. Pls see https://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28","title":"Meeting doc 15th of october"},{"location":"resources/meetings/meeting-doc-15th-of-october/#github","text":"https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've recently started also looking through github discussions, and cherry picking the ones with high priority, but for this week all github discussions are either answered or more clarification is needed.","title":"Github"},{"location":"resources/meetings/meeting-doc-15th-of-october/#discord","text":"Some matters have been raised in the #dev-general channel to be discussed in today's meeting. Apart from discussing those, we will also be discussing the questions that weren't properly answered throught the past 7 days, and we'll follow up individually with everyone who's listed down below for a question. All people listed below have also been invited to participate this dev call. alexon#6056 Quote: \"I was just trying to do this on rinkeby but it failed for me with INCORRECT_LAZY_NFT Invalid creator and signature size. Did this ever work for you?\" Quote 2: \"It\u2019s about minting an 1155 with 2+ more creators. The signature part keeps failing because there\u2019s only one signature in the request, mine, and not from the other creators. I was just wondering how we could mint an nft with 2+ creators if only one of the creators is the one doing the mint action.\" Answer: You should include signatures for every creator (and you can include zero-length signature for the creator who is executing transaction) inartin#9707 Quote: \"Is there an API call that will return ALL types of order activities? Not a separate one but all of them at once, MINT, TRANSFER, BURN, BID, LIST, SELL (or MATCH)? The getNftOrderAllActivities does not have the Sell or MATCH type (it has in the documentation but it was a typo and will be removed from docs).... So, how do I get all activities in one API call? \" Answer: https://ethereum-api-dev.rarible.org/v0.1/doc#operation/getNftOrderAllActivities There is a SELL type chusla#6031 Quote: \"Should a minted (bought and minted not just lazy minted) nft that's been burned still be visible on rarible.com? Etherscan shows it's been burned. Do these also have to be manually deleted in lazy db? https://etherscan.io/tx/0xb496e0e664c4529020ebd4ba5d2734f0d9aa1ecf2bacaeaa499d7ee1542da5e2. Thank you! trying to come with a plan of action to clear the collection for new mints If they do need to be manually deleted can we include in list of items to be cleared this week? Thank you!\" Answer: \"If it was fully burned, it should not appear on .com\" Quote: \"Thanks Eduard we might want to test or check this if you burn an item even in rinkeby after it's been bought or minted it just goes back to the original owner. The original owner can then put it back in for sale and then it can get purchased again! Fyi screen above shows history of an item that was put back on sale AFTER being burned. I am have confirmed in rinkeby that this item can also be repurchased a second time by the buyer after it was burned.\" Andrew has also opened an issue here: https://github.com/rarible/protocol-issues/issues/135 Answer: This looks like a serious bug. Will wix it. mynamebrody#5466 Quote: \"Don't have time at the moment to write up an issue, but the production API endpoint for bidsByItem has \"valueDecimal\": null, under the make object, where in the rinkeby/ropsten version of the API return the value field as ETH instead of GWEI\" Answer: This is because prod version was not updated to the latest version. I think everything should be fine now. tgb2929#1533 Quote: \"When creating a sell order using the SDK, if we want to sell for Ether, what do we input here: \"takeAssetType: { assetClass: \"ERC20\", contract: contractErc20Address }\" https://docs.rarible.org/sdk#create-sell-order\" Answer: you should use assetClass: \"ETH\" for this and not \"ERC20\" Quote 2: \"I'm using the SDK to create Buy orders. The issue is that almost always on the first buy attempt, the estimated gas fee is several Ether, which isn't really true. If I close and try again, then usually it's more reasonable. Anyone know how to deal with handling buy orders and showing reasonable gas fees?\" Answer: Pls, give me tx or item example or code example, what you trying to do. What amount of gas is calculated in the wallet? lazycaramel#4474 Quote: \"Hey guys, I was interested if I could use ERC1155Factory directly, or should I use SDK? Also, what's the caveat to using this vs deploying my own ERC1155? Is there some kind of lock-in with Rarible taking 2.5% on each token sale even outside of the platform?\" Answer: ERC1155Factory creates a proxy to our contract implementation, Rarible protocol will upgrade these tokens when new features are available. You can use your own version of the token contract. It's not related to 2.5% on each sale. 2.5% for each sale is taken by rarible.com website when order is created. Rhabdodon#4653 Quote: \"We've been experiencing a tremendous amount of interest and usage of cocoNFT which is amazing! Want to first thank you all for the support along the way! \u2764\ufe0f I also wanted to share the 5 biggest pieces of feedback we're getting from users that are related to the protocol. Users want to be able to burn lazy minted NFTs without paying gas fees. There is certainly confusion around this. Users also want to be able to remove lazy minted NFTs from sale without paying gas fees. Users want more sale types supported (i.e. auctions for 721 and Open for Bids for 1155s). We're on an 1155 collection so the latter would be particularly helpful. Users want to setup their Rarible profile within cocoNFT. They don't understand why they have 2 different profiles. I really think the Rarible protocol could do something cool here for the ecosystem by building a unified profile system similar to what exists on Tezos but maybe the Rarible one is cross-chain. Users want to change the price for their lazy minted NFTs (I believe this is coming soon!)\" Answer: I think we covered this on the call. We will implement feature to burn lazy minted NFTs with 2 options: 1. by just removing from the website. 2. by calling contract to invalidate signatures agamanin#2389 Quote: \"Hi. I'm new to the community, glad to be here. I have a question about the protocol smart contracts licensing. There is no LICENCE file on github. Some research indicates that it means 'forbidden for private or commercial use' (i.e. https://github.com/github/choosealicense.com/issues/196). Does it basically mean one cannot fork it, then adapt to her own needs (i.e. change the protocol fees structure, and the fee recipient address) and run her own markeplace? \ud83d\ude42 An open github issue with similar question does not make it more transparent as well Also, 77 forks (at the moment of writing) would only make sense for educational purposes in this case, right?\" Answer - Eduard: AFAIK, anyone is allowed to fork and use rarible-protocol code for their own projects and whatnot. It's open source. Quote: \"Wow, that would be just great. BTW, as far as I can understand, tools like https://one2all.io/ already do this - they let anyone set an arbitrary fee recipient and assign the fee structure. But they may have special permission of Rarible to do that, I don't know. Anyhow, having a more explicit license stating what can be done and what cannot would be beneficial for everyone.\" Answer - Eugene: Thanks, we will check if licenses are set everywhere. If you are talking about protocol-contracts repo, then MIT license should be set there. Unnatural Space#0655 Quote: \"is the rarible protocol compatible with polygon network?\" Answer - Eduard: I'd have answered that it's in the plans to be implemented soon, but Eugene, it'd be best for a more accurate answer. Answer - Eugene: It's WIP. Will be live in the end of the year, may be soonerhttps://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28 chusla#6031 Quote: \"Hi all question on sdk. My recent understanding is that the mint function automatically generates the contract token ID. But how does this work with including token id in external URI in Json metadata? Don't we need to generate token id before Json/ipfs upload and then mint? Any thoughts on this much appreciated. Seems like there may be an order of operations issue here? I've been doing some testing and think lack of token id on external URI May cause issue with opensea rendering. Previously we were able to do in two steps. Generate token id, then get ipfs content id then mint. Would be great to discuss on today's call thanks!\" Answer: We covered this on the call. Pls see https://github.com/rarible/protocol-ethereum-sdk/blob/7212730302a2a34e42018b6a02676dd589458ff8/packages/protocol-ethereum-sdk/src/nft/mint.ts#L28","title":"Discord"},{"location":"resources/meetings/meeting-doc-8th-of-october/","text":"Meeting document for dev meeting on the 8th of October. Addresing the https://api-staging.rarible.com/ to https://ethereum-api.rarible.org/ replacement in the docs. There are 4 instances where api-staging is used in the docs. 1. https://docs.rarible.org/example-projects/picnic#api-calls 2. https://docs.rarible.org/exchange/order-discovery#search-orders 3. https://docs.rarible.org/exchange/creating-a-sell-order#creating-an-order 4. https://docs.rarible.org/asset/creating-an-asset#erc1155-lazy-minting Github https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've realised that discussions that are not in the Q&A section won't get indexed in the link above so I've changed the section for a few of them, that's the reason there might be some older questions in there. Discord All members who have a question listed below have been invited to participate in this call All members will be notified about the answer to their question privately or in #dev-general (discord) Only the past 7 days of unanswered questions are indexed here. Konstantin#3916 Quote: \"The question for lazy mint. Can I mint nft myself from order? For example, I will hit any sales order with a lazy mint, and I just do mint nft. Will the excenge method be able to make a new duplicate nft since the order remains?\" Answer: No, if it was minted, then no more NFT's will be minted. It's controlled by the smart contract. So if we're talking about ERC721 of course not because they're unique. If we're talking about ERC1155 no, the total supply of the token is controlled by the smart contract so if there's a message saying only 5 will be minted, no more will be minted. Rhabdodon#4653 Quote: \"Thanks! Would love an update on how we're addressing this on the protocol. I believe @Eugene Nacu | Rarible has an idea for how we can address this but needs someone to work on it.\" \"this\" meant: \"Regarding the opensea bug it's caused by the function in the lazy minting contract that does the minting transfer as it was originally calling the function doing the minting at the Blackhole address and then doing the transfer to the OpenSea address. The fix requires minting, sending to the creator of the lazy minter address and then to the buyer vs minting and sending from the blackHole address.\" \"@Eugene Nacu | Rarible do you think a fix to the OpenSea issue would be completed and shipped by the end of the week?\" Answer: Skipped -- alexon#6056 Quote: \"Is there a way to use the protocol-ethereum-sdk in node without having to pass a web3 instance (since I don't need it)\" \"I just tried it by configuring a web3 instance in node, but I'm getting FormData is not defined. So I'm guessing the sdk is not meant to be used in node then?\" Answer: It can be used in node, look in tests, here's a walkaround. Link with example: https://github.com/rarible/protocol-ethereum-sdk/blob/master/packages/protocol-ethereum-sdk/jest.setup.js Laviniao#9840 Quote: \"Hi, does anyone in this chat know when L2 will be available on rarible?\" \"Also, will generative art projects be able to be minted on platforms built on the protocol, in reglf to the smart contract element?\" Answer: If you consider polygon to be L2, the exact implementation date is not known, but we'll start looking into it in the first week of November. Peter Watts#5307 Quote: \"Hi. Is there a delay when adding Royalties to existing external contract? I followed the steps here (https://docs.rarible.org/asset/royalties-on-a-external-collection) and tx is here (https://etherscan.io/tx/0xb5f625595fed64d629818401b61342d1f0443867fa866fe588d442f36804f834) but it doesn't show up when selling on Rarible, nor when querying the API (https://api.rarible.com/protocol/v0.1/ethereum/nft/items/0x819327e005a3ed85f7b634e195b8f25d4a2a45f8:35739319466029867409935893104794648465119721019613204601875682368845852747852?includeMeta=true)\" Answer: Add to github issues. AzFlin#5259 Quote: \"hey, can we not post a fixed price auction on rarible UI with an expiration date?\" Answer: Not yet. It will be available soon (almost implemented). When you create a sell/bid order you will be able to set an end date for the order. It almost works, soon will be on rarible.com as well. Will prioritise this task. Alexandr Devyatkin#4906 Quote: \"Hi! Having trouble with local publishing scala-rpc. While using sbt publishM2 i receive this error: unable to locate a valid GitHub token from GitConfig(token). Which token could be used in that case? Thanks in advance. Link to repo: https://github.com/rarible/scala-rpc\" Answer: This matter was already discussed between Eugene and Alexandr. bold#5220 Quote: \"Hey devs, many of these NFT projects (BAYC, Cool Cats, Pudgy Penguins, etc.) don't have the Rarible Royalties contracts built in. So do they just not receive royalties if traded on Rarible Marketplace, or does Rarible set up some kind of proxy contracts to account for royalties for them?\" \"@Eugene Nacu | Rarible just want to confirm that going forward with a custom contract, I'd only have to include the EIP-2981 standard and not the overall RaribleRoyalties contracts found on Rarible's github, right?\" Answer: Rarible exchange contract uses royalty registry. For some time there is a feature on rarible.com to update royalties for a specific collection, so creators of the collection can override and set custom royalties for their collections. Also if for example artblocks doesn't implement rarible royalties, but we implement this proxy contract to convert the royalties to our format and registered it, it works. Anyone from these contracts can register and override royalties on rarible. Answer for the EIP-2981 question: Currently it's not the case so exchange contract doesn't follow this standard but it will. This issue will be solved after we finish the auction contract. nullren#4914 Quote: \"for properties on an nft detail page, does rarible use the same metadata attributes as opensea? or does it use the enjin properties? ie following or does rarible have it's own version of this https://docs.opensea.io/docs/metadata-standards\" Answer: It's the same as opensea, so not like our own standard, we pretty much follow what opensea does. NiFTiChristian#7535 Quote: \"I'm using the ethereum sdk to create an order, but I get a 404: https://ethereum-api-staging.rarible.org/v0.1/nft/items/0x03c592e5f277C37A3e8dEE74f743a7972e5BF51B%3A1/lazy 404 has anyone experienced this while using the SDK?\" Answer: Add to github issues.","title":"Meeting doc 8th of october"},{"location":"resources/meetings/meeting-doc-8th-of-october/#addresing-the-httpsapi-stagingrariblecom-to-httpsethereum-apiraribleorg-replacement-in-the-docs","text":"There are 4 instances where api-staging is used in the docs. 1. https://docs.rarible.org/example-projects/picnic#api-calls 2. https://docs.rarible.org/exchange/order-discovery#search-orders 3. https://docs.rarible.org/exchange/creating-a-sell-order#creating-an-order 4. https://docs.rarible.org/asset/creating-an-asset#erc1155-lazy-minting","title":"Addresing the https://api-staging.rarible.com/ to https://ethereum-api.rarible.org/ replacement in the docs."},{"location":"resources/meetings/meeting-doc-8th-of-october/#github","text":"https://github.com/rarible/protocol-issues/discussions?discussions_q=is%3Aunanswered I've realised that discussions that are not in the Q&A section won't get indexed in the link above so I've changed the section for a few of them, that's the reason there might be some older questions in there.","title":"Github"},{"location":"resources/meetings/meeting-doc-8th-of-october/#discord","text":"All members who have a question listed below have been invited to participate in this call All members will be notified about the answer to their question privately or in #dev-general (discord) Only the past 7 days of unanswered questions are indexed here. Konstantin#3916 Quote: \"The question for lazy mint. Can I mint nft myself from order? For example, I will hit any sales order with a lazy mint, and I just do mint nft. Will the excenge method be able to make a new duplicate nft since the order remains?\" Answer: No, if it was minted, then no more NFT's will be minted. It's controlled by the smart contract. So if we're talking about ERC721 of course not because they're unique. If we're talking about ERC1155 no, the total supply of the token is controlled by the smart contract so if there's a message saying only 5 will be minted, no more will be minted. Rhabdodon#4653 Quote: \"Thanks! Would love an update on how we're addressing this on the protocol. I believe @Eugene Nacu | Rarible has an idea for how we can address this but needs someone to work on it.\" \"this\" meant: \"Regarding the opensea bug it's caused by the function in the lazy minting contract that does the minting transfer as it was originally calling the function doing the minting at the Blackhole address and then doing the transfer to the OpenSea address. The fix requires minting, sending to the creator of the lazy minter address and then to the buyer vs minting and sending from the blackHole address.\" \"@Eugene Nacu | Rarible do you think a fix to the OpenSea issue would be completed and shipped by the end of the week?\" Answer: Skipped -- alexon#6056 Quote: \"Is there a way to use the protocol-ethereum-sdk in node without having to pass a web3 instance (since I don't need it)\" \"I just tried it by configuring a web3 instance in node, but I'm getting FormData is not defined. So I'm guessing the sdk is not meant to be used in node then?\" Answer: It can be used in node, look in tests, here's a walkaround. Link with example: https://github.com/rarible/protocol-ethereum-sdk/blob/master/packages/protocol-ethereum-sdk/jest.setup.js Laviniao#9840 Quote: \"Hi, does anyone in this chat know when L2 will be available on rarible?\" \"Also, will generative art projects be able to be minted on platforms built on the protocol, in reglf to the smart contract element?\" Answer: If you consider polygon to be L2, the exact implementation date is not known, but we'll start looking into it in the first week of November. Peter Watts#5307 Quote: \"Hi. Is there a delay when adding Royalties to existing external contract? I followed the steps here (https://docs.rarible.org/asset/royalties-on-a-external-collection) and tx is here (https://etherscan.io/tx/0xb5f625595fed64d629818401b61342d1f0443867fa866fe588d442f36804f834) but it doesn't show up when selling on Rarible, nor when querying the API (https://api.rarible.com/protocol/v0.1/ethereum/nft/items/0x819327e005a3ed85f7b634e195b8f25d4a2a45f8:35739319466029867409935893104794648465119721019613204601875682368845852747852?includeMeta=true)\" Answer: Add to github issues. AzFlin#5259 Quote: \"hey, can we not post a fixed price auction on rarible UI with an expiration date?\" Answer: Not yet. It will be available soon (almost implemented). When you create a sell/bid order you will be able to set an end date for the order. It almost works, soon will be on rarible.com as well. Will prioritise this task. Alexandr Devyatkin#4906 Quote: \"Hi! Having trouble with local publishing scala-rpc. While using sbt publishM2 i receive this error: unable to locate a valid GitHub token from GitConfig(token). Which token could be used in that case? Thanks in advance. Link to repo: https://github.com/rarible/scala-rpc\" Answer: This matter was already discussed between Eugene and Alexandr. bold#5220 Quote: \"Hey devs, many of these NFT projects (BAYC, Cool Cats, Pudgy Penguins, etc.) don't have the Rarible Royalties contracts built in. So do they just not receive royalties if traded on Rarible Marketplace, or does Rarible set up some kind of proxy contracts to account for royalties for them?\" \"@Eugene Nacu | Rarible just want to confirm that going forward with a custom contract, I'd only have to include the EIP-2981 standard and not the overall RaribleRoyalties contracts found on Rarible's github, right?\" Answer: Rarible exchange contract uses royalty registry. For some time there is a feature on rarible.com to update royalties for a specific collection, so creators of the collection can override and set custom royalties for their collections. Also if for example artblocks doesn't implement rarible royalties, but we implement this proxy contract to convert the royalties to our format and registered it, it works. Anyone from these contracts can register and override royalties on rarible. Answer for the EIP-2981 question: Currently it's not the case so exchange contract doesn't follow this standard but it will. This issue will be solved after we finish the auction contract. nullren#4914 Quote: \"for properties on an nft detail page, does rarible use the same metadata attributes as opensea? or does it use the enjin properties? ie following or does rarible have it's own version of this https://docs.opensea.io/docs/metadata-standards\" Answer: It's the same as opensea, so not like our own standard, we pretty much follow what opensea does. NiFTiChristian#7535 Quote: \"I'm using the ethereum sdk to create an order, but I get a 404: https://ethereum-api-staging.rarible.org/v0.1/nft/items/0x03c592e5f277C37A3e8dEE74f743a7972e5BF51B%3A1/lazy 404 has anyone experienced this while using the SDK?\" Answer: Add to github issues.","title":"Discord"},{"location":"tezos/tezos-overview/","text":"Tezos overview Tezos is an open-source platform for assets and applications that can evolve by upgrading itself. Protocol Flow ... SDK ... Smart Contracts ...","title":"Tezos overview"},{"location":"tezos/tezos-overview/#tezos-overview","text":"Tezos is an open-source platform for assets and applications that can evolve by upgrading itself.","title":"Tezos overview"},{"location":"tezos/tezos-overview/#protocol-flow","text":"...","title":"Protocol Flow"},{"location":"tezos/tezos-overview/#sdk","text":"...","title":"SDK"},{"location":"tezos/tezos-overview/#smart-contracts","text":"...","title":"Smart Contracts"}]}